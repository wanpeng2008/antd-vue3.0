(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("vue"));
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["antd-vue3"] = factory(require("vue"));
	else
		root["antd-vue3"] = factory(root["Vue"]);
})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__8bbf__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fb15");
/******/ })
/************************************************************************/
/******/ ({

/***/ "00fd":
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__("9e69");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "010e":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var uzLatn = moment.defineLocale('uz-latn', {
        months : 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
        monthsShort : 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
        weekdays : 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
        weekdaysShort : 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
        weekdaysMin : 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'D MMMM YYYY, dddd HH:mm'
        },
        calendar : {
            sameDay : '[Bugun soat] LT [da]',
            nextDay : '[Ertaga] LT [da]',
            nextWeek : 'dddd [kuni soat] LT [da]',
            lastDay : '[Kecha soat] LT [da]',
            lastWeek : '[O\'tgan] dddd [kuni soat] LT [da]',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'Yaqin %s ichida',
            past : 'Bir necha %s oldin',
            s : 'soniya',
            ss : '%d soniya',
            m : 'bir daqiqa',
            mm : '%d daqiqa',
            h : 'bir soat',
            hh : '%d soat',
            d : 'bir kun',
            dd : '%d kun',
            M : 'bir oy',
            MM : '%d oy',
            y : 'bir yil',
            yy : '%d yil'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return uzLatn;

})));


/***/ }),

/***/ "02fb":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var ml = moment.defineLocale('ml', {
        months : 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split('_'),
        monthsShort : 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split('_'),
        monthsParseExact : true,
        weekdays : 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split('_'),
        weekdaysShort : 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
        weekdaysMin : 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
        longDateFormat : {
            LT : 'A h:mm -നു',
            LTS : 'A h:mm:ss -നു',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm -നു',
            LLLL : 'dddd, D MMMM YYYY, A h:mm -നു'
        },
        calendar : {
            sameDay : '[ഇന്ന്] LT',
            nextDay : '[നാളെ] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[ഇന്നലെ] LT',
            lastWeek : '[കഴിഞ്ഞ] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s കഴിഞ്ഞ്',
            past : '%s മുൻപ്',
            s : 'അൽപ നിമിഷങ്ങൾ',
            ss : '%d സെക്കൻഡ്',
            m : 'ഒരു മിനിറ്റ്',
            mm : '%d മിനിറ്റ്',
            h : 'ഒരു മണിക്കൂർ',
            hh : '%d മണിക്കൂർ',
            d : 'ഒരു ദിവസം',
            dd : '%d ദിവസം',
            M : 'ഒരു മാസം',
            MM : '%d മാസം',
            y : 'ഒരു വർഷം',
            yy : '%d വർഷം'
        },
        meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === 'രാത്രി' && hour >= 4) ||
                    meridiem === 'ഉച്ച കഴിഞ്ഞ്' ||
                    meridiem === 'വൈകുന്നേരം') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'രാത്രി';
            } else if (hour < 12) {
                return 'രാവിലെ';
            } else if (hour < 17) {
                return 'ഉച്ച കഴിഞ്ഞ്';
            } else if (hour < 20) {
                return 'വൈകുന്നേരം';
            } else {
                return 'രാത്രി';
            }
        }
    });

    return ml;

})));


/***/ }),

/***/ "03dd":
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__("eac5"),
    nativeKeys = __webpack_require__("57a5");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ "03ec":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var cv = moment.defineLocale('cv', {
        months : 'кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав'.split('_'),
        monthsShort : 'кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш'.split('_'),
        weekdays : 'вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун'.split('_'),
        weekdaysShort : 'выр_тун_ытл_юн_кӗҫ_эрн_шӑм'.split('_'),
        weekdaysMin : 'вр_тн_ыт_юн_кҫ_эр_шм'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]',
            LLL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
            LLLL : 'dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm'
        },
        calendar : {
            sameDay: '[Паян] LT [сехетре]',
            nextDay: '[Ыран] LT [сехетре]',
            lastDay: '[Ӗнер] LT [сехетре]',
            nextWeek: '[Ҫитес] dddd LT [сехетре]',
            lastWeek: '[Иртнӗ] dddd LT [сехетре]',
            sameElse: 'L'
        },
        relativeTime : {
            future : function (output) {
                var affix = /сехет$/i.exec(output) ? 'рен' : /ҫул$/i.exec(output) ? 'тан' : 'ран';
                return output + affix;
            },
            past : '%s каялла',
            s : 'пӗр-ик ҫеккунт',
            ss : '%d ҫеккунт',
            m : 'пӗр минут',
            mm : '%d минут',
            h : 'пӗр сехет',
            hh : '%d сехет',
            d : 'пӗр кун',
            dd : '%d кун',
            M : 'пӗр уйӑх',
            MM : '%d уйӑх',
            y : 'пӗр ҫул',
            yy : '%d ҫул'
        },
        dayOfMonthOrdinalParse: /\d{1,2}-мӗш/,
        ordinal : '%d-мӗш',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return cv;

})));


/***/ }),

/***/ "0558":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function plural(n) {
        if (n % 100 === 11) {
            return true;
        } else if (n % 10 === 1) {
            return false;
        }
        return true;
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                return withoutSuffix || isFuture ? 'nokkrar sekúndur' : 'nokkrum sekúndum';
            case 'ss':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'sekúndur' : 'sekúndum');
                }
                return result + 'sekúnda';
            case 'm':
                return withoutSuffix ? 'mínúta' : 'mínútu';
            case 'mm':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum');
                } else if (withoutSuffix) {
                    return result + 'mínúta';
                }
                return result + 'mínútu';
            case 'hh':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
                }
                return result + 'klukkustund';
            case 'd':
                if (withoutSuffix) {
                    return 'dagur';
                }
                return isFuture ? 'dag' : 'degi';
            case 'dd':
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + 'dagar';
                    }
                    return result + (isFuture ? 'daga' : 'dögum');
                } else if (withoutSuffix) {
                    return result + 'dagur';
                }
                return result + (isFuture ? 'dag' : 'degi');
            case 'M':
                if (withoutSuffix) {
                    return 'mánuður';
                }
                return isFuture ? 'mánuð' : 'mánuði';
            case 'MM':
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + 'mánuðir';
                    }
                    return result + (isFuture ? 'mánuði' : 'mánuðum');
                } else if (withoutSuffix) {
                    return result + 'mánuður';
                }
                return result + (isFuture ? 'mánuð' : 'mánuði');
            case 'y':
                return withoutSuffix || isFuture ? 'ár' : 'ári';
            case 'yy':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
                }
                return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
        }
    }

    var is = moment.defineLocale('is', {
        months : 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
        weekdays : 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split('_'),
        weekdaysShort : 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
        weekdaysMin : 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] H:mm',
            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
        },
        calendar : {
            sameDay : '[í dag kl.] LT',
            nextDay : '[á morgun kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[í gær kl.] LT',
            lastWeek : '[síðasta] dddd [kl.] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'eftir %s',
            past : 'fyrir %s síðan',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : 'klukkustund',
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return is;

})));


/***/ }),

/***/ "0621":
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__("9e69"),
    isArguments = __webpack_require__("d370"),
    isArray = __webpack_require__("6747");

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),

/***/ "0644":
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__("3818");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),

/***/ "0676":
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),

/***/ "0721":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var fo = moment.defineLocale('fo', {
        months : 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split('_'),
        weekdaysShort : 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
        weekdaysMin : 'su_má_tý_mi_hó_fr_le'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D. MMMM, YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Í dag kl.] LT',
            nextDay : '[Í morgin kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[Í gjár kl.] LT',
            lastWeek : '[síðstu] dddd [kl] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'um %s',
            past : '%s síðani',
            s : 'fá sekund',
            ss : '%d sekundir',
            m : 'ein minuttur',
            mm : '%d minuttir',
            h : 'ein tími',
            hh : '%d tímar',
            d : 'ein dagur',
            dd : '%d dagar',
            M : 'ein mánaður',
            MM : '%d mánaðir',
            y : 'eitt ár',
            yy : '%d ár'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fo;

})));


/***/ }),

/***/ "079e":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var ja = moment.defineLocale('ja', {
        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays : '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
        weekdaysShort : '日_月_火_水_木_金_土'.split('_'),
        weekdaysMin : '日_月_火_水_木_金_土'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYY年M月D日',
            LLL : 'YYYY年M月D日 HH:mm',
            LLLL : 'YYYY年M月D日 dddd HH:mm',
            l : 'YYYY/MM/DD',
            ll : 'YYYY年M月D日',
            lll : 'YYYY年M月D日 HH:mm',
            llll : 'YYYY年M月D日(ddd) HH:mm'
        },
        meridiemParse: /午前|午後/i,
        isPM : function (input) {
            return input === '午後';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '午前';
            } else {
                return '午後';
            }
        },
        calendar : {
            sameDay : '[今日] LT',
            nextDay : '[明日] LT',
            nextWeek : function (now) {
                if (now.week() < this.week()) {
                    return '[来週]dddd LT';
                } else {
                    return 'dddd LT';
                }
            },
            lastDay : '[昨日] LT',
            lastWeek : function (now) {
                if (this.week() < now.week()) {
                    return '[先週]dddd LT';
                } else {
                    return 'dddd LT';
                }
            },
            sameElse : 'L'
        },
        dayOfMonthOrdinalParse : /\d{1,2}日/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '日';
                default:
                    return number;
            }
        },
        relativeTime : {
            future : '%s後',
            past : '%s前',
            s : '数秒',
            ss : '%d秒',
            m : '1分',
            mm : '%d分',
            h : '1時間',
            hh : '%d時間',
            d : '1日',
            dd : '%d日',
            M : '1ヶ月',
            MM : '%dヶ月',
            y : '1年',
            yy : '%d年'
        }
    });

    return ja;

})));


/***/ }),

/***/ "07c7":
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "07e3":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "087d":
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ "08cc":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("1a8c");

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),

/***/ "099a":
/***/ (function(module, exports) {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


/***/ }),

/***/ "0a3c":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
    var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var esDo = moment.defineLocale('es-do', {
        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY h:mm A',
            LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            ss : '%d segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un día',
            dd : '%d días',
            M : 'un mes',
            MM : '%d meses',
            y : 'un año',
            yy : '%d años'
        },
        dayOfMonthOrdinalParse : /\d{1,2}º/,
        ordinal : '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return esDo;

})));


/***/ }),

/***/ "0a84":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var arMa = moment.defineLocale('ar-ma', {
        months : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        monthsShort : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        weekdays : 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort : 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'في %s',
            past : 'منذ %s',
            s : 'ثوان',
            ss : '%d ثانية',
            m : 'دقيقة',
            mm : '%d دقائق',
            h : 'ساعة',
            hh : '%d ساعات',
            d : 'يوم',
            dd : '%d أيام',
            M : 'شهر',
            MM : '%d أشهر',
            y : 'سنة',
            yy : '%d سنوات'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return arMa;

})));


/***/ }),

/***/ "0b07":
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__("34ac"),
    getValue = __webpack_require__("3698");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "0c75":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "0caa":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's': ['thodde secondanim', 'thodde second'],
            'ss': [number + ' secondanim', number + ' second'],
            'm': ['eka mintan', 'ek minute'],
            'mm': [number + ' mintanim', number + ' mintam'],
            'h': ['eka voran', 'ek vor'],
            'hh': [number + ' voranim', number + ' voram'],
            'd': ['eka disan', 'ek dis'],
            'dd': [number + ' disanim', number + ' dis'],
            'M': ['eka mhoinean', 'ek mhoino'],
            'MM': [number + ' mhoineanim', number + ' mhoine'],
            'y': ['eka vorsan', 'ek voros'],
            'yy': [number + ' vorsanim', number + ' vorsam']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var gomLatn = moment.defineLocale('gom-latn', {
        months : 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
        monthsShort : 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\'var'.split('_'),
        weekdaysShort : 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
        weekdaysMin : 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'A h:mm [vazta]',
            LTS : 'A h:mm:ss [vazta]',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY A h:mm [vazta]',
            LLLL : 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
            llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
        },
        calendar : {
            sameDay: '[Aiz] LT',
            nextDay: '[Faleam] LT',
            nextWeek: '[Ieta to] dddd[,] LT',
            lastDay: '[Kal] LT',
            lastWeek: '[Fatlo] dddd[,] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s',
            past : '%s adim',
            s : processRelativeTime,
            ss : processRelativeTime,
            m : processRelativeTime,
            mm : processRelativeTime,
            h : processRelativeTime,
            hh : processRelativeTime,
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse : /\d{1,2}(er)/,
        ordinal : function (number, period) {
            switch (period) {
                // the ordinal 'er' only applies to day of the month
                case 'D':
                    return number + 'er';
                default:
                case 'M':
                case 'Q':
                case 'DDD':
                case 'd':
                case 'w':
                case 'W':
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        },
        meridiemParse: /rati|sokalli|donparam|sanje/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'rati') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'sokalli') {
                return hour;
            } else if (meridiem === 'donparam') {
                return hour > 12 ? hour : hour + 12;
            } else if (meridiem === 'sanje') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'rati';
            } else if (hour < 12) {
                return 'sokalli';
            } else if (hour < 16) {
                return 'donparam';
            } else if (hour < 20) {
                return 'sanje';
            } else {
                return 'rati';
            }
        }
    });

    return gomLatn;

})));


/***/ }),

/***/ "0d24":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__("2b3e"),
    stubFalse = __webpack_require__("07c7");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("62e4")(module)))

/***/ }),

/***/ "0e49":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var frCh = moment.defineLocale('fr-ch', {
        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Aujourd’hui à] LT',
            nextDay : '[Demain à] LT',
            nextWeek : 'dddd [à] LT',
            lastDay : '[Hier à] LT',
            lastWeek : 'dddd [dernier à] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            ss : '%d secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal : function (number, period) {
            switch (period) {
                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'D':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return frCh;

})));


/***/ }),

/***/ "0e6b":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var enAu = moment.defineLocale('en-au', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enAu;

})));


/***/ }),

/***/ "0e81":
/***/ (function(module, exports, __webpack_require__) {


;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';

    var suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',
        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',
        3: '\'üncü',
        4: '\'üncü',
        100: '\'üncü',
        6: '\'ncı',
        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',
        60: '\'ıncı',
        90: '\'ıncı'
    };

    var tr = moment.defineLocale('tr', {
        months : 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
        monthsShort : 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
        weekdays : 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
        weekdaysShort : 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
        weekdaysMin : 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[bugün saat] LT',
            nextDay : '[yarın saat] LT',
            nextWeek : '[gelecek] dddd [saat] LT',
            lastDay : '[dün] LT',
            lastWeek : '[geçen] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s önce',
            s : 'birkaç saniye',
            ss : '%d saniye',
            m : 'bir dakika',
            mm : '%d dakika',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gün',
            dd : '%d gün',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir yıl',
            yy : '%d yıl'
        },
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'Do':
                case 'DD':
                    return number;
                default:
                    if (number === 0) {  // special case for zero
                        return number + '\'ıncı';
                    }
                    var a = number % 10,
                        b = number % 100 - a,
                        c = number >= 100 ? 100 : null;
                    return number + (suffixes[a] || suffixes[b] || suffixes[c]);
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return tr;

})));


/***/ }),

/***/ "0f0f":
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__("8eeb"),
    keysIn = __webpack_require__("9934");

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ "0f14":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var da = moment.defineLocale('da', {
        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
        weekdaysShort : 'søn_man_tir_ons_tor_fre_lør'.split('_'),
        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
        },
        calendar : {
            sameDay : '[i dag kl.] LT',
            nextDay : '[i morgen kl.] LT',
            nextWeek : 'på dddd [kl.] LT',
            lastDay : '[i går kl.] LT',
            lastWeek : '[i] dddd[s kl.] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s siden',
            s : 'få sekunder',
            ss : '%d sekunder',
            m : 'et minut',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dage',
            M : 'en måned',
            MM : '%d måneder',
            y : 'et år',
            yy : '%d år'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return da;

})));


/***/ }),

/***/ "0f38":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var tlPh = moment.defineLocale('tl-ph', {
        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'MM/D/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY HH:mm',
            LLLL : 'dddd, MMMM DD, YYYY HH:mm'
        },
        calendar : {
            sameDay: 'LT [ngayong araw]',
            nextDay: '[Bukas ng] LT',
            nextWeek: 'LT [sa susunod na] dddd',
            lastDay: 'LT [kahapon]',
            lastWeek: 'LT [noong nakaraang] dddd',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'sa loob ng %s',
            past : '%s ang nakalipas',
            s : 'ilang segundo',
            ss : '%d segundo',
            m : 'isang minuto',
            mm : '%d minuto',
            h : 'isang oras',
            hh : '%d oras',
            d : 'isang araw',
            dd : '%d araw',
            M : 'isang buwan',
            MM : '%d buwan',
            y : 'isang taon',
            yy : '%d taon'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tlPh;

})));


/***/ }),

/***/ "0fc9":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("3a38");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "0ff2":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var eu = moment.defineLocale('eu', {
        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
        monthsParseExact : true,
        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY[ko] MMMM[ren] D[a]',
            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
            l : 'YYYY-M-D',
            ll : 'YYYY[ko] MMM D[a]',
            lll : 'YYYY[ko] MMM D[a] HH:mm',
            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
        },
        calendar : {
            sameDay : '[gaur] LT[etan]',
            nextDay : '[bihar] LT[etan]',
            nextWeek : 'dddd LT[etan]',
            lastDay : '[atzo] LT[etan]',
            lastWeek : '[aurreko] dddd LT[etan]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s barru',
            past : 'duela %s',
            s : 'segundo batzuk',
            ss : '%d segundo',
            m : 'minutu bat',
            mm : '%d minutu',
            h : 'ordu bat',
            hh : '%d ordu',
            d : 'egun bat',
            dd : '%d egun',
            M : 'hilabete bat',
            MM : '%d hilabete',
            y : 'urte bat',
            yy : '%d urte'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return eu;

})));


/***/ }),

/***/ "1041":
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__("8eeb"),
    getSymbolsIn = __webpack_require__("a029");

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ "10e8":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var th = moment.defineLocale('th', {
        months : 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split('_'),
        monthsShort : 'ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.'.split('_'),
        monthsParseExact: true,
        weekdays : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
        weekdaysShort : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'), // yes, three characters difference
        weekdaysMin : 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY เวลา H:mm',
            LLLL : 'วันddddที่ D MMMM YYYY เวลา H:mm'
        },
        meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
        isPM: function (input) {
            return input === 'หลังเที่ยง';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ก่อนเที่ยง';
            } else {
                return 'หลังเที่ยง';
            }
        },
        calendar : {
            sameDay : '[วันนี้ เวลา] LT',
            nextDay : '[พรุ่งนี้ เวลา] LT',
            nextWeek : 'dddd[หน้า เวลา] LT',
            lastDay : '[เมื่อวานนี้ เวลา] LT',
            lastWeek : '[วัน]dddd[ที่แล้ว เวลา] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'อีก %s',
            past : '%sที่แล้ว',
            s : 'ไม่กี่วินาที',
            ss : '%d วินาที',
            m : '1 นาที',
            mm : '%d นาที',
            h : '1 ชั่วโมง',
            hh : '%d ชั่วโมง',
            d : '1 วัน',
            dd : '%d วัน',
            M : '1 เดือน',
            MM : '%d เดือน',
            y : '1 ปี',
            yy : '%d ปี'
        }
    });

    return th;

})));


/***/ }),

/***/ "11b0":
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),

/***/ "1290":
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "1310":
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "134b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @ignore
 * event object for dom
 * @author yiminghe@gmail.com
 */



Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _EventBaseObject = __webpack_require__("4039");

var _EventBaseObject2 = _interopRequireDefault(_EventBaseObject);

var _objectAssign = __webpack_require__("320c");

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var TRUE = true;
var FALSE = false;
var commonProps = ['altKey', 'bubbles', 'cancelable', 'ctrlKey', 'currentTarget', 'eventPhase', 'metaKey', 'shiftKey', 'target', 'timeStamp', 'view', 'type'];

function isNullOrUndefined(w) {
  return w === null || w === undefined;
}

var eventNormalizers = [{
  reg: /^key/,
  props: ['char', 'charCode', 'key', 'keyCode', 'which'],
  fix: function fix(event, nativeEvent) {
    if (isNullOrUndefined(event.which)) {
      event.which = !isNullOrUndefined(nativeEvent.charCode) ? nativeEvent.charCode : nativeEvent.keyCode;
    }

    // add metaKey to non-Mac browsers (use ctrl for PC 's and Meta for Macs)
    if (event.metaKey === undefined) {
      event.metaKey = event.ctrlKey;
    }
  }
}, {
  reg: /^touch/,
  props: ['touches', 'changedTouches', 'targetTouches']
}, {
  reg: /^hashchange$/,
  props: ['newURL', 'oldURL']
}, {
  reg: /^gesturechange$/i,
  props: ['rotation', 'scale']
}, {
  reg: /^(mousewheel|DOMMouseScroll)$/,
  props: [],
  fix: function fix(event, nativeEvent) {
    var deltaX = undefined;
    var deltaY = undefined;
    var delta = undefined;
    var wheelDelta = nativeEvent.wheelDelta;
    var axis = nativeEvent.axis;
    var wheelDeltaY = nativeEvent.wheelDeltaY;
    var wheelDeltaX = nativeEvent.wheelDeltaX;
    var detail = nativeEvent.detail;

    // ie/webkit
    if (wheelDelta) {
      delta = wheelDelta / 120;
    }

    // gecko
    if (detail) {
      // press control e.detail == 1 else e.detail == 3
      delta = 0 - (detail % 3 === 0 ? detail / 3 : detail);
    }

    // Gecko
    if (axis !== undefined) {
      if (axis === event.HORIZONTAL_AXIS) {
        deltaY = 0;
        deltaX = 0 - delta;
      } else if (axis === event.VERTICAL_AXIS) {
        deltaX = 0;
        deltaY = delta;
      }
    }

    // Webkit
    if (wheelDeltaY !== undefined) {
      deltaY = wheelDeltaY / 120;
    }
    if (wheelDeltaX !== undefined) {
      deltaX = -1 * wheelDeltaX / 120;
    }

    // 默认 deltaY (ie)
    if (!deltaX && !deltaY) {
      deltaY = delta;
    }

    if (deltaX !== undefined) {
      /**
       * deltaX of mousewheel event
       * @property deltaX
       * @member Event.DomEvent.Object
       */
      event.deltaX = deltaX;
    }

    if (deltaY !== undefined) {
      /**
       * deltaY of mousewheel event
       * @property deltaY
       * @member Event.DomEvent.Object
       */
      event.deltaY = deltaY;
    }

    if (delta !== undefined) {
      /**
       * delta of mousewheel event
       * @property delta
       * @member Event.DomEvent.Object
       */
      event.delta = delta;
    }
  }
}, {
  reg: /^mouse|contextmenu|click|mspointer|(^DOMMouseScroll$)/i,
  props: ['buttons', 'clientX', 'clientY', 'button', 'offsetX', 'relatedTarget', 'which', 'fromElement', 'toElement', 'offsetY', 'pageX', 'pageY', 'screenX', 'screenY'],
  fix: function fix(event, nativeEvent) {
    var eventDoc = undefined;
    var doc = undefined;
    var body = undefined;
    var target = event.target;
    var button = nativeEvent.button;

    // Calculate pageX/Y if missing and clientX/Y available
    if (target && isNullOrUndefined(event.pageX) && !isNullOrUndefined(nativeEvent.clientX)) {
      eventDoc = target.ownerDocument || document;
      doc = eventDoc.documentElement;
      body = eventDoc.body;
      event.pageX = nativeEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = nativeEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // which for click: 1 === left; 2 === middle; 3 === right
    // do not use button
    if (!event.which && button !== undefined) {
      if (button & 1) {
        event.which = 1;
      } else if (button & 2) {
        event.which = 3;
      } else if (button & 4) {
        event.which = 2;
      } else {
        event.which = 0;
      }
    }

    // add relatedTarget, if necessary
    if (!event.relatedTarget && event.fromElement) {
      event.relatedTarget = event.fromElement === target ? event.toElement : event.fromElement;
    }

    return event;
  }
}];

function retTrue() {
  return TRUE;
}

function retFalse() {
  return FALSE;
}

function DomEventObject(nativeEvent) {
  var type = nativeEvent.type;

  var isNative = typeof nativeEvent.stopPropagation === 'function' || typeof nativeEvent.cancelBubble === 'boolean';

  _EventBaseObject2['default'].call(this);

  this.nativeEvent = nativeEvent;

  // in case dom event has been mark as default prevented by lower dom node
  var isDefaultPrevented = retFalse;
  if ('defaultPrevented' in nativeEvent) {
    isDefaultPrevented = nativeEvent.defaultPrevented ? retTrue : retFalse;
  } else if ('getPreventDefault' in nativeEvent) {
    // https://bugzilla.mozilla.org/show_bug.cgi?id=691151
    isDefaultPrevented = nativeEvent.getPreventDefault() ? retTrue : retFalse;
  } else if ('returnValue' in nativeEvent) {
    isDefaultPrevented = nativeEvent.returnValue === FALSE ? retTrue : retFalse;
  }

  this.isDefaultPrevented = isDefaultPrevented;

  var fixFns = [];
  var fixFn = undefined;
  var l = undefined;
  var prop = undefined;
  var props = commonProps.concat();

  eventNormalizers.forEach(function (normalizer) {
    if (type.match(normalizer.reg)) {
      props = props.concat(normalizer.props);
      if (normalizer.fix) {
        fixFns.push(normalizer.fix);
      }
    }
  });

  l = props.length;

  // clone properties of the original event object
  while (l) {
    prop = props[--l];
    this[prop] = nativeEvent[prop];
  }

  // fix target property, if necessary
  if (!this.target && isNative) {
    this.target = nativeEvent.srcElement || document; // srcElement might not be defined either
  }

  // check if target is a text node (safari)
  if (this.target && this.target.nodeType === 3) {
    this.target = this.target.parentNode;
  }

  l = fixFns.length;

  while (l) {
    fixFn = fixFns[--l];
    fixFn(this, nativeEvent);
  }

  this.timeStamp = nativeEvent.timeStamp || Date.now();
}

var EventBaseObjectProto = _EventBaseObject2['default'].prototype;

(0, _objectAssign2['default'])(DomEventObject.prototype, EventBaseObjectProto, {
  constructor: DomEventObject,

  preventDefault: function preventDefault() {
    var e = this.nativeEvent;

    // if preventDefault exists run it on the original event
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      // otherwise set the returnValue property of the original event to FALSE (IE)
      e.returnValue = FALSE;
    }

    EventBaseObjectProto.preventDefault.call(this);
  },

  stopPropagation: function stopPropagation() {
    var e = this.nativeEvent;

    // if stopPropagation exists run it on the original event
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      // otherwise set the cancelBubble property of the original event to TRUE (IE)
      e.cancelBubble = TRUE;
    }

    EventBaseObjectProto.stopPropagation.call(this);
  }
});

exports['default'] = DomEventObject;
module.exports = exports['default'];

/***/ }),

/***/ "1368":
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__("da03");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "13e9":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var translator = {
        words: { //Different grammatical cases
            ss: ['секунда', 'секунде', 'секунди'],
            m: ['један минут', 'једне минуте'],
            mm: ['минут', 'минуте', 'минута'],
            h: ['један сат', 'једног сата'],
            hh: ['сат', 'сата', 'сати'],
            dd: ['дан', 'дана', 'дана'],
            MM: ['месец', 'месеца', 'месеци'],
            yy: ['година', 'године', 'година']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var srCyrl = moment.defineLocale('sr-cyrl', {
        months: 'јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар'.split('_'),
        monthsShort: 'јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.'.split('_'),
        monthsParseExact: true,
        weekdays: 'недеља_понедељак_уторак_среда_четвртак_петак_субота'.split('_'),
        weekdaysShort: 'нед._пон._уто._сре._чет._пет._суб.'.split('_'),
        weekdaysMin: 'не_по_ут_ср_че_пе_су'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[данас у] LT',
            nextDay: '[сутра у] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[у] [недељу] [у] LT';
                    case 3:
                        return '[у] [среду] [у] LT';
                    case 6:
                        return '[у] [суботу] [у] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[у] dddd [у] LT';
                }
            },
            lastDay  : '[јуче у] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[прошле] [недеље] [у] LT',
                    '[прошлог] [понедељка] [у] LT',
                    '[прошлог] [уторка] [у] LT',
                    '[прошле] [среде] [у] LT',
                    '[прошлог] [четвртка] [у] LT',
                    '[прошлог] [петка] [у] LT',
                    '[прошле] [суботе] [у] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'за %s',
            past   : 'пре %s',
            s      : 'неколико секунди',
            ss     : translator.translate,
            m      : translator.translate,
            mm     : translator.translate,
            h      : translator.translate,
            hh     : translator.translate,
            d      : 'дан',
            dd     : translator.translate,
            M      : 'месец',
            MM     : translator.translate,
            y      : 'годину',
            yy     : translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return srCyrl;

})));


/***/ }),

/***/ "159a":
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__("32b3"),
    castPath = __webpack_require__("e2e4"),
    isIndex = __webpack_require__("c098"),
    isObject = __webpack_require__("1a8c"),
    toKey = __webpack_require__("f4d6");

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),

/***/ "15f3":
/***/ (function(module, exports, __webpack_require__) {

var basePickBy = __webpack_require__("89d9"),
    hasIn = __webpack_require__("8604");

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;


/***/ }),

/***/ "1691":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "1838":
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__("c05f"),
    get = __webpack_require__("9b02"),
    hasIn = __webpack_require__("8604"),
    isKey = __webpack_require__("f608"),
    isStrictComparable = __webpack_require__("08cc"),
    matchesStrictComparable = __webpack_require__("20ec"),
    toKey = __webpack_require__("f4d6");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),

/***/ "18d8":
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__("234d");

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ "1a2d":
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__("42a2"),
    isObjectLike = __webpack_require__("1310");

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ "1a8c":
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "1b2b":
/***/ (function(module, exports) {

//

module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};


/***/ }),

/***/ "1b45":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var mt = moment.defineLocale('mt', {
        months : 'Jannar_Frar_Marzu_April_Mejju_Ġunju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diċembru'.split('_'),
        monthsShort : 'Jan_Fra_Mar_Apr_Mej_Ġun_Lul_Aww_Set_Ott_Nov_Diċ'.split('_'),
        weekdays : 'Il-Ħadd_It-Tnejn_It-Tlieta_L-Erbgħa_Il-Ħamis_Il-Ġimgħa_Is-Sibt'.split('_'),
        weekdaysShort : 'Ħad_Tne_Tli_Erb_Ħam_Ġim_Sib'.split('_'),
        weekdaysMin : 'Ħa_Tn_Tl_Er_Ħa_Ġi_Si'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Illum fil-]LT',
            nextDay : '[Għada fil-]LT',
            nextWeek : 'dddd [fil-]LT',
            lastDay : '[Il-bieraħ fil-]LT',
            lastWeek : 'dddd [li għadda] [fil-]LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'f’ %s',
            past : '%s ilu',
            s : 'ftit sekondi',
            ss : '%d sekondi',
            m : 'minuta',
            mm : '%d minuti',
            h : 'siegħa',
            hh : '%d siegħat',
            d : 'ġurnata',
            dd : '%d ġranet',
            M : 'xahar',
            MM : '%d xhur',
            y : 'sena',
            yy : '%d sni'
        },
        dayOfMonthOrdinalParse : /\d{1,2}º/,
        ordinal: '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return mt;

})));


/***/ }),

/***/ "1bac":
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__("7d1f"),
    getSymbolsIn = __webpack_require__("a029"),
    keysIn = __webpack_require__("9934");

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ "1bc3":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("f772");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "1c3c":
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__("9e69"),
    Uint8Array = __webpack_require__("2474"),
    eq = __webpack_require__("9638"),
    equalArrays = __webpack_require__("a2be"),
    mapToArray = __webpack_require__("edfa"),
    setToArray = __webpack_require__("ac41");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ "1cec":
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__("0b07"),
    root = __webpack_require__("2b3e");

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ "1cfd":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '1',
        '2': '2',
        '3': '3',
        '4': '4',
        '5': '5',
        '6': '6',
        '7': '7',
        '8': '8',
        '9': '9',
        '0': '0'
    }, pluralForm = function (n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
        m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
        h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
        d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
        M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
        y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
    }, pluralize = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, months = [
        'يناير',
        'فبراير',
        'مارس',
        'أبريل',
        'مايو',
        'يونيو',
        'يوليو',
        'أغسطس',
        'سبتمبر',
        'أكتوبر',
        'نوفمبر',
        'ديسمبر'
    ];

    var arLy = moment.defineLocale('ar-ly', {
        months : months,
        monthsShort : months,
        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/\u200FM/\u200FYYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /ص|م/,
        isPM : function (input) {
            return 'م' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar : {
            sameDay: '[اليوم عند الساعة] LT',
            nextDay: '[غدًا عند الساعة] LT',
            nextWeek: 'dddd [عند الساعة] LT',
            lastDay: '[أمس عند الساعة] LT',
            lastWeek: 'dddd [عند الساعة] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'بعد %s',
            past : 'منذ %s',
            s : pluralize('s'),
            ss : pluralize('s'),
            m : pluralize('m'),
            mm : pluralize('m'),
            h : pluralize('h'),
            hh : pluralize('h'),
            d : pluralize('d'),
            dd : pluralize('d'),
            M : pluralize('M'),
            MM : pluralize('M'),
            y : pluralize('y'),
            yy : pluralize('y')
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '،');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return arLy;

})));


/***/ }),

/***/ "1ec9":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("f772");
var document = __webpack_require__("e53d").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "1efc":
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "1fc1":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'ss': withoutSuffix ? 'секунда_секунды_секунд' : 'секунду_секунды_секунд',
            'mm': withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
            'hh': withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
            'dd': 'дзень_дні_дзён',
            'MM': 'месяц_месяцы_месяцаў',
            'yy': 'год_гады_гадоў'
        };
        if (key === 'm') {
            return withoutSuffix ? 'хвіліна' : 'хвіліну';
        }
        else if (key === 'h') {
            return withoutSuffix ? 'гадзіна' : 'гадзіну';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }

    var be = moment.defineLocale('be', {
        months : {
            format: 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split('_'),
            standalone: 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split('_')
        },
        monthsShort : 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split('_'),
        weekdays : {
            format: 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split('_'),
            standalone: 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split('_'),
            isFormat: /\[ ?[Ууў] ?(?:мінулую|наступную)? ?\] ?dddd/
        },
        weekdaysShort : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
        weekdaysMin : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY г.',
            LLL : 'D MMMM YYYY г., HH:mm',
            LLLL : 'dddd, D MMMM YYYY г., HH:mm'
        },
        calendar : {
            sameDay: '[Сёння ў] LT',
            nextDay: '[Заўтра ў] LT',
            lastDay: '[Учора ў] LT',
            nextWeek: function () {
                return '[У] dddd [ў] LT';
            },
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 5:
                    case 6:
                        return '[У мінулую] dddd [ў] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[У мінулы] dddd [ў] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'праз %s',
            past : '%s таму',
            s : 'некалькі секунд',
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : relativeTimeWithPlural,
            hh : relativeTimeWithPlural,
            d : 'дзень',
            dd : relativeTimeWithPlural,
            M : 'месяц',
            MM : relativeTimeWithPlural,
            y : 'год',
            yy : relativeTimeWithPlural
        },
        meridiemParse: /ночы|раніцы|дня|вечара/,
        isPM : function (input) {
            return /^(дня|вечара)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ночы';
            } else if (hour < 12) {
                return 'раніцы';
            } else if (hour < 17) {
                return 'дня';
            } else {
                return 'вечара';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                case 'w':
                case 'W':
                    return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-і' : number + '-ы';
                case 'D':
                    return number + '-га';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return be;

})));


/***/ }),

/***/ "1fc8":
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__("4245");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "201b":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var ka = moment.defineLocale('ka', {
        months : {
            standalone: 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split('_'),
            format: 'იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს'.split('_')
        },
        monthsShort : 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
        weekdays : {
            standalone: 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split('_'),
            format: 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split('_'),
            isFormat: /(წინა|შემდეგ)/
        },
        weekdaysShort : 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
        weekdaysMin : 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[დღეს] LT[-ზე]',
            nextDay : '[ხვალ] LT[-ზე]',
            lastDay : '[გუშინ] LT[-ზე]',
            nextWeek : '[შემდეგ] dddd LT[-ზე]',
            lastWeek : '[წინა] dddd LT-ზე',
            sameElse : 'L'
        },
        relativeTime : {
            future : function (s) {
                return (/(წამი|წუთი|საათი|წელი)/).test(s) ?
                    s.replace(/ი$/, 'ში') :
                    s + 'ში';
            },
            past : function (s) {
                if ((/(წამი|წუთი|საათი|დღე|თვე)/).test(s)) {
                    return s.replace(/(ი|ე)$/, 'ის წინ');
                }
                if ((/წელი/).test(s)) {
                    return s.replace(/წელი$/, 'წლის წინ');
                }
            },
            s : 'რამდენიმე წამი',
            ss : '%d წამი',
            m : 'წუთი',
            mm : '%d წუთი',
            h : 'საათი',
            hh : '%d საათი',
            d : 'დღე',
            dd : '%d დღე',
            M : 'თვე',
            MM : '%d თვე',
            y : 'წელი',
            yy : '%d წელი'
        },
        dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
        ordinal : function (number) {
            if (number === 0) {
                return number;
            }
            if (number === 1) {
                return number + '-ლი';
            }
            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
                return 'მე-' + number;
            }
            return number + '-ე';
        },
        week : {
            dow : 1,
            doy : 7
        }
    });

    return ka;

})));


/***/ }),

/***/ "20ba":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.presetPrimaryColors = exports.presetPalettes = exports.generate = undefined;

var _generate = __webpack_require__("b897");

var _generate2 = _interopRequireDefault(_generate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var presetPrimaryColors = {
  red: '#F5222D',
  volcano: '#FA541C',
  orange: '#FA8C16',
  gold: '#FAAD14',
  yellow: '#FADB14',
  lime: '#A0D911',
  green: '#52C41A',
  cyan: '#13C2C2',
  blue: '#1890FF',
  geekblue: '#2F54EB',
  purple: '#722ED1',
  magenta: '#EB2F96',
  grey: '#666666'
};

var presetPalettes = {};

Object.keys(presetPrimaryColors).forEach(function (key) {
  presetPalettes[key] = (0, _generate2.default)(presetPrimaryColors[key]);
});

exports.generate = _generate2.default;
exports.presetPalettes = presetPalettes;
exports.presetPrimaryColors = presetPrimaryColors;

/***/ }),

/***/ "20ec":
/***/ (function(module, exports) {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),

/***/ "2236":
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__("5a43");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),

/***/ "2286":
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__("85e3");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),

/***/ "22f8":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var ko = moment.defineLocale('ko', {
        months : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
        monthsShort : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
        weekdays : '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
        weekdaysShort : '일_월_화_수_목_금_토'.split('_'),
        weekdaysMin : '일_월_화_수_목_금_토'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'YYYY.MM.DD.',
            LL : 'YYYY년 MMMM D일',
            LLL : 'YYYY년 MMMM D일 A h:mm',
            LLLL : 'YYYY년 MMMM D일 dddd A h:mm',
            l : 'YYYY.MM.DD.',
            ll : 'YYYY년 MMMM D일',
            lll : 'YYYY년 MMMM D일 A h:mm',
            llll : 'YYYY년 MMMM D일 dddd A h:mm'
        },
        calendar : {
            sameDay : '오늘 LT',
            nextDay : '내일 LT',
            nextWeek : 'dddd LT',
            lastDay : '어제 LT',
            lastWeek : '지난주 dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s 후',
            past : '%s 전',
            s : '몇 초',
            ss : '%d초',
            m : '1분',
            mm : '%d분',
            h : '한 시간',
            hh : '%d시간',
            d : '하루',
            dd : '%d일',
            M : '한 달',
            MM : '%d달',
            y : '일 년',
            yy : '%d년'
        },
        dayOfMonthOrdinalParse : /\d{1,2}(일|월|주)/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '일';
                case 'M':
                    return number + '월';
                case 'w':
                case 'W':
                    return number + '주';
                default:
                    return number;
            }
        },
        meridiemParse : /오전|오후/,
        isPM : function (token) {
            return token === '오후';
        },
        meridiem : function (hour, minute, isUpper) {
            return hour < 12 ? '오전' : '오후';
        }
    });

    return ko;

})));


/***/ }),

/***/ "234d":
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__("e380");

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ "241e":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__("25eb");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "2421":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '١',
        '2': '٢',
        '3': '٣',
        '4': '٤',
        '5': '٥',
        '6': '٦',
        '7': '٧',
        '8': '٨',
        '9': '٩',
        '0': '٠'
    }, numberMap = {
        '١': '1',
        '٢': '2',
        '٣': '3',
        '٤': '4',
        '٥': '5',
        '٦': '6',
        '٧': '7',
        '٨': '8',
        '٩': '9',
        '٠': '0'
    },
    months = [
        'کانونی دووەم',
        'شوبات',
        'ئازار',
        'نیسان',
        'ئایار',
        'حوزەیران',
        'تەمموز',
        'ئاب',
        'ئەیلوول',
        'تشرینی یەكەم',
        'تشرینی دووەم',
        'كانونی یەکەم'
    ];


    var ku = moment.defineLocale('ku', {
        months : months,
        monthsShort : months,
        weekdays : 'یه‌كشه‌ممه‌_دووشه‌ممه‌_سێشه‌ممه‌_چوارشه‌ممه‌_پێنجشه‌ممه‌_هه‌ینی_شه‌ممه‌'.split('_'),
        weekdaysShort : 'یه‌كشه‌م_دووشه‌م_سێشه‌م_چوارشه‌م_پێنجشه‌م_هه‌ینی_شه‌ممه‌'.split('_'),
        weekdaysMin : 'ی_د_س_چ_پ_ه_ش'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        meridiemParse: /ئێواره‌|به‌یانی/,
        isPM: function (input) {
            return /ئێواره‌/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'به‌یانی';
            } else {
                return 'ئێواره‌';
            }
        },
        calendar : {
            sameDay : '[ئه‌مرۆ كاتژمێر] LT',
            nextDay : '[به‌یانی كاتژمێر] LT',
            nextWeek : 'dddd [كاتژمێر] LT',
            lastDay : '[دوێنێ كاتژمێر] LT',
            lastWeek : 'dddd [كاتژمێر] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'له‌ %s',
            past : '%s',
            s : 'چه‌ند چركه‌یه‌ك',
            ss : 'چركه‌ %d',
            m : 'یه‌ك خوله‌ك',
            mm : '%d خوله‌ك',
            h : 'یه‌ك كاتژمێر',
            hh : '%d كاتژمێر',
            d : 'یه‌ك ڕۆژ',
            dd : '%d ڕۆژ',
            M : 'یه‌ك مانگ',
            MM : '%d مانگ',
            y : 'یه‌ك ساڵ',
            yy : '%d ساڵ'
        },
        preparse: function (string) {
            return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                return numberMap[match];
            }).replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '،');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12 // The week that contains Jan 12th is the first week of the year.
        }
    });

    return ku;

})));


/***/ }),

/***/ "242e":
/***/ (function(module, exports, __webpack_require__) {

var baseFor = __webpack_require__("72af"),
    keys = __webpack_require__("ec69");

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),

/***/ "243f":
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__("48a0");

/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach(collection, function(value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

module.exports = baseAggregator;


/***/ }),

/***/ "2474":
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__("2b3e");

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ "2478":
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__("4245");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "2524":
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__("6044");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "253c":
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__("3729"),
    isObjectLike = __webpack_require__("1310");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "2554":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                if (number === 1) {
                    result += 'sekunda';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sekunde';
                } else {
                    result += 'sekundi';
                }
                return result;
            case 'm':
                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
            case 'mm':
                if (number === 1) {
                    result += 'minuta';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'minute';
                } else {
                    result += 'minuta';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'jedan sat' : 'jednog sata';
            case 'hh':
                if (number === 1) {
                    result += 'sat';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sata';
                } else {
                    result += 'sati';
                }
                return result;
            case 'dd':
                if (number === 1) {
                    result += 'dan';
                } else {
                    result += 'dana';
                }
                return result;
            case 'MM':
                if (number === 1) {
                    result += 'mjesec';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'mjeseca';
                } else {
                    result += 'mjeseci';
                }
                return result;
            case 'yy':
                if (number === 1) {
                    result += 'godina';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'godine';
                } else {
                    result += 'godina';
                }
                return result;
        }
    }

    var bs = moment.defineLocale('bs', {
        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jučer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                        return '[prošlu] dddd [u] LT';
                    case 6:
                        return '[prošle] [subote] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[prošli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            ss     : translate,
            m      : translate,
            mm     : translate,
            h      : translate,
            hh     : translate,
            d      : 'dan',
            dd     : translate,
            M      : 'mjesec',
            MM     : translate,
            y      : 'godinu',
            yy     : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return bs;

})));


/***/ }),

/***/ "2593":
/***/ (function(module, exports, __webpack_require__) {

var basePick = __webpack_require__("15f3"),
    flatRest = __webpack_require__("c6cf");

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;


/***/ }),

/***/ "25eb":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "26e8":
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),

/***/ "26f9":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var units = {
        'ss' : 'sekundė_sekundžių_sekundes',
        'm' : 'minutė_minutės_minutę',
        'mm': 'minutės_minučių_minutes',
        'h' : 'valanda_valandos_valandą',
        'hh': 'valandos_valandų_valandas',
        'd' : 'diena_dienos_dieną',
        'dd': 'dienos_dienų_dienas',
        'M' : 'mėnuo_mėnesio_mėnesį',
        'MM': 'mėnesiai_mėnesių_mėnesius',
        'y' : 'metai_metų_metus',
        'yy': 'metai_metų_metus'
    };
    function translateSeconds(number, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
            return 'kelios sekundės';
        } else {
            return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
        }
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
    }
    function special(number) {
        return number % 10 === 0 || (number > 10 && number < 20);
    }
    function forms(key) {
        return units[key].split('_');
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        if (number === 1) {
            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
        } else if (withoutSuffix) {
            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
        } else {
            if (isFuture) {
                return result + forms(key)[1];
            } else {
                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
            }
        }
    }
    var lt = moment.defineLocale('lt', {
        months : {
            format: 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split('_'),
            standalone: 'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split('_'),
            isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
        },
        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
        weekdays : {
            format: 'sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį'.split('_'),
            standalone: 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split('_'),
            isFormat: /dddd HH:mm/
        },
        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
        weekdaysMin : 'S_P_A_T_K_Pn_Š'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY [m.] MMMM D [d.]',
            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
            l : 'YYYY-MM-DD',
            ll : 'YYYY [m.] MMMM D [d.]',
            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
        },
        calendar : {
            sameDay : '[Šiandien] LT',
            nextDay : '[Rytoj] LT',
            nextWeek : 'dddd LT',
            lastDay : '[Vakar] LT',
            lastWeek : '[Praėjusį] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'po %s',
            past : 'prieš %s',
            s : translateSeconds,
            ss : translate,
            m : translateSingular,
            mm : translate,
            h : translateSingular,
            hh : translate,
            d : translateSingular,
            dd : translate,
            M : translateSingular,
            MM : translate,
            y : translateSingular,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}-oji/,
        ordinal : function (number) {
            return number + '-oji';
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lt;

})));


/***/ }),

/***/ "278c":
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__("c135");

var iterableToArrayLimit = __webpack_require__("9b42");

var unsupportedIterableToArray = __webpack_require__("6613");

var nonIterableRest = __webpack_require__("c240");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "28c9":
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "2921":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var vi = moment.defineLocale('vi', {
        months : 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split('_'),
        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
        monthsParseExact : true,
        weekdays : 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysParseExact : true,
        meridiemParse: /sa|ch/i,
        isPM : function (input) {
            return /^ch$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'sa' : 'SA';
            } else {
                return isLower ? 'ch' : 'CH';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM [năm] YYYY',
            LLL : 'D MMMM [năm] YYYY HH:mm',
            LLLL : 'dddd, D MMMM [năm] YYYY HH:mm',
            l : 'DD/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd, D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Hôm nay lúc] LT',
            nextDay: '[Ngày mai lúc] LT',
            nextWeek: 'dddd [tuần tới lúc] LT',
            lastDay: '[Hôm qua lúc] LT',
            lastWeek: 'dddd [tuần rồi lúc] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s tới',
            past : '%s trước',
            s : 'vài giây',
            ss : '%d giây' ,
            m : 'một phút',
            mm : '%d phút',
            h : 'một giờ',
            hh : '%d giờ',
            d : 'một ngày',
            dd : '%d ngày',
            M : 'một tháng',
            MM : '%d tháng',
            y : 'một năm',
            yy : '%d năm'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return vi;

})));


/***/ }),

/***/ "293c":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var translator = {
        words: { //Different grammatical cases
            ss: ['sekund', 'sekunda', 'sekundi'],
            m: ['jedan minut', 'jednog minuta'],
            mm: ['minut', 'minuta', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mjesec', 'mjeseca', 'mjeseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var me = moment.defineLocale('me', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact : true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sjutra u] LT',

            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juče u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[prošle] [nedjelje] [u] LT',
                    '[prošlog] [ponedjeljka] [u] LT',
                    '[prošlog] [utorka] [u] LT',
                    '[prošle] [srijede] [u] LT',
                    '[prošlog] [četvrtka] [u] LT',
                    '[prošlog] [petka] [u] LT',
                    '[prošle] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'nekoliko sekundi',
            ss     : translator.translate,
            m      : translator.translate,
            mm     : translator.translate,
            h      : translator.translate,
            hh     : translator.translate,
            d      : 'dan',
            dd     : translator.translate,
            M      : 'mjesec',
            MM     : translator.translate,
            y      : 'godinu',
            yy     : translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return me;

})));


/***/ }),

/***/ "294c":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "29f3":
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "2b03":
/***/ (function(module, exports) {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),

/***/ "2b10":
/***/ (function(module, exports) {

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;


/***/ }),

/***/ "2b3e":
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__("585a");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "2bfb":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var af = moment.defineLocale('af', {
        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
        meridiemParse: /vm|nm/i,
        isPM : function (input) {
            return /^nm$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'vm' : 'VM';
            } else {
                return isLower ? 'nm' : 'NM';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Vandag om] LT',
            nextDay : '[Môre om] LT',
            nextWeek : 'dddd [om] LT',
            lastDay : '[Gister om] LT',
            lastWeek : '[Laas] dddd [om] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'oor %s',
            past : '%s gelede',
            s : '\'n paar sekondes',
            ss : '%d sekondes',
            m : '\'n minuut',
            mm : '%d minute',
            h : '\'n uur',
            hh : '%d ure',
            d : '\'n dag',
            dd : '%d dae',
            M : '\'n maand',
            MM : '%d maande',
            y : '\'n jaar',
            yy : '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Röling : https://github.com/jjupiter
        },
        week : {
            dow : 1, // Maandag is die eerste dag van die week.
            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
        }
    });

    return af;

})));


/***/ }),

/***/ "2c66":
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__("d612"),
    arrayIncludes = __webpack_require__("8db3"),
    arrayIncludesWith = __webpack_require__("5edf"),
    cacheHas = __webpack_require__("c584"),
    createSet = __webpack_require__("750a"),
    setToArray = __webpack_require__("ac41");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;


/***/ }),

/***/ "2c80":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = addEventListener;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _EventObject = __webpack_require__("134b");

var _EventObject2 = _interopRequireDefault(_EventObject);

function addEventListener(target, eventType, callback, option) {
  function wrapCallback(e) {
    var ne = new _EventObject2['default'](e);
    callback.call(target, ne);
  }

  if (target.addEventListener) {
    var _ret = (function () {
      var useCapture = false;
      if (typeof option === 'object') {
        useCapture = option.capture || false;
      } else if (typeof option === 'boolean') {
        useCapture = option;
      }

      target.addEventListener(eventType, wrapCallback, option || false);

      return {
        v: {
          remove: function remove() {
            target.removeEventListener(eventType, wrapCallback, useCapture);
          }
        }
      };
    })();

    if (typeof _ret === 'object') return _ret.v;
  } else if (target.attachEvent) {
    target.attachEvent('on' + eventType, wrapCallback);
    return {
      remove: function remove() {
        target.detachEvent('on' + eventType, wrapCallback);
      }
    };
  }
}

module.exports = exports['default'];

/***/ }),

/***/ "2d7c":
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ "2dcb":
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__("91e9");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "2e8c":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var uz = moment.defineLocale('uz', {
        months : 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split('_'),
        monthsShort : 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
        weekdays : 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
        weekdaysShort : 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
        weekdaysMin : 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'D MMMM YYYY, dddd HH:mm'
        },
        calendar : {
            sameDay : '[Бугун соат] LT [да]',
            nextDay : '[Эртага] LT [да]',
            nextWeek : 'dddd [куни соат] LT [да]',
            lastDay : '[Кеча соат] LT [да]',
            lastWeek : '[Утган] dddd [куни соат] LT [да]',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'Якин %s ичида',
            past : 'Бир неча %s олдин',
            s : 'фурсат',
            ss : '%d фурсат',
            m : 'бир дакика',
            mm : '%d дакика',
            h : 'бир соат',
            hh : '%d соат',
            d : 'бир кун',
            dd : '%d кун',
            M : 'бир ой',
            MM : '%d ой',
            y : 'бир йил',
            yy : '%d йил'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return uz;

})));


/***/ }),

/***/ "2fcc":
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ "30c9":
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__("9520"),
    isLength = __webpack_require__("b218");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "320c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "327d":
/***/ (function(module, exports, __webpack_require__) {

var createAggregator = __webpack_require__("50c6");

/**
 * Creates an array of elements split into two groups, the first of which
 * contains elements `predicate` returns truthy for, the second of which
 * contains elements `predicate` returns falsey for. The predicate is
 * invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the array of grouped elements.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': false },
 *   { 'user': 'fred',    'age': 40, 'active': true },
 *   { 'user': 'pebbles', 'age': 1,  'active': false }
 * ];
 *
 * _.partition(users, function(o) { return o.active; });
 * // => objects for [['fred'], ['barney', 'pebbles']]
 *
 * // The `_.matches` iteratee shorthand.
 * _.partition(users, { 'age': 1, 'active': false });
 * // => objects for [['pebbles'], ['barney', 'fred']]
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.partition(users, ['active', false]);
 * // => objects for [['barney', 'pebbles'], ['fred']]
 *
 * // The `_.property` iteratee shorthand.
 * _.partition(users, 'active');
 * // => objects for [['fred'], ['barney', 'pebbles']]
 */
var partition = createAggregator(function(result, value, key) {
  result[key ? 0 : 1].push(value);
}, function() { return [[], []]; });

module.exports = partition;


/***/ }),

/***/ "32b3":
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__("872a"),
    eq = __webpack_require__("9638");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ "32f4":
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__("2d7c"),
    stubArray = __webpack_require__("d327");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ "335c":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__("6b4c");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "34ac":
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__("9520"),
    isMasked = __webpack_require__("1368"),
    isObject = __webpack_require__("1a8c"),
    toSource = __webpack_require__("dc57");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "34b2":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "355d":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "35e8":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("d9f6");
var createDesc = __webpack_require__("aebd");
module.exports = __webpack_require__("8e60") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "3698":
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "36c3":
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__("335c");
var defined = __webpack_require__("25eb");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "3729":
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__("9e69"),
    getRawTag = __webpack_require__("00fd"),
    objectToString = __webpack_require__("29f3");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "3818":
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__("7e64"),
    arrayEach = __webpack_require__("8057"),
    assignValue = __webpack_require__("32b3"),
    baseAssign = __webpack_require__("5b01"),
    baseAssignIn = __webpack_require__("0f0f"),
    cloneBuffer = __webpack_require__("e538"),
    copyArray = __webpack_require__("4359"),
    copySymbols = __webpack_require__("54eb"),
    copySymbolsIn = __webpack_require__("1041"),
    getAllKeys = __webpack_require__("a994"),
    getAllKeysIn = __webpack_require__("1bac"),
    getTag = __webpack_require__("42a2"),
    initCloneArray = __webpack_require__("c87c"),
    initCloneByTag = __webpack_require__("c2b6"),
    initCloneObject = __webpack_require__("fa21"),
    isArray = __webpack_require__("6747"),
    isBuffer = __webpack_require__("0d24"),
    isMap = __webpack_require__("cc45"),
    isObject = __webpack_require__("1a8c"),
    isSet = __webpack_require__("d7ee"),
    keys = __webpack_require__("ec69");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ "3886":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var enCa = moment.defineLocale('en-ca', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'YYYY-MM-DD',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY h:mm A',
            LLLL : 'dddd, MMMM D, YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    return enCa;

})));


/***/ }),

/***/ "39a6":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var enGb = moment.defineLocale('en-gb', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enGb;

})));


/***/ }),

/***/ "39bd":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '१',
        '2': '२',
        '3': '३',
        '4': '४',
        '5': '५',
        '6': '६',
        '7': '७',
        '8': '८',
        '9': '९',
        '0': '०'
    },
    numberMap = {
        '१': '1',
        '२': '2',
        '३': '3',
        '४': '4',
        '५': '5',
        '६': '6',
        '७': '7',
        '८': '8',
        '९': '9',
        '०': '0'
    };

    function relativeTimeMr(number, withoutSuffix, string, isFuture)
    {
        var output = '';
        if (withoutSuffix) {
            switch (string) {
                case 's': output = 'काही सेकंद'; break;
                case 'ss': output = '%d सेकंद'; break;
                case 'm': output = 'एक मिनिट'; break;
                case 'mm': output = '%d मिनिटे'; break;
                case 'h': output = 'एक तास'; break;
                case 'hh': output = '%d तास'; break;
                case 'd': output = 'एक दिवस'; break;
                case 'dd': output = '%d दिवस'; break;
                case 'M': output = 'एक महिना'; break;
                case 'MM': output = '%d महिने'; break;
                case 'y': output = 'एक वर्ष'; break;
                case 'yy': output = '%d वर्षे'; break;
            }
        }
        else {
            switch (string) {
                case 's': output = 'काही सेकंदां'; break;
                case 'ss': output = '%d सेकंदां'; break;
                case 'm': output = 'एका मिनिटा'; break;
                case 'mm': output = '%d मिनिटां'; break;
                case 'h': output = 'एका तासा'; break;
                case 'hh': output = '%d तासां'; break;
                case 'd': output = 'एका दिवसा'; break;
                case 'dd': output = '%d दिवसां'; break;
                case 'M': output = 'एका महिन्या'; break;
                case 'MM': output = '%d महिन्यां'; break;
                case 'y': output = 'एका वर्षा'; break;
                case 'yy': output = '%d वर्षां'; break;
            }
        }
        return output.replace(/%d/i, number);
    }

    var mr = moment.defineLocale('mr', {
        months : 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split('_'),
        monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split('_'),
        monthsParseExact : true,
        weekdays : 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
        weekdaysShort : 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
        longDateFormat : {
            LT : 'A h:mm वाजता',
            LTS : 'A h:mm:ss वाजता',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm वाजता',
            LLLL : 'dddd, D MMMM YYYY, A h:mm वाजता'
        },
        calendar : {
            sameDay : '[आज] LT',
            nextDay : '[उद्या] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[काल] LT',
            lastWeek: '[मागील] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future: '%sमध्ये',
            past: '%sपूर्वी',
            s: relativeTimeMr,
            ss: relativeTimeMr,
            m: relativeTimeMr,
            mm: relativeTimeMr,
            h: relativeTimeMr,
            hh: relativeTimeMr,
            d: relativeTimeMr,
            dd: relativeTimeMr,
            M: relativeTimeMr,
            MM: relativeTimeMr,
            y: relativeTimeMr,
            yy: relativeTimeMr
        },
        preparse: function (string) {
            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'रात्री') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'सकाळी') {
                return hour;
            } else if (meridiem === 'दुपारी') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'सायंकाळी') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'रात्री';
            } else if (hour < 10) {
                return 'सकाळी';
            } else if (hour < 17) {
                return 'दुपारी';
            } else if (hour < 20) {
                return 'सायंकाळी';
            } else {
                return 'रात्री';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return mr;

})));


/***/ }),

/***/ "39ff":
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__("0b07"),
    root = __webpack_require__("2b3e");

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ "3a38":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "3a39":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '१',
        '2': '२',
        '3': '३',
        '4': '४',
        '5': '५',
        '6': '६',
        '7': '७',
        '8': '८',
        '9': '९',
        '0': '०'
    },
    numberMap = {
        '१': '1',
        '२': '2',
        '३': '3',
        '४': '4',
        '५': '5',
        '६': '6',
        '७': '7',
        '८': '8',
        '९': '9',
        '०': '0'
    };

    var ne = moment.defineLocale('ne', {
        months : 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split('_'),
        monthsShort : 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split('_'),
        monthsParseExact : true,
        weekdays : 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split('_'),
        weekdaysShort : 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
        weekdaysMin : 'आ._सो._मं._बु._बि._शु._श.'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'Aको h:mm बजे',
            LTS : 'Aको h:mm:ss बजे',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, Aको h:mm बजे',
            LLLL : 'dddd, D MMMM YYYY, Aको h:mm बजे'
        },
        preparse: function (string) {
            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'राति') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'बिहान') {
                return hour;
            } else if (meridiem === 'दिउँसो') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'साँझ') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 3) {
                return 'राति';
            } else if (hour < 12) {
                return 'बिहान';
            } else if (hour < 16) {
                return 'दिउँसो';
            } else if (hour < 20) {
                return 'साँझ';
            } else {
                return 'राति';
            }
        },
        calendar : {
            sameDay : '[आज] LT',
            nextDay : '[भोलि] LT',
            nextWeek : '[आउँदो] dddd[,] LT',
            lastDay : '[हिजो] LT',
            lastWeek : '[गएको] dddd[,] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%sमा',
            past : '%s अगाडि',
            s : 'केही क्षण',
            ss : '%d सेकेण्ड',
            m : 'एक मिनेट',
            mm : '%d मिनेट',
            h : 'एक घण्टा',
            hh : '%d घण्टा',
            d : 'एक दिन',
            dd : '%d दिन',
            M : 'एक महिना',
            MM : '%d महिना',
            y : 'एक बर्ष',
            yy : '%d बर्ष'
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return ne;

})));


/***/ }),

/***/ "3b1b":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var suffixes = {
        0: '-ум',
        1: '-ум',
        2: '-юм',
        3: '-юм',
        4: '-ум',
        5: '-ум',
        6: '-ум',
        7: '-ум',
        8: '-ум',
        9: '-ум',
        10: '-ум',
        12: '-ум',
        13: '-ум',
        20: '-ум',
        30: '-юм',
        40: '-ум',
        50: '-ум',
        60: '-ум',
        70: '-ум',
        80: '-ум',
        90: '-ум',
        100: '-ум'
    };

    var tg = moment.defineLocale('tg', {
        months : 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split('_'),
        monthsShort : 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
        weekdays : 'якшанбе_душанбе_сешанбе_чоршанбе_панҷшанбе_ҷумъа_шанбе'.split('_'),
        weekdaysShort : 'яшб_дшб_сшб_чшб_пшб_ҷум_шнб'.split('_'),
        weekdaysMin : 'яш_дш_сш_чш_пш_ҷм_шб'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Имрӯз соати] LT',
            nextDay : '[Пагоҳ соати] LT',
            lastDay : '[Дирӯз соати] LT',
            nextWeek : 'dddd[и] [ҳафтаи оянда соати] LT',
            lastWeek : 'dddd[и] [ҳафтаи гузашта соати] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'баъди %s',
            past : '%s пеш',
            s : 'якчанд сония',
            m : 'як дақиқа',
            mm : '%d дақиқа',
            h : 'як соат',
            hh : '%d соат',
            d : 'як рӯз',
            dd : '%d рӯз',
            M : 'як моҳ',
            MM : '%d моҳ',
            y : 'як сол',
            yy : '%d сол'
        },
        meridiemParse: /шаб|субҳ|рӯз|бегоҳ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'шаб') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'субҳ') {
                return hour;
            } else if (meridiem === 'рӯз') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'бегоҳ') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'шаб';
            } else if (hour < 11) {
                return 'субҳ';
            } else if (hour < 16) {
                return 'рӯз';
            } else if (hour < 19) {
                return 'бегоҳ';
            } else {
                return 'шаб';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ум|юм)/,
        ordinal: function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1th is the first week of the year.
        }
    });

    return tg;

})));


/***/ }),

/***/ "3b4a":
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__("0b07");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ "3bb4":
/***/ (function(module, exports, __webpack_require__) {

var isStrictComparable = __webpack_require__("08cc"),
    keys = __webpack_require__("ec69");

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),

/***/ "3c0d":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var months = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_'),
        monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_');

    var monthsParse = [/^led/i, /^úno/i, /^bře/i, /^dub/i, /^kvě/i, /^(čvn|červen$|června)/i, /^(čvc|červenec|července)/i, /^srp/i, /^zář/i, /^říj/i, /^lis/i, /^pro/i];
    // NOTE: 'červen' is substring of 'červenec'; therefore 'červenec' must precede 'červen' in the regex to be fully matched.
    // Otherwise parser matches '1. červenec' as '1. červen' + 'ec'.
    var monthsRegex = /^(leden|únor|březen|duben|květen|červenec|července|červen|června|srpen|září|říjen|listopad|prosinec|led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i;

    function plural(n) {
        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':  // a few seconds / in a few seconds / a few seconds ago
                return (withoutSuffix || isFuture) ? 'pár sekund' : 'pár sekundami';
            case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'sekundy' : 'sekund');
                } else {
                    return result + 'sekundami';
                }
                break;
            case 'm':  // a minute / in a minute / a minute ago
                return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'minuty' : 'minut');
                } else {
                    return result + 'minutami';
                }
                break;
            case 'h':  // an hour / in an hour / an hour ago
                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
            case 'hh': // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'hodiny' : 'hodin');
                } else {
                    return result + 'hodinami';
                }
                break;
            case 'd':  // a day / in a day / a day ago
                return (withoutSuffix || isFuture) ? 'den' : 'dnem';
            case 'dd': // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'dny' : 'dní');
                } else {
                    return result + 'dny';
                }
                break;
            case 'M':  // a month / in a month / a month ago
                return (withoutSuffix || isFuture) ? 'měsíc' : 'měsícem';
            case 'MM': // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'měsíce' : 'měsíců');
                } else {
                    return result + 'měsíci';
                }
                break;
            case 'y':  // a year / in a year / a year ago
                return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
            case 'yy': // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'roky' : 'let');
                } else {
                    return result + 'lety';
                }
                break;
        }
    }

    var cs = moment.defineLocale('cs', {
        months : months,
        monthsShort : monthsShort,
        monthsRegex : monthsRegex,
        monthsShortRegex : monthsRegex,
        // NOTE: 'červen' is substring of 'červenec'; therefore 'červenec' must precede 'červen' in the regex to be fully matched.
        // Otherwise parser matches '1. červenec' as '1. červen' + 'ec'.
        monthsStrictRegex : /^(leden|ledna|února|únor|březen|března|duben|dubna|květen|května|červenec|července|červen|června|srpen|srpna|září|říjen|října|listopadu|listopad|prosinec|prosince)/i,
        monthsShortStrictRegex : /^(led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i,
        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,
        weekdays : 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
        weekdaysShort : 'ne_po_út_st_čt_pá_so'.split('_'),
        weekdaysMin : 'ne_po_út_st_čt_pá_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd D. MMMM YYYY H:mm',
            l : 'D. M. YYYY'
        },
        calendar : {
            sameDay: '[dnes v] LT',
            nextDay: '[zítra v] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[v neděli v] LT';
                    case 1:
                    case 2:
                        return '[v] dddd [v] LT';
                    case 3:
                        return '[ve středu v] LT';
                    case 4:
                        return '[ve čtvrtek v] LT';
                    case 5:
                        return '[v pátek v] LT';
                    case 6:
                        return '[v sobotu v] LT';
                }
            },
            lastDay: '[včera v] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[minulou neděli v] LT';
                    case 1:
                    case 2:
                        return '[minulé] dddd [v] LT';
                    case 3:
                        return '[minulou středu v] LT';
                    case 4:
                    case 5:
                        return '[minulý] dddd [v] LT';
                    case 6:
                        return '[minulou sobotu v] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'před %s',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse : /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return cs;

})));


/***/ }),

/***/ "3c55":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

try {
  var index = __webpack_require__("cecd");
} catch (err) {
  var index = __webpack_require__("cecd");
}

/**
 * Whitespace regexp.
 */

var re = /\s+/;

/**
 * toString reference.
 */

var toString = Object.prototype.toString;

/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

module.exports = function(el){
  return new ClassList(el);
};

/**
 * Initialize a new ClassList for `el`.
 *
 * @param {Element} el
 * @api private
 */

function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error('A DOM element reference is required');
  }
  this.el = el;
  this.list = el.classList;
}

/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.add = function(name){
  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (!~i) arr.push(name);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.remove = function(name){
  if ('[object RegExp]' == toString.call(name)) {
    return this.removeMatching(name);
  }

  // classList
  if (this.list) {
    this.list.remove(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (~i) arr.splice(i, 1);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */

ClassList.prototype.removeMatching = function(re){
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};

/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.toggle = function(name, force){
  // classList
  if (this.list) {
    if ("undefined" !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  }

  // fallback
  if ("undefined" !== typeof force) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};

/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */

ClassList.prototype.array = function(){
  var className = this.el.getAttribute('class') || '';
  var str = className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) arr.shift();
  return arr;
};

/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.has =
ClassList.prototype.contains = function(name){
  return this.list
    ? this.list.contains(name)
    : !! ~index(this.array(), name);
};


/***/ }),

/***/ "3de5":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '௧',
        '2': '௨',
        '3': '௩',
        '4': '௪',
        '5': '௫',
        '6': '௬',
        '7': '௭',
        '8': '௮',
        '9': '௯',
        '0': '௦'
    }, numberMap = {
        '௧': '1',
        '௨': '2',
        '௩': '3',
        '௪': '4',
        '௫': '5',
        '௬': '6',
        '௭': '7',
        '௮': '8',
        '௯': '9',
        '௦': '0'
    };

    var ta = moment.defineLocale('ta', {
        months : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
        monthsShort : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
        weekdays : 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split('_'),
        weekdaysShort : 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split('_'),
        weekdaysMin : 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, HH:mm',
            LLLL : 'dddd, D MMMM YYYY, HH:mm'
        },
        calendar : {
            sameDay : '[இன்று] LT',
            nextDay : '[நாளை] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[நேற்று] LT',
            lastWeek : '[கடந்த வாரம்] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s இல்',
            past : '%s முன்',
            s : 'ஒரு சில விநாடிகள்',
            ss : '%d விநாடிகள்',
            m : 'ஒரு நிமிடம்',
            mm : '%d நிமிடங்கள்',
            h : 'ஒரு மணி நேரம்',
            hh : '%d மணி நேரம்',
            d : 'ஒரு நாள்',
            dd : '%d நாட்கள்',
            M : 'ஒரு மாதம்',
            MM : '%d மாதங்கள்',
            y : 'ஒரு வருடம்',
            yy : '%d ஆண்டுகள்'
        },
        dayOfMonthOrdinalParse: /\d{1,2}வது/,
        ordinal : function (number) {
            return number + 'வது';
        },
        preparse: function (string) {
            return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // refer http://ta.wikipedia.org/s/1er1
        meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
        meridiem : function (hour, minute, isLower) {
            if (hour < 2) {
                return ' யாமம்';
            } else if (hour < 6) {
                return ' வைகறை';  // வைகறை
            } else if (hour < 10) {
                return ' காலை'; // காலை
            } else if (hour < 14) {
                return ' நண்பகல்'; // நண்பகல்
            } else if (hour < 18) {
                return ' எற்பாடு'; // எற்பாடு
            } else if (hour < 22) {
                return ' மாலை'; // மாலை
            } else {
                return ' யாமம்';
            }
        },
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'யாமம்') {
                return hour < 2 ? hour : hour + 12;
            } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
                return hour;
            } else if (meridiem === 'நண்பகல்') {
                return hour >= 10 ? hour : hour + 12;
            } else {
                return hour + 12;
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return ta;

})));


/***/ }),

/***/ "3e92":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '೧',
        '2': '೨',
        '3': '೩',
        '4': '೪',
        '5': '೫',
        '6': '೬',
        '7': '೭',
        '8': '೮',
        '9': '೯',
        '0': '೦'
    },
    numberMap = {
        '೧': '1',
        '೨': '2',
        '೩': '3',
        '೪': '4',
        '೫': '5',
        '೬': '6',
        '೭': '7',
        '೮': '8',
        '೯': '9',
        '೦': '0'
    };

    var kn = moment.defineLocale('kn', {
        months : 'ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್'.split('_'),
        monthsShort : 'ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂ_ಅಕ್ಟೋ_ನವೆಂ_ಡಿಸೆಂ'.split('_'),
        monthsParseExact: true,
        weekdays : 'ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ'.split('_'),
        weekdaysShort : 'ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ'.split('_'),
        weekdaysMin : 'ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[ಇಂದು] LT',
            nextDay : '[ನಾಳೆ] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[ನಿನ್ನೆ] LT',
            lastWeek : '[ಕೊನೆಯ] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ನಂತರ',
            past : '%s ಹಿಂದೆ',
            s : 'ಕೆಲವು ಕ್ಷಣಗಳು',
            ss : '%d ಸೆಕೆಂಡುಗಳು',
            m : 'ಒಂದು ನಿಮಿಷ',
            mm : '%d ನಿಮಿಷ',
            h : 'ಒಂದು ಗಂಟೆ',
            hh : '%d ಗಂಟೆ',
            d : 'ಒಂದು ದಿನ',
            dd : '%d ದಿನ',
            M : 'ಒಂದು ತಿಂಗಳು',
            MM : '%d ತಿಂಗಳು',
            y : 'ಒಂದು ವರ್ಷ',
            yy : '%d ವರ್ಷ'
        },
        preparse: function (string) {
            return string.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ರಾತ್ರಿ') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'ಬೆಳಿಗ್ಗೆ') {
                return hour;
            } else if (meridiem === 'ಮಧ್ಯಾಹ್ನ') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'ಸಂಜೆ') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ರಾತ್ರಿ';
            } else if (hour < 10) {
                return 'ಬೆಳಿಗ್ಗೆ';
            } else if (hour < 17) {
                return 'ಮಧ್ಯಾಹ್ನ';
            } else if (hour < 20) {
                return 'ಸಂಜೆ';
            } else {
                return 'ರಾತ್ರಿ';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/,
        ordinal : function (number) {
            return number + 'ನೇ';
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return kn;

})));


/***/ }),

/***/ "3eea":
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__("7948"),
    baseClone = __webpack_require__("3818"),
    baseUnset = __webpack_require__("4bb5"),
    castPath = __webpack_require__("e2e4"),
    copyObject = __webpack_require__("8eeb"),
    customOmitClone = __webpack_require__("e0e7"),
    flatRest = __webpack_require__("c6cf"),
    getAllKeysIn = __webpack_require__("1bac");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});

module.exports = omit;


/***/ }),

/***/ "3f6b":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("51b6"), __esModule: true };

/***/ }),

/***/ "4039":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @ignore
 * base event object for custom and dom event.
 * @author yiminghe@gmail.com
 */



Object.defineProperty(exports, "__esModule", {
  value: true
});
function returnFalse() {
  return false;
}

function returnTrue() {
  return true;
}

function EventBaseObject() {
  this.timeStamp = Date.now();
  this.target = undefined;
  this.currentTarget = undefined;
}

EventBaseObject.prototype = {
  isEventObject: 1,

  constructor: EventBaseObject,

  isDefaultPrevented: returnFalse,

  isPropagationStopped: returnFalse,

  isImmediatePropagationStopped: returnFalse,

  preventDefault: function preventDefault() {
    this.isDefaultPrevented = returnTrue;
  },

  stopPropagation: function stopPropagation() {
    this.isPropagationStopped = returnTrue;
  },

  stopImmediatePropagation: function stopImmediatePropagation() {
    this.isImmediatePropagationStopped = returnTrue;
    // fixed 1.2
    // call stopPropagation implicitly
    this.stopPropagation();
  },

  halt: function halt(immediate) {
    if (immediate) {
      this.stopImmediatePropagation();
    } else {
      this.stopPropagation();
    }
    this.preventDefault();
  }
};

exports["default"] = EventBaseObject;
module.exports = exports["default"];

/***/ }),

/***/ "408c":
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__("2b3e");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ "41b2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__("3f6b");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),

/***/ "41c3":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("1a8c"),
    isPrototype = __webpack_require__("eac5"),
    nativeKeysIn = __webpack_require__("ec8c");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ "423e":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var arKw = moment.defineLocale('ar-kw', {
        months : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        monthsShort : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
        weekdays : 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort : 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'في %s',
            past : 'منذ %s',
            s : 'ثوان',
            ss : '%d ثانية',
            m : 'دقيقة',
            mm : '%d دقائق',
            h : 'ساعة',
            hh : '%d ساعات',
            d : 'يوم',
            dd : '%d أيام',
            M : 'شهر',
            MM : '%d أشهر',
            y : 'سنة',
            yy : '%d سنوات'
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return arKw;

})));


/***/ }),

/***/ "4245":
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__("1290");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "4284":
/***/ (function(module, exports) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ "42a2":
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__("b5a7"),
    Map = __webpack_require__("79bc"),
    Promise = __webpack_require__("1cec"),
    Set = __webpack_require__("c869"),
    WeakMap = __webpack_require__("39ff"),
    baseGetTag = __webpack_require__("3729"),
    toSource = __webpack_require__("dc57");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ "4359":
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ "4362":
/***/ (function(module, exports, __webpack_require__) {

exports.nextTick = function nextTick(fn) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();
    setTimeout(function () {
        fn.apply(null, args);
    }, 0);
};

exports.platform = exports.arch = 
exports.execPath = exports.title = 'browser';
exports.pid = 1;
exports.browser = true;
exports.env = {};
exports.argv = [];

exports.binding = function (name) {
	throw new Error('No such module. (Possibly not yet loaded)')
};

(function () {
    var cwd = '/';
    var path;
    exports.cwd = function () { return cwd };
    exports.chdir = function (dir) {
        if (!path) path = __webpack_require__("df7c");
        cwd = path.resolve(dir, cwd);
    };
})();

exports.exit = exports.kill = 
exports.umask = exports.dlopen = 
exports.uptime = exports.memoryUsage = 
exports.uvCounters = function() {};
exports.features = {};


/***/ }),

/***/ "440c":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eng Minutt', 'enger Minutt'],
            'h': ['eng Stonn', 'enger Stonn'],
            'd': ['een Dag', 'engem Dag'],
            'M': ['ee Mount', 'engem Mount'],
            'y': ['ee Joer', 'engem Joer']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'a ' + string;
        }
        return 'an ' + string;
    }
    function processPastTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'viru ' + string;
        }
        return 'virun ' + string;
    }
    /**
     * Returns true if the word before the given number loses the '-n' ending.
     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
     *
     * @param number {integer}
     * @returns {boolean}
     */
    function eifelerRegelAppliesToNumber(number) {
        number = parseInt(number, 10);
        if (isNaN(number)) {
            return false;
        }
        if (number < 0) {
            // Negative Number --> always true
            return true;
        } else if (number < 10) {
            // Only 1 digit
            if (4 <= number && number <= 7) {
                return true;
            }
            return false;
        } else if (number < 100) {
            // 2 digits
            var lastDigit = number % 10, firstDigit = number / 10;
            if (lastDigit === 0) {
                return eifelerRegelAppliesToNumber(firstDigit);
            }
            return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number < 10000) {
            // 3 or 4 digits --> recursively check first digit
            while (number >= 10) {
                number = number / 10;
            }
            return eifelerRegelAppliesToNumber(number);
        } else {
            // Anything larger than 4 digits: recursively check first n-3 digits
            number = number / 1000;
            return eifelerRegelAppliesToNumber(number);
        }
    }

    var lb = moment.defineLocale('lb', {
        months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
        weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm [Auer]',
            LTS: 'H:mm:ss [Auer]',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm [Auer]',
            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
        },
        calendar: {
            sameDay: '[Haut um] LT',
            sameElse: 'L',
            nextDay: '[Muer um] LT',
            nextWeek: 'dddd [um] LT',
            lastDay: '[Gëschter um] LT',
            lastWeek: function () {
                // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                switch (this.day()) {
                    case 2:
                    case 4:
                        return '[Leschten] dddd [um] LT';
                    default:
                        return '[Leschte] dddd [um] LT';
                }
            }
        },
        relativeTime : {
            future : processFutureTime,
            past : processPastTime,
            s : 'e puer Sekonnen',
            ss : '%d Sekonnen',
            m : processRelativeTime,
            mm : '%d Minutten',
            h : processRelativeTime,
            hh : '%d Stonnen',
            d : processRelativeTime,
            dd : '%d Deeg',
            M : processRelativeTime,
            MM : '%d Méint',
            y : processRelativeTime,
            yy : '%d Joer'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lb;

})));


/***/ }),

/***/ "4416":
/***/ (function(module, exports) {

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;


/***/ }),

/***/ "448a":
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__("2236");

var iterableToArray = __webpack_require__("11b0");

var unsupportedIterableToArray = __webpack_require__("6613");

var nonIterableSpread = __webpack_require__("0676");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),

/***/ "454f":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("46a7");
var $Object = __webpack_require__("584a").Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),

/***/ "4678":
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": "2bfb",
	"./af.js": "2bfb",
	"./ar": "8e73",
	"./ar-dz": "a356",
	"./ar-dz.js": "a356",
	"./ar-kw": "423e",
	"./ar-kw.js": "423e",
	"./ar-ly": "1cfd",
	"./ar-ly.js": "1cfd",
	"./ar-ma": "0a84",
	"./ar-ma.js": "0a84",
	"./ar-sa": "8230",
	"./ar-sa.js": "8230",
	"./ar-tn": "6d83",
	"./ar-tn.js": "6d83",
	"./ar.js": "8e73",
	"./az": "485c",
	"./az.js": "485c",
	"./be": "1fc1",
	"./be.js": "1fc1",
	"./bg": "84aa",
	"./bg.js": "84aa",
	"./bm": "a7fa",
	"./bm.js": "a7fa",
	"./bn": "9043",
	"./bn.js": "9043",
	"./bo": "d26a",
	"./bo.js": "d26a",
	"./br": "6887",
	"./br.js": "6887",
	"./bs": "2554",
	"./bs.js": "2554",
	"./ca": "d716",
	"./ca.js": "d716",
	"./cs": "3c0d",
	"./cs.js": "3c0d",
	"./cv": "03ec",
	"./cv.js": "03ec",
	"./cy": "9797",
	"./cy.js": "9797",
	"./da": "0f14",
	"./da.js": "0f14",
	"./de": "b469",
	"./de-at": "b3eb",
	"./de-at.js": "b3eb",
	"./de-ch": "bb71",
	"./de-ch.js": "bb71",
	"./de.js": "b469",
	"./dv": "598a",
	"./dv.js": "598a",
	"./el": "8d47",
	"./el.js": "8d47",
	"./en-SG": "cdab",
	"./en-SG.js": "cdab",
	"./en-au": "0e6b",
	"./en-au.js": "0e6b",
	"./en-ca": "3886",
	"./en-ca.js": "3886",
	"./en-gb": "39a6",
	"./en-gb.js": "39a6",
	"./en-ie": "e1d3",
	"./en-ie.js": "e1d3",
	"./en-il": "7333",
	"./en-il.js": "7333",
	"./en-nz": "6f50",
	"./en-nz.js": "6f50",
	"./eo": "65db",
	"./eo.js": "65db",
	"./es": "898b",
	"./es-do": "0a3c",
	"./es-do.js": "0a3c",
	"./es-us": "55c9",
	"./es-us.js": "55c9",
	"./es.js": "898b",
	"./et": "ec18",
	"./et.js": "ec18",
	"./eu": "0ff2",
	"./eu.js": "0ff2",
	"./fa": "8df4",
	"./fa.js": "8df4",
	"./fi": "81e9",
	"./fi.js": "81e9",
	"./fo": "0721",
	"./fo.js": "0721",
	"./fr": "9f26",
	"./fr-ca": "d9f8",
	"./fr-ca.js": "d9f8",
	"./fr-ch": "0e49",
	"./fr-ch.js": "0e49",
	"./fr.js": "9f26",
	"./fy": "7118",
	"./fy.js": "7118",
	"./ga": "5120",
	"./ga.js": "5120",
	"./gd": "f6b4",
	"./gd.js": "f6b4",
	"./gl": "8840",
	"./gl.js": "8840",
	"./gom-latn": "0caa",
	"./gom-latn.js": "0caa",
	"./gu": "e0c5",
	"./gu.js": "e0c5",
	"./he": "c7aa",
	"./he.js": "c7aa",
	"./hi": "dc4d",
	"./hi.js": "dc4d",
	"./hr": "4ba9",
	"./hr.js": "4ba9",
	"./hu": "5b14",
	"./hu.js": "5b14",
	"./hy-am": "d6b6",
	"./hy-am.js": "d6b6",
	"./id": "5038",
	"./id.js": "5038",
	"./is": "0558",
	"./is.js": "0558",
	"./it": "6e98",
	"./it-ch": "6f12",
	"./it-ch.js": "6f12",
	"./it.js": "6e98",
	"./ja": "079e",
	"./ja.js": "079e",
	"./jv": "b540",
	"./jv.js": "b540",
	"./ka": "201b",
	"./ka.js": "201b",
	"./kk": "6d79",
	"./kk.js": "6d79",
	"./km": "e81d",
	"./km.js": "e81d",
	"./kn": "3e92",
	"./kn.js": "3e92",
	"./ko": "22f8",
	"./ko.js": "22f8",
	"./ku": "2421",
	"./ku.js": "2421",
	"./ky": "9609",
	"./ky.js": "9609",
	"./lb": "440c",
	"./lb.js": "440c",
	"./lo": "b29d",
	"./lo.js": "b29d",
	"./lt": "26f9",
	"./lt.js": "26f9",
	"./lv": "b97c",
	"./lv.js": "b97c",
	"./me": "293c",
	"./me.js": "293c",
	"./mi": "688b",
	"./mi.js": "688b",
	"./mk": "6909",
	"./mk.js": "6909",
	"./ml": "02fb",
	"./ml.js": "02fb",
	"./mn": "958b",
	"./mn.js": "958b",
	"./mr": "39bd",
	"./mr.js": "39bd",
	"./ms": "ebe4",
	"./ms-my": "6403",
	"./ms-my.js": "6403",
	"./ms.js": "ebe4",
	"./mt": "1b45",
	"./mt.js": "1b45",
	"./my": "8689",
	"./my.js": "8689",
	"./nb": "6ce3",
	"./nb.js": "6ce3",
	"./ne": "3a39",
	"./ne.js": "3a39",
	"./nl": "facd",
	"./nl-be": "db29",
	"./nl-be.js": "db29",
	"./nl.js": "facd",
	"./nn": "b84c",
	"./nn.js": "b84c",
	"./pa-in": "f3ff",
	"./pa-in.js": "f3ff",
	"./pl": "8d57",
	"./pl.js": "8d57",
	"./pt": "f260",
	"./pt-br": "d2d4",
	"./pt-br.js": "d2d4",
	"./pt.js": "f260",
	"./ro": "972c",
	"./ro.js": "972c",
	"./ru": "957c",
	"./ru.js": "957c",
	"./sd": "6784",
	"./sd.js": "6784",
	"./se": "ffff",
	"./se.js": "ffff",
	"./si": "eda5",
	"./si.js": "eda5",
	"./sk": "7be6",
	"./sk.js": "7be6",
	"./sl": "8155",
	"./sl.js": "8155",
	"./sq": "c8f3",
	"./sq.js": "c8f3",
	"./sr": "cf1e",
	"./sr-cyrl": "13e9",
	"./sr-cyrl.js": "13e9",
	"./sr.js": "cf1e",
	"./ss": "52bd",
	"./ss.js": "52bd",
	"./sv": "5fbd",
	"./sv.js": "5fbd",
	"./sw": "74dc",
	"./sw.js": "74dc",
	"./ta": "3de5",
	"./ta.js": "3de5",
	"./te": "5cbb",
	"./te.js": "5cbb",
	"./tet": "576c",
	"./tet.js": "576c",
	"./tg": "3b1b",
	"./tg.js": "3b1b",
	"./th": "10e8",
	"./th.js": "10e8",
	"./tl-ph": "0f38",
	"./tl-ph.js": "0f38",
	"./tlh": "cf75",
	"./tlh.js": "cf75",
	"./tr": "0e81",
	"./tr.js": "0e81",
	"./tzl": "cf51",
	"./tzl.js": "cf51",
	"./tzm": "c109",
	"./tzm-latn": "b53d",
	"./tzm-latn.js": "b53d",
	"./tzm.js": "c109",
	"./ug-cn": "6117",
	"./ug-cn.js": "6117",
	"./uk": "ada2",
	"./uk.js": "ada2",
	"./ur": "5294",
	"./ur.js": "5294",
	"./uz": "2e8c",
	"./uz-latn": "010e",
	"./uz-latn.js": "010e",
	"./uz.js": "2e8c",
	"./vi": "2921",
	"./vi.js": "2921",
	"./x-pseudo": "fd7e",
	"./x-pseudo.js": "fd7e",
	"./yo": "7f33",
	"./yo.js": "7f33",
	"./zh-cn": "5c3a",
	"./zh-cn.js": "5c3a",
	"./zh-hk": "49ab",
	"./zh-hk.js": "49ab",
	"./zh-tw": "90ea",
	"./zh-tw.js": "90ea"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "4678";

/***/ }),

/***/ "46a7":
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__("63b6");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__("8e60"), 'Object', { defineProperty: __webpack_require__("d9f6").f });


/***/ }),

/***/ "46cf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  install: function install(Vue) {
    var options =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var directiveName = options.name || "ref";
    Vue.directive(directiveName, {
      bind: function bind(el, binding, vnode) {
        Vue.nextTick(function() {
          binding.value(vnode.componentInstance || el, vnode.key);
        });
        binding.value(vnode.componentInstance || el, vnode.key);
      },
      update: function update(el, binding, vnode, oldVnode) {
        if (oldVnode.data && oldVnode.data.directives) {
          var oldBinding = oldVnode.data.directives.find(function(directive) {
            var name = directive.name;
            return name === directiveName;
          });
          if (oldBinding && oldBinding.value !== binding.value) {
            oldBinding && oldBinding.value(null, oldVnode.key);
            binding.value(vnode.componentInstance || el, vnode.key);
            return;
          }
        }
        // Should not have this situation
        if (
          vnode.componentInstance !== oldVnode.componentInstance ||
          vnode.elm !== oldVnode.elm
        ) {
          binding.value(vnode.componentInstance || el, vnode.key);
        }
      },
      unbind: function unbind(el, binding, vnode) {
        binding.value(null, vnode.key);
      }
    });
  }
};


/***/ }),

/***/ "47f5":
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__("2b03"),
    baseIsNaN = __webpack_require__("d9a8"),
    strictIndexOf = __webpack_require__("099a");

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


/***/ }),

/***/ "4849":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("454f"), __esModule: true };

/***/ }),

/***/ "485c":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var suffixes = {
        1: '-inci',
        5: '-inci',
        8: '-inci',
        70: '-inci',
        80: '-inci',
        2: '-nci',
        7: '-nci',
        20: '-nci',
        50: '-nci',
        3: '-üncü',
        4: '-üncü',
        100: '-üncü',
        6: '-ncı',
        9: '-uncu',
        10: '-uncu',
        30: '-uncu',
        60: '-ıncı',
        90: '-ıncı'
    };

    var az = moment.defineLocale('az', {
        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
        weekdays : 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split('_'),
        weekdaysShort : 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
        weekdaysMin : 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[bugün saat] LT',
            nextDay : '[sabah saat] LT',
            nextWeek : '[gələn həftə] dddd [saat] LT',
            lastDay : '[dünən] LT',
            lastWeek : '[keçən həftə] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s əvvəl',
            s : 'birneçə saniyə',
            ss : '%d saniyə',
            m : 'bir dəqiqə',
            mm : '%d dəqiqə',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gün',
            dd : '%d gün',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir il',
            yy : '%d il'
        },
        meridiemParse: /gecə|səhər|gündüz|axşam/,
        isPM : function (input) {
            return /^(gündüz|axşam)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'gecə';
            } else if (hour < 12) {
                return 'səhər';
            } else if (hour < 17) {
                return 'gündüz';
            } else {
                return 'axşam';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
        ordinal : function (number) {
            if (number === 0) {  // special case for zero
                return number + '-ıncı';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return az;

})));


/***/ }),

/***/ "48a0":
/***/ (function(module, exports, __webpack_require__) {

var baseForOwn = __webpack_require__("242e"),
    createBaseEach = __webpack_require__("950a");

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),

/***/ "49ab":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var zhHk = moment.defineLocale('zh-hk', {
        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYY年M月D日',
            LLL : 'YYYY年M月D日 HH:mm',
            LLLL : 'YYYY年M月D日dddd HH:mm',
            l : 'YYYY/M/D',
            ll : 'YYYY年M月D日',
            lll : 'YYYY年M月D日 HH:mm',
            llll : 'YYYY年M月D日dddd HH:mm'
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                return hour;
            } else if (meridiem === '中午') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1130) {
                return '上午';
            } else if (hm < 1230) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar : {
            sameDay : '[今天]LT',
            nextDay : '[明天]LT',
            nextWeek : '[下]ddddLT',
            lastDay : '[昨天]LT',
            lastWeek : '[上]ddddLT',
            sameElse : 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd' :
                case 'D' :
                case 'DDD' :
                    return number + '日';
                case 'M' :
                    return number + '月';
                case 'w' :
                case 'W' :
                    return number + '週';
                default :
                    return number;
            }
        },
        relativeTime : {
            future : '%s內',
            past : '%s前',
            s : '幾秒',
            ss : '%d 秒',
            m : '1 分鐘',
            mm : '%d 分鐘',
            h : '1 小時',
            hh : '%d 小時',
            d : '1 天',
            dd : '%d 天',
            M : '1 個月',
            MM : '%d 個月',
            y : '1 年',
            yy : '%d 年'
        }
    });

    return zhHk;

})));


/***/ }),

/***/ "49f4":
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__("6044");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "4b17":
/***/ (function(module, exports, __webpack_require__) {

var toFinite = __webpack_require__("6428");

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;


/***/ }),

/***/ "4ba9":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                if (number === 1) {
                    result += 'sekunda';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sekunde';
                } else {
                    result += 'sekundi';
                }
                return result;
            case 'm':
                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
            case 'mm':
                if (number === 1) {
                    result += 'minuta';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'minute';
                } else {
                    result += 'minuta';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'jedan sat' : 'jednog sata';
            case 'hh':
                if (number === 1) {
                    result += 'sat';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sata';
                } else {
                    result += 'sati';
                }
                return result;
            case 'dd':
                if (number === 1) {
                    result += 'dan';
                } else {
                    result += 'dana';
                }
                return result;
            case 'MM':
                if (number === 1) {
                    result += 'mjesec';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'mjeseca';
                } else {
                    result += 'mjeseci';
                }
                return result;
            case 'yy':
                if (number === 1) {
                    result += 'godina';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'godine';
                } else {
                    result += 'godina';
                }
                return result;
        }
    }

    var hr = moment.defineLocale('hr', {
        months : {
            format: 'siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
            standalone: 'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
        },
        monthsShort : 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jučer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                        return '[prošlu] dddd [u] LT';
                    case 6:
                        return '[prošle] [subote] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[prošli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            ss     : translate,
            m      : translate,
            mm     : translate,
            h      : translate,
            hh     : translate,
            d      : 'dan',
            dd     : translate,
            M      : 'mjesec',
            MM     : translate,
            y      : 'godinu',
            yy     : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return hr;

})));


/***/ }),

/***/ "4bb5":
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__("e2e4"),
    last = __webpack_require__("4416"),
    parent = __webpack_require__("8296"),
    toKey = __webpack_require__("f4d6");

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;


/***/ }),

/***/ "4d26":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ "4d8c":
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__("5c69");

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),

/***/ "5038":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var id = moment.defineLocale('id', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'siang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sore' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'siang';
            } else if (hours < 19) {
                return 'sore';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Besok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kemarin pukul] LT',
            lastWeek : 'dddd [lalu pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lalu',
            s : 'beberapa detik',
            ss : '%d detik',
            m : 'semenit',
            mm : '%d menit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return id;

})));


/***/ }),

/***/ "50c6":
/***/ (function(module, exports, __webpack_require__) {

var arrayAggregator = __webpack_require__("a0c4"),
    baseAggregator = __webpack_require__("243f"),
    baseIteratee = __webpack_require__("badf"),
    isArray = __webpack_require__("6747");

/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray(collection) ? arrayAggregator : baseAggregator,
        accumulator = initializer ? initializer() : {};

    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
  };
}

module.exports = createAggregator;


/***/ }),

/***/ "50d8":
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "5118":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__("6017");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "5120":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';



    var months = [
        'Eanáir', 'Feabhra', 'Márta', 'Aibreán', 'Bealtaine', 'Méitheamh', 'Iúil', 'Lúnasa', 'Meán Fómhair', 'Deaireadh Fómhair', 'Samhain', 'Nollaig'
    ];

    var monthsShort = ['Eaná', 'Feab', 'Márt', 'Aibr', 'Beal', 'Méit', 'Iúil', 'Lúna', 'Meán', 'Deai', 'Samh', 'Noll'];

    var weekdays = ['Dé Domhnaigh', 'Dé Luain', 'Dé Máirt', 'Dé Céadaoin', 'Déardaoin', 'Dé hAoine', 'Dé Satharn'];

    var weekdaysShort = ['Dom', 'Lua', 'Mái', 'Céa', 'Déa', 'hAo', 'Sat'];

    var weekdaysMin = ['Do', 'Lu', 'Má', 'Ce', 'Dé', 'hA', 'Sa'];

    var ga = moment.defineLocale('ga', {
        months: months,
        monthsShort: monthsShort,
        monthsParseExact: true,
        weekdays: weekdays,
        weekdaysShort: weekdaysShort,
        weekdaysMin: weekdaysMin,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Inniu ag] LT',
            nextDay: '[Amárach ag] LT',
            nextWeek: 'dddd [ag] LT',
            lastDay: '[Inné aig] LT',
            lastWeek: 'dddd [seo caite] [ag] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'i %s',
            past: '%s ó shin',
            s: 'cúpla soicind',
            ss: '%d soicind',
            m: 'nóiméad',
            mm: '%d nóiméad',
            h: 'uair an chloig',
            hh: '%d uair an chloig',
            d: 'lá',
            dd: '%d lá',
            M: 'mí',
            MM: '%d mí',
            y: 'bliain',
            yy: '%d bliain'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
        ordinal: function (number) {
            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ga;

})));


/***/ }),

/***/ "51b6":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("a3c3");
module.exports = __webpack_require__("584a").Object.assign;


/***/ }),

/***/ "51f5":
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__("2b03"),
    baseIteratee = __webpack_require__("badf"),
    toInteger = __webpack_require__("4b17");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;


/***/ }),

/***/ "5294":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var months = [
        'جنوری',
        'فروری',
        'مارچ',
        'اپریل',
        'مئی',
        'جون',
        'جولائی',
        'اگست',
        'ستمبر',
        'اکتوبر',
        'نومبر',
        'دسمبر'
    ];
    var days = [
        'اتوار',
        'پیر',
        'منگل',
        'بدھ',
        'جمعرات',
        'جمعہ',
        'ہفتہ'
    ];

    var ur = moment.defineLocale('ur', {
        months : months,
        monthsShort : months,
        weekdays : days,
        weekdaysShort : days,
        weekdaysMin : days,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd، D MMMM YYYY HH:mm'
        },
        meridiemParse: /صبح|شام/,
        isPM : function (input) {
            return 'شام' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'صبح';
            }
            return 'شام';
        },
        calendar : {
            sameDay : '[آج بوقت] LT',
            nextDay : '[کل بوقت] LT',
            nextWeek : 'dddd [بوقت] LT',
            lastDay : '[گذشتہ روز بوقت] LT',
            lastWeek : '[گذشتہ] dddd [بوقت] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s بعد',
            past : '%s قبل',
            s : 'چند سیکنڈ',
            ss : '%d سیکنڈ',
            m : 'ایک منٹ',
            mm : '%d منٹ',
            h : 'ایک گھنٹہ',
            hh : '%d گھنٹے',
            d : 'ایک دن',
            dd : '%d دن',
            M : 'ایک ماہ',
            MM : '%d ماہ',
            y : 'ایک سال',
            yy : '%d سال'
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '،');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ur;

})));


/***/ }),

/***/ "52bd":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var ss = moment.defineLocale('ss', {
        months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
        monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
        weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
        weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
        weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Namuhla nga] LT',
            nextDay : '[Kusasa nga] LT',
            nextWeek : 'dddd [nga] LT',
            lastDay : '[Itolo nga] LT',
            lastWeek : 'dddd [leliphelile] [nga] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'nga %s',
            past : 'wenteka nga %s',
            s : 'emizuzwana lomcane',
            ss : '%d mzuzwana',
            m : 'umzuzu',
            mm : '%d emizuzu',
            h : 'lihora',
            hh : '%d emahora',
            d : 'lilanga',
            dd : '%d emalanga',
            M : 'inyanga',
            MM : '%d tinyanga',
            y : 'umnyaka',
            yy : '%d iminyaka'
        },
        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'ekuseni';
            } else if (hours < 15) {
                return 'emini';
            } else if (hours < 19) {
                return 'entsambama';
            } else {
                return 'ebusuku';
            }
        },
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ekuseni') {
                return hour;
            } else if (meridiem === 'emini') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
                if (hour === 0) {
                    return 0;
                }
                return hour + 12;
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ss;

})));


/***/ }),

/***/ "54eb":
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__("8eeb"),
    getSymbols = __webpack_require__("32f4");

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ "5559":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("dbdb")('keys');
var uid = __webpack_require__("62a0");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "55a3":
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ "55c9":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
    var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var esUs = moment.defineLocale('es-us', {
        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'MM/DD/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY h:mm A',
            LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            ss : '%d segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un día',
            dd : '%d días',
            M : 'un mes',
            MM : '%d meses',
            y : 'un año',
            yy : '%d años'
        },
        dayOfMonthOrdinalParse : /\d{1,2}º/,
        ordinal : '%dº',
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return esUs;

})));


/***/ }),

/***/ "576c":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var tet = moment.defineLocale('tet', {
        months : 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juñu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
        weekdaysShort : 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
        weekdaysMin : 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Ohin iha] LT',
            nextDay: '[Aban iha] LT',
            nextWeek: 'dddd [iha] LT',
            lastDay: '[Horiseik iha] LT',
            lastWeek: 'dddd [semana kotuk] [iha] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'iha %s',
            past : '%s liuba',
            s : 'minutu balun',
            ss : 'minutu %d',
            m : 'minutu ida',
            mm : 'minutu %d',
            h : 'oras ida',
            hh : 'oras %d',
            d : 'loron ida',
            dd : 'loron %d',
            M : 'fulan ida',
            MM : 'fulan %d',
            y : 'tinan ida',
            yy : 'tinan %d'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tet;

})));


/***/ }),

/***/ "57a5":
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__("91e9");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "57ba":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__("4849");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),

/***/ "584a":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "585a":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "598a":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var months = [
        'ޖެނުއަރީ',
        'ފެބްރުއަރީ',
        'މާރިޗު',
        'އޭޕްރީލު',
        'މޭ',
        'ޖޫން',
        'ޖުލައި',
        'އޯގަސްޓު',
        'ސެޕްޓެމްބަރު',
        'އޮކްޓޯބަރު',
        'ނޮވެމްބަރު',
        'ޑިސެމްބަރު'
    ], weekdays = [
        'އާދިއްތަ',
        'ހޯމަ',
        'އަންގާރަ',
        'ބުދަ',
        'ބުރާސްފަތި',
        'ހުކުރު',
        'ހޮނިހިރު'
    ];

    var dv = moment.defineLocale('dv', {
        months : months,
        monthsShort : months,
        weekdays : weekdays,
        weekdaysShort : weekdays,
        weekdaysMin : 'އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި'.split('_'),
        longDateFormat : {

            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/M/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /މކ|މފ/,
        isPM : function (input) {
            return 'މފ' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'މކ';
            } else {
                return 'މފ';
            }
        },
        calendar : {
            sameDay : '[މިއަދު] LT',
            nextDay : '[މާދަމާ] LT',
            nextWeek : 'dddd LT',
            lastDay : '[އިއްޔެ] LT',
            lastWeek : '[ފާއިތުވި] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ތެރޭގައި %s',
            past : 'ކުރިން %s',
            s : 'ސިކުންތުކޮޅެއް',
            ss : 'd% ސިކުންތު',
            m : 'މިނިޓެއް',
            mm : 'މިނިޓު %d',
            h : 'ގަޑިއިރެއް',
            hh : 'ގަޑިއިރު %d',
            d : 'ދުވަހެއް',
            dd : 'ދުވަސް %d',
            M : 'މަހެއް',
            MM : 'މަސް %d',
            y : 'އަހަރެއް',
            yy : 'އަހަރު %d'
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '،');
        },
        week : {
            dow : 7,  // Sunday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return dv;

})));


/***/ }),

/***/ "5a43":
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "5b01":
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__("8eeb"),
    keys = __webpack_require__("ec69");

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ "5b14":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(' ');
    function translate(number, withoutSuffix, key, isFuture) {
        var num = number;
        switch (key) {
            case 's':
                return (isFuture || withoutSuffix) ? 'néhány másodperc' : 'néhány másodperce';
            case 'ss':
                return num + (isFuture || withoutSuffix) ? ' másodperc' : ' másodperce';
            case 'm':
                return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'mm':
                return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'h':
                return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');
            case 'hh':
                return num + (isFuture || withoutSuffix ? ' óra' : ' órája');
            case 'd':
                return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'dd':
                return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'M':
                return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
            case 'MM':
                return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
            case 'y':
                return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');
            case 'yy':
                return num + (isFuture || withoutSuffix ? ' év' : ' éve');
        }
        return '';
    }
    function week(isFuture) {
        return (isFuture ? '' : '[múlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
    }

    var hu = moment.defineLocale('hu', {
        months : 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split('_'),
        monthsShort : 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
        weekdays : 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
        weekdaysShort : 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'YYYY.MM.DD.',
            LL : 'YYYY. MMMM D.',
            LLL : 'YYYY. MMMM D. H:mm',
            LLLL : 'YYYY. MMMM D., dddd H:mm'
        },
        meridiemParse: /de|du/i,
        isPM: function (input) {
            return input.charAt(1).toLowerCase() === 'u';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower === true ? 'de' : 'DE';
            } else {
                return isLower === true ? 'du' : 'DU';
            }
        },
        calendar : {
            sameDay : '[ma] LT[-kor]',
            nextDay : '[holnap] LT[-kor]',
            nextWeek : function () {
                return week.call(this, true);
            },
            lastDay : '[tegnap] LT[-kor]',
            lastWeek : function () {
                return week.call(this, false);
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s múlva',
            past : '%s',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return hu;

})));


/***/ }),

/***/ "5b4e":
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__("36c3");
var toLength = __webpack_require__("b447");
var toAbsoluteIndex = __webpack_require__("0fc9");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "5c3a":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var zhCn = moment.defineLocale('zh-cn', {
        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort : '周日_周一_周二_周三_周四_周五_周六'.split('_'),
        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYY年M月D日',
            LLL : 'YYYY年M月D日Ah点mm分',
            LLLL : 'YYYY年M月D日ddddAh点mm分',
            l : 'YYYY/M/D',
            ll : 'YYYY年M月D日',
            lll : 'YYYY年M月D日 HH:mm',
            llll : 'YYYY年M月D日dddd HH:mm'
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' ||
                    meridiem === '上午') {
                return hour;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            } else {
                // '中午'
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1130) {
                return '上午';
            } else if (hm < 1230) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar : {
            sameDay : '[今天]LT',
            nextDay : '[明天]LT',
            nextWeek : '[下]ddddLT',
            lastDay : '[昨天]LT',
            lastWeek : '[上]ddddLT',
            sameElse : 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '日';
                case 'M':
                    return number + '月';
                case 'w':
                case 'W':
                    return number + '周';
                default:
                    return number;
            }
        },
        relativeTime : {
            future : '%s内',
            past : '%s前',
            s : '几秒',
            ss : '%d 秒',
            m : '1 分钟',
            mm : '%d 分钟',
            h : '1 小时',
            hh : '%d 小时',
            d : '1 天',
            dd : '%d 天',
            M : '1 个月',
            MM : '%d 个月',
            y : '1 年',
            yy : '%d 年'
        },
        week : {
            // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return zhCn;

})));


/***/ }),

/***/ "5c69":
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__("087d"),
    isFlattenable = __webpack_require__("0621");

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),

/***/ "5cbb":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var te = moment.defineLocale('te', {
        months : 'జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జులై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్'.split('_'),
        monthsShort : 'జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జులై_ఆగ._సెప్._అక్టో._నవ._డిసె.'.split('_'),
        monthsParseExact : true,
        weekdays : 'ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం'.split('_'),
        weekdaysShort : 'ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని'.split('_'),
        weekdaysMin : 'ఆ_సో_మం_బు_గు_శు_శ'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[నేడు] LT',
            nextDay : '[రేపు] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[నిన్న] LT',
            lastWeek : '[గత] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s లో',
            past : '%s క్రితం',
            s : 'కొన్ని క్షణాలు',
            ss : '%d సెకన్లు',
            m : 'ఒక నిమిషం',
            mm : '%d నిమిషాలు',
            h : 'ఒక గంట',
            hh : '%d గంటలు',
            d : 'ఒక రోజు',
            dd : '%d రోజులు',
            M : 'ఒక నెల',
            MM : '%d నెలలు',
            y : 'ఒక సంవత్సరం',
            yy : '%d సంవత్సరాలు'
        },
        dayOfMonthOrdinalParse : /\d{1,2}వ/,
        ordinal : '%dవ',
        meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'రాత్రి') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'ఉదయం') {
                return hour;
            } else if (meridiem === 'మధ్యాహ్నం') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'సాయంత్రం') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'రాత్రి';
            } else if (hour < 10) {
                return 'ఉదయం';
            } else if (hour < 17) {
                return 'మధ్యాహ్నం';
            } else if (hour < 20) {
                return 'సాయంత్రం';
            } else {
                return 'రాత్రి';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return te;

})));


/***/ }),

/***/ "5d89":
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__("f8af");

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ "5e2e":
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__("28c9"),
    listCacheDelete = __webpack_require__("69d5"),
    listCacheGet = __webpack_require__("b4c0"),
    listCacheHas = __webpack_require__("fba5"),
    listCacheSet = __webpack_require__("67ca");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "5edf":
/***/ (function(module, exports) {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;


/***/ }),

/***/ "5fbd":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var sv = moment.defineLocale('sv', {
        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
        weekdaysShort : 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
        weekdaysMin : 'sö_må_ti_on_to_fr_lö'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [kl.] HH:mm',
            LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Idag] LT',
            nextDay: '[Imorgon] LT',
            lastDay: '[Igår] LT',
            nextWeek: '[På] dddd LT',
            lastWeek: '[I] dddd[s] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'för %s sedan',
            s : 'några sekunder',
            ss : '%d sekunder',
            m : 'en minut',
            mm : '%d minuter',
            h : 'en timme',
            hh : '%d timmar',
            d : 'en dag',
            dd : '%d dagar',
            M : 'en månad',
            MM : '%d månader',
            y : 'ett år',
            yy : '%d år'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'e' :
                (b === 1) ? 'a' :
                (b === 2) ? 'a' :
                (b === 3) ? 'e' : 'e';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sv;

})));


/***/ }),

/***/ "6017":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba"), __webpack_require__("4362")))

/***/ }),

/***/ "6044":
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__("0b07");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "60ed":
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__("3729"),
    getPrototype = __webpack_require__("2dcb"),
    isObjectLike = __webpack_require__("1310");

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),

/***/ "6117":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js language configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var ugCn = moment.defineLocale('ug-cn', {
        months: 'يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر'.split(
            '_'
        ),
        monthsShort: 'يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر'.split(
            '_'
        ),
        weekdays: 'يەكشەنبە_دۈشەنبە_سەيشەنبە_چارشەنبە_پەيشەنبە_جۈمە_شەنبە'.split(
            '_'
        ),
        weekdaysShort: 'يە_دۈ_سە_چا_پە_جۈ_شە'.split('_'),
        weekdaysMin: 'يە_دۈ_سە_چا_پە_جۈ_شە'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'YYYY-يىلىM-ئاينىڭD-كۈنى',
            LLL: 'YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm',
            LLLL: 'dddd، YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm'
        },
        meridiemParse: /يېرىم كېچە|سەھەر|چۈشتىن بۇرۇن|چۈش|چۈشتىن كېيىن|كەچ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (
                meridiem === 'يېرىم كېچە' ||
                meridiem === 'سەھەر' ||
                meridiem === 'چۈشتىن بۇرۇن'
            ) {
                return hour;
            } else if (meridiem === 'چۈشتىن كېيىن' || meridiem === 'كەچ') {
                return hour + 12;
            } else {
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return 'يېرىم كېچە';
            } else if (hm < 900) {
                return 'سەھەر';
            } else if (hm < 1130) {
                return 'چۈشتىن بۇرۇن';
            } else if (hm < 1230) {
                return 'چۈش';
            } else if (hm < 1800) {
                return 'چۈشتىن كېيىن';
            } else {
                return 'كەچ';
            }
        },
        calendar: {
            sameDay: '[بۈگۈن سائەت] LT',
            nextDay: '[ئەتە سائەت] LT',
            nextWeek: '[كېلەركى] dddd [سائەت] LT',
            lastDay: '[تۆنۈگۈن] LT',
            lastWeek: '[ئالدىنقى] dddd [سائەت] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s كېيىن',
            past: '%s بۇرۇن',
            s: 'نەچچە سېكونت',
            ss: '%d سېكونت',
            m: 'بىر مىنۇت',
            mm: '%d مىنۇت',
            h: 'بىر سائەت',
            hh: '%d سائەت',
            d: 'بىر كۈن',
            dd: '%d كۈن',
            M: 'بىر ئاي',
            MM: '%d ئاي',
            y: 'بىر يىل',
            yy: '%d يىل'
        },

        dayOfMonthOrdinalParse: /\d{1,2}(-كۈنى|-ئاي|-ھەپتە)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '-كۈنى';
                case 'w':
                case 'W':
                    return number + '-ھەپتە';
                default:
                    return number;
            }
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '،');
        },
        week: {
            // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ugCn;

})));


/***/ }),

/***/ "62a0":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "62e4":
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "63b6":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("e53d");
var core = __webpack_require__("584a");
var ctx = __webpack_require__("d864");
var hide = __webpack_require__("35e8");
var has = __webpack_require__("07e3");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "6403":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var msMy = moment.defineLocale('ms-my', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            ss : '%d saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return msMy;

})));


/***/ }),

/***/ "6428":
/***/ (function(module, exports, __webpack_require__) {

var toNumber = __webpack_require__("b4b0");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),

/***/ "642a":
/***/ (function(module, exports, __webpack_require__) {

var baseIsMatch = __webpack_require__("966f"),
    getMatchData = __webpack_require__("3bb4"),
    matchesStrictComparable = __webpack_require__("20ec");

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),

/***/ "656b":
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__("e2e4"),
    toKey = __webpack_require__("f4d6");

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ "65db":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var eo = moment.defineLocale('eo', {
        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec'.split('_'),
        weekdays : 'dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato'.split('_'),
        weekdaysShort : 'dim_lun_mard_merk_ĵaŭ_ven_sab'.split('_'),
        weekdaysMin : 'di_lu_ma_me_ĵa_ve_sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D[-a de] MMMM, YYYY',
            LLL : 'D[-a de] MMMM, YYYY HH:mm',
            LLLL : 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function (input) {
            return input.charAt(0).toLowerCase() === 'p';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'p.t.m.' : 'P.T.M.';
            } else {
                return isLower ? 'a.t.m.' : 'A.T.M.';
            }
        },
        calendar : {
            sameDay : '[Hodiaŭ je] LT',
            nextDay : '[Morgaŭ je] LT',
            nextWeek : 'dddd [je] LT',
            lastDay : '[Hieraŭ je] LT',
            lastWeek : '[pasinta] dddd [je] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'post %s',
            past : 'antaŭ %s',
            s : 'sekundoj',
            ss : '%d sekundoj',
            m : 'minuto',
            mm : '%d minutoj',
            h : 'horo',
            hh : '%d horoj',
            d : 'tago',//ne 'diurno', ĉar estas uzita por proksimumo
            dd : '%d tagoj',
            M : 'monato',
            MM : '%d monatoj',
            y : 'jaro',
            yy : '%d jaroj'
        },
        dayOfMonthOrdinalParse: /\d{1,2}a/,
        ordinal : '%da',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return eo;

})));


/***/ }),

/***/ "6613":
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__("5a43");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "66cb":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function(Math) {

var trimLeft = /^\s+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathRandom = Math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function(allow4Char) {
        return '#' + this.toHex8(allow4Char);
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
            formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },
    clone: function() {
        return tinycolor(this.toString());
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ];

    // Return a 4 character hex if possible
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;

    var rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((Math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            a: convertHexToDecimal(match[4] + '' + match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}

// Node: Export function
if ( true && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {return tinycolor;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}
// Browser: Expose to window
else {}

})(Math);


/***/ }),

/***/ "6747":
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "6784":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var months = [
        'جنوري',
        'فيبروري',
        'مارچ',
        'اپريل',
        'مئي',
        'جون',
        'جولاءِ',
        'آگسٽ',
        'سيپٽمبر',
        'آڪٽوبر',
        'نومبر',
        'ڊسمبر'
    ];
    var days = [
        'آچر',
        'سومر',
        'اڱارو',
        'اربع',
        'خميس',
        'جمع',
        'ڇنڇر'
    ];

    var sd = moment.defineLocale('sd', {
        months : months,
        monthsShort : months,
        weekdays : days,
        weekdaysShort : days,
        weekdaysMin : days,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd، D MMMM YYYY HH:mm'
        },
        meridiemParse: /صبح|شام/,
        isPM : function (input) {
            return 'شام' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'صبح';
            }
            return 'شام';
        },
        calendar : {
            sameDay : '[اڄ] LT',
            nextDay : '[سڀاڻي] LT',
            nextWeek : 'dddd [اڳين هفتي تي] LT',
            lastDay : '[ڪالهه] LT',
            lastWeek : '[گزريل هفتي] dddd [تي] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s پوء',
            past : '%s اڳ',
            s : 'چند سيڪنڊ',
            ss : '%d سيڪنڊ',
            m : 'هڪ منٽ',
            mm : '%d منٽ',
            h : 'هڪ ڪلاڪ',
            hh : '%d ڪلاڪ',
            d : 'هڪ ڏينهن',
            dd : '%d ڏينهن',
            M : 'هڪ مهينو',
            MM : '%d مهينا',
            y : 'هڪ سال',
            yy : '%d سال'
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '،');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sd;

})));


/***/ }),

/***/ "67ca":
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__("cb5a");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "6887":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function relativeTimeWithMutation(number, withoutSuffix, key) {
        var format = {
            'mm': 'munutenn',
            'MM': 'miz',
            'dd': 'devezh'
        };
        return number + ' ' + mutation(format[key], number);
    }
    function specialMutationForYears(number) {
        switch (lastNumber(number)) {
            case 1:
            case 3:
            case 4:
            case 5:
            case 9:
                return number + ' bloaz';
            default:
                return number + ' vloaz';
        }
    }
    function lastNumber(number) {
        if (number > 9) {
            return lastNumber(number % 10);
        }
        return number;
    }
    function mutation(text, number) {
        if (number === 2) {
            return softMutation(text);
        }
        return text;
    }
    function softMutation(text) {
        var mutationTable = {
            'm': 'v',
            'b': 'v',
            'd': 'z'
        };
        if (mutationTable[text.charAt(0)] === undefined) {
            return text;
        }
        return mutationTable[text.charAt(0)] + text.substring(1);
    }

    var br = moment.defineLocale('br', {
        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h[e]mm A',
            LTS : 'h[e]mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D [a viz] MMMM YYYY',
            LLL : 'D [a viz] MMMM YYYY h[e]mm A',
            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
        },
        calendar : {
            sameDay : '[Hiziv da] LT',
            nextDay : '[Warc\'hoazh da] LT',
            nextWeek : 'dddd [da] LT',
            lastDay : '[Dec\'h da] LT',
            lastWeek : 'dddd [paset da] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'a-benn %s',
            past : '%s \'zo',
            s : 'un nebeud segondennoù',
            ss : '%d eilenn',
            m : 'ur vunutenn',
            mm : relativeTimeWithMutation,
            h : 'un eur',
            hh : '%d eur',
            d : 'un devezh',
            dd : relativeTimeWithMutation,
            M : 'ur miz',
            MM : relativeTimeWithMutation,
            y : 'ur bloaz',
            yy : specialMutationForYears
        },
        dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/,
        ordinal : function (number) {
            var output = (number === 1) ? 'añ' : 'vet';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return br;

})));


/***/ }),

/***/ "688b":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var mi = moment.defineLocale('mi', {
        months: 'Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea'.split('_'),
        monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
        monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
        weekdays: 'Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei'.split('_'),
        weekdaysShort: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
        weekdaysMin: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [i] HH:mm',
            LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
        },
        calendar: {
            sameDay: '[i teie mahana, i] LT',
            nextDay: '[apopo i] LT',
            nextWeek: 'dddd [i] LT',
            lastDay: '[inanahi i] LT',
            lastWeek: 'dddd [whakamutunga i] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'i roto i %s',
            past: '%s i mua',
            s: 'te hēkona ruarua',
            ss: '%d hēkona',
            m: 'he meneti',
            mm: '%d meneti',
            h: 'te haora',
            hh: '%d haora',
            d: 'he ra',
            dd: '%d ra',
            M: 'he marama',
            MM: '%d marama',
            y: 'he tau',
            yy: '%d tau'
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return mi;

})));


/***/ }),

/***/ "6909":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var mk = moment.defineLocale('mk', {
        months : 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split('_'),
        monthsShort : 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
        weekdays : 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split('_'),
        weekdaysShort : 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
        weekdaysMin : 'нe_пo_вт_ср_че_пе_сa'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : '[Денес во] LT',
            nextDay : '[Утре во] LT',
            nextWeek : '[Во] dddd [во] LT',
            lastDay : '[Вчера во] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 6:
                        return '[Изминатата] dddd [во] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[Изминатиот] dddd [во] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'после %s',
            past : 'пред %s',
            s : 'неколку секунди',
            ss : '%d секунди',
            m : 'минута',
            mm : '%d минути',
            h : 'час',
            hh : '%d часа',
            d : 'ден',
            dd : '%d дена',
            M : 'месец',
            MM : '%d месеци',
            y : 'година',
            yy : '%d години'
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-ев';
            } else if (last2Digits === 0) {
                return number + '-ен';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-ти';
            } else if (lastDigit === 1) {
                return number + '-ви';
            } else if (lastDigit === 2) {
                return number + '-ри';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-ми';
            } else {
                return number + '-ти';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return mk;

})));


/***/ }),

/***/ "69d5":
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__("cb5a");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "6b4c":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "6ce3":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var nb = moment.defineLocale('nb', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
        monthsParseExact : true,
        weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
        weekdaysShort : 'sø._ma._ti._on._to._fr._lø.'.split('_'),
        weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] HH:mm',
            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar : {
            sameDay: '[i dag kl.] LT',
            nextDay: '[i morgen kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[i går kl.] LT',
            lastWeek: '[forrige] dddd [kl.] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s siden',
            s : 'noen sekunder',
            ss : '%d sekunder',
            m : 'ett minutt',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dager',
            M : 'en måned',
            MM : '%d måneder',
            y : 'ett år',
            yy : '%d år'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nb;

})));


/***/ }),

/***/ "6d08":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

//# sourceMappingURL=performance-now.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("4362")))

/***/ }),

/***/ "6d79":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var suffixes = {
        0: '-ші',
        1: '-ші',
        2: '-ші',
        3: '-ші',
        4: '-ші',
        5: '-ші',
        6: '-шы',
        7: '-ші',
        8: '-ші',
        9: '-шы',
        10: '-шы',
        20: '-шы',
        30: '-шы',
        40: '-шы',
        50: '-ші',
        60: '-шы',
        70: '-ші',
        80: '-ші',
        90: '-шы',
        100: '-ші'
    };

    var kk = moment.defineLocale('kk', {
        months : 'қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан'.split('_'),
        monthsShort : 'қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел'.split('_'),
        weekdays : 'жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі'.split('_'),
        weekdaysShort : 'жек_дүй_сей_сәр_бей_жұм_сен'.split('_'),
        weekdaysMin : 'жк_дй_сй_ср_бй_жм_сн'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Бүгін сағат] LT',
            nextDay : '[Ертең сағат] LT',
            nextWeek : 'dddd [сағат] LT',
            lastDay : '[Кеше сағат] LT',
            lastWeek : '[Өткен аптаның] dddd [сағат] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ішінде',
            past : '%s бұрын',
            s : 'бірнеше секунд',
            ss : '%d секунд',
            m : 'бір минут',
            mm : '%d минут',
            h : 'бір сағат',
            hh : '%d сағат',
            d : 'бір күн',
            dd : '%d күн',
            M : 'бір ай',
            MM : '%d ай',
            y : 'бір жыл',
            yy : '%d жыл'
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/,
        ordinal : function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return kk;

})));


/***/ }),

/***/ "6d83":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var arTn = moment.defineLocale('ar-tn', {
        months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'في %s',
            past: 'منذ %s',
            s: 'ثوان',
            ss : '%d ثانية',
            m: 'دقيقة',
            mm: '%d دقائق',
            h: 'ساعة',
            hh: '%d ساعات',
            d: 'يوم',
            dd: '%d أيام',
            M: 'شهر',
            MM: '%d أشهر',
            y: 'سنة',
            yy: '%d سنوات'
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return arTn;

})));


/***/ }),

/***/ "6dd8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* harmony default export */ __webpack_exports__["a"] = (index);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "6e98":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var it = moment.defineLocale('it', {
        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays : 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split('_'),
        weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
        weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : function (s) {
                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past : '%s fa',
            s : 'alcuni secondi',
            ss : '%d secondi',
            m : 'un minuto',
            mm : '%d minuti',
            h : 'un\'ora',
            hh : '%d ore',
            d : 'un giorno',
            dd : '%d giorni',
            M : 'un mese',
            MM : '%d mesi',
            y : 'un anno',
            yy : '%d anni'
        },
        dayOfMonthOrdinalParse : /\d{1,2}º/,
        ordinal: '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return it;

})));


/***/ }),

/***/ "6f12":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var itCh = moment.defineLocale('it-ch', {
        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays : 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split('_'),
        weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
        weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : function (s) {
                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past : '%s fa',
            s : 'alcuni secondi',
            ss : '%d secondi',
            m : 'un minuto',
            mm : '%d minuti',
            h : 'un\'ora',
            hh : '%d ore',
            d : 'un giorno',
            dd : '%d giorni',
            M : 'un mese',
            MM : '%d mesi',
            y : 'un anno',
            yy : '%d anni'
        },
        dayOfMonthOrdinalParse : /\d{1,2}º/,
        ordinal: '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return itCh;

})));


/***/ }),

/***/ "6f50":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var enNz = moment.defineLocale('en-nz', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enNz;

})));


/***/ }),

/***/ "6f6c":
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ "6fcd":
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__("50d8"),
    isArguments = __webpack_require__("d370"),
    isArray = __webpack_require__("6747"),
    isBuffer = __webpack_require__("0d24"),
    isIndex = __webpack_require__("c098"),
    isTypedArray = __webpack_require__("73ac");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "7037":
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "7118":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

    var fy = moment.defineLocale('fy', {
        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },
        monthsParseExact : true,
        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[hjoed om] LT',
            nextDay: '[moarn om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[juster om] LT',
            lastWeek: '[ôfrûne] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'oer %s',
            past : '%s lyn',
            s : 'in pear sekonden',
            ss : '%d sekonden',
            m : 'ien minút',
            mm : '%d minuten',
            h : 'ien oere',
            hh : '%d oeren',
            d : 'ien dei',
            dd : '%d dagen',
            M : 'ien moanne',
            MM : '%d moannen',
            y : 'ien jier',
            yy : '%d jierren'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fy;

})));


/***/ }),

/***/ "7244":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "72af":
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__("99cd");

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),

/***/ "72f0":
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),

/***/ "7333":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var enIl = moment.defineLocale('en-il', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    return enIl;

})));


/***/ }),

/***/ "73ac":
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__("743f"),
    baseUnary = __webpack_require__("b047f"),
    nodeUtil = __webpack_require__("99d3");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "743f":
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__("3729"),
    isLength = __webpack_require__("b218"),
    isObjectLike = __webpack_require__("1310");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "74dc":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var sw = moment.defineLocale('sw', {
        months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
        weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
        weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[leo saa] LT',
            nextDay : '[kesho saa] LT',
            nextWeek : '[wiki ijayo] dddd [saat] LT',
            lastDay : '[jana] LT',
            lastWeek : '[wiki iliyopita] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s baadaye',
            past : 'tokea %s',
            s : 'hivi punde',
            ss : 'sekunde %d',
            m : 'dakika moja',
            mm : 'dakika %d',
            h : 'saa limoja',
            hh : 'masaa %d',
            d : 'siku moja',
            dd : 'masiku %d',
            M : 'mwezi mmoja',
            MM : 'miezi %d',
            y : 'mwaka mmoja',
            yy : 'miaka %d'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return sw;

})));


/***/ }),

/***/ "750a":
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__("c869"),
    noop = __webpack_require__("bcdf"),
    setToArray = __webpack_require__("ac41");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;


/***/ }),

/***/ "7530":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("1a8c");

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ "76dd":
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__("ce86");

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ "78ce":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isIconDefinition; });
/* unused harmony export normalizeAttrs */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MiniMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return generate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return withSuffix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getSecondaryColor; });
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7037");
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ant_design_palettes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("20ba");
/* harmony import */ var ant_design_palettes__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ant_design_palettes__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("8827");
/* harmony import */ var babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("57ba");
/* harmony import */ var babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("41b2");
/* harmony import */ var babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_5__);






function log(message) {
  if (!(process && Object({"NODE_ENV":"production","BASE_URL":"/"}) && "production" === 'production')) {
    console.error('[@ant-design/icons-vue]: ' + message + '.');
  }
}
function isIconDefinition(target) {
  return _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(target) === 'object' && typeof target.name === 'string' && typeof target.theme === 'string' && (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(target.icon) === 'object' || typeof target.icon === 'function');
}
function normalizeAttrs() {
  var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return Object.keys(attrs).reduce(function (acc, key) {
    var val = attrs[key];

    switch (key) {
      case 'class':
        acc.className = val;
        delete acc['class'];
        break;

      default:
        acc[key] = val;
    }

    return acc;
  }, {});
}
var MiniMap = function () {
  function MiniMap() {
    babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2___default()(this, MiniMap);

    this.collection = {};
  }

  babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3___default()(MiniMap, [{
    key: 'clear',
    value: function clear() {
      this.collection = {};
    }
  }, {
    key: 'delete',
    value: function _delete(key) {
      return delete this.collection[key];
    }
  }, {
    key: 'get',
    value: function get(key) {
      return this.collection[key];
    }
  }, {
    key: 'has',
    value: function has(key) {
      return Boolean(this.collection[key]);
    }
  }, {
    key: 'set',
    value: function set(key, value) {
      this.collection[key] = value;
      return this;
    }
  }, {
    key: 'size',
    get: function get() {
      return Object.keys(this.collection).length;
    }
  }]);

  return MiniMap;
}();
function generate(node, key, rootProps) {
  if (!rootProps) {
    return Object(vue__WEBPACK_IMPORTED_MODULE_5__["h"])(node.tag, Object.assign({
      key: key
    }, babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_4___default()({}, normalizeAttrs(node.attrs))), (node.children || []).map(function (child, index) {
      return generate(child, key + '-' + node.tag + '-' + index);
    }));
  }

  var attrs = babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_4___default()({
    key: key
  }, rootProps, babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_4___default()({}, normalizeAttrs(node.attrs), rootProps.attrs));

  return Object(vue__WEBPACK_IMPORTED_MODULE_5__["h"])(node.tag, attrs, (node.children || []).map(function (child, index) {
    return generate(child, key + '-' + node.tag + '-' + index);
  }));
}
function withSuffix(name, theme) {
  switch (theme) {
    case 'fill':
      return name + '-fill';

    case 'outline':
      return name + '-o';

    case 'twotone':
      return name + '-twotone';

    default:
      throw new TypeError('Unknown theme type: ' + theme + ', name: ' + name);
  }
}
function getSecondaryColor(primaryColor) {
  // choose the second color
  return Object(ant_design_palettes__WEBPACK_IMPORTED_MODULE_1__["generate"])(primaryColor)[0];
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("4362")))

/***/ }),

/***/ "7948":
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ "794b":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("8e60") && !__webpack_require__("294c")(function () {
  return Object.defineProperty(__webpack_require__("1ec9")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "79aa":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "79bc":
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__("0b07"),
    root = __webpack_require__("2b3e");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "7a48":
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__("6044");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "7b83":
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__("7c64"),
    mapCacheDelete = __webpack_require__("93ed"),
    mapCacheGet = __webpack_require__("2478"),
    mapCacheHas = __webpack_require__("a524"),
    mapCacheSet = __webpack_require__("1fc8");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "7b97":
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__("7e64"),
    equalArrays = __webpack_require__("a2be"),
    equalByTag = __webpack_require__("1c3c"),
    equalObjects = __webpack_require__("b1e5"),
    getTag = __webpack_require__("42a2"),
    isArray = __webpack_require__("6747"),
    isBuffer = __webpack_require__("0d24"),
    isTypedArray = __webpack_require__("73ac");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ "7be6":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var months = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split('_'),
        monthsShort = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');
    function plural(n) {
        return (n > 1) && (n < 5);
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':  // a few seconds / in a few seconds / a few seconds ago
                return (withoutSuffix || isFuture) ? 'pár sekúnd' : 'pár sekundami';
            case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'sekundy' : 'sekúnd');
                } else {
                    return result + 'sekundami';
                }
                break;
            case 'm':  // a minute / in a minute / a minute ago
                return withoutSuffix ? 'minúta' : (isFuture ? 'minútu' : 'minútou');
            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'minúty' : 'minút');
                } else {
                    return result + 'minútami';
                }
                break;
            case 'h':  // an hour / in an hour / an hour ago
                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
            case 'hh': // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'hodiny' : 'hodín');
                } else {
                    return result + 'hodinami';
                }
                break;
            case 'd':  // a day / in a day / a day ago
                return (withoutSuffix || isFuture) ? 'deň' : 'dňom';
            case 'dd': // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'dni' : 'dní');
                } else {
                    return result + 'dňami';
                }
                break;
            case 'M':  // a month / in a month / a month ago
                return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
            case 'MM': // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'mesiace' : 'mesiacov');
                } else {
                    return result + 'mesiacmi';
                }
                break;
            case 'y':  // a year / in a year / a year ago
                return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
            case 'yy': // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'roky' : 'rokov');
                } else {
                    return result + 'rokmi';
                }
                break;
        }
    }

    var sk = moment.defineLocale('sk', {
        months : months,
        monthsShort : monthsShort,
        weekdays : 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
        weekdaysShort : 'ne_po_ut_st_št_pi_so'.split('_'),
        weekdaysMin : 'ne_po_ut_st_št_pi_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[dnes o] LT',
            nextDay: '[zajtra o] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[v nedeľu o] LT';
                    case 1:
                    case 2:
                        return '[v] dddd [o] LT';
                    case 3:
                        return '[v stredu o] LT';
                    case 4:
                        return '[vo štvrtok o] LT';
                    case 5:
                        return '[v piatok o] LT';
                    case 6:
                        return '[v sobotu o] LT';
                }
            },
            lastDay: '[včera o] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[minulú nedeľu o] LT';
                    case 1:
                    case 2:
                        return '[minulý] dddd [o] LT';
                    case 3:
                        return '[minulú stredu o] LT';
                    case 4:
                    case 5:
                        return '[minulý] dddd [o] LT';
                    case 6:
                        return '[minulú sobotu o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'pred %s',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sk;

})));


/***/ }),

/***/ "7c64":
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__("e24b"),
    ListCache = __webpack_require__("5e2e"),
    Map = __webpack_require__("79bc");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "7d1f":
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__("087d"),
    isArray = __webpack_require__("6747");

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ "7e64":
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__("5e2e"),
    stackClear = __webpack_require__("efb6"),
    stackDelete = __webpack_require__("2fcc"),
    stackGet = __webpack_require__("802a"),
    stackHas = __webpack_require__("55a3"),
    stackSet = __webpack_require__("d02c");

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ "7ed2":
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ "7f33":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var yo = moment.defineLocale('yo', {
        months : 'Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀'.split('_'),
        monthsShort : 'Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀'.split('_'),
        weekdays : 'Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta'.split('_'),
        weekdaysShort : 'Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá'.split('_'),
        weekdaysMin : 'Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Ònì ni] LT',
            nextDay : '[Ọ̀la ni] LT',
            nextWeek : 'dddd [Ọsẹ̀ tón\'bọ] [ni] LT',
            lastDay : '[Àna ni] LT',
            lastWeek : 'dddd [Ọsẹ̀ tólọ́] [ni] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ní %s',
            past : '%s kọjá',
            s : 'ìsẹjú aayá die',
            ss :'aayá %d',
            m : 'ìsẹjú kan',
            mm : 'ìsẹjú %d',
            h : 'wákati kan',
            hh : 'wákati %d',
            d : 'ọjọ́ kan',
            dd : 'ọjọ́ %d',
            M : 'osù kan',
            MM : 'osù %d',
            y : 'ọdún kan',
            yy : 'ọdún %d'
        },
        dayOfMonthOrdinalParse : /ọjọ́\s\d{1,2}/,
        ordinal : 'ọjọ́ %d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return yo;

})));


/***/ }),

/***/ "802a":
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ "8057":
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ "8155":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
            case 'ss':
                if (number === 1) {
                    result += withoutSuffix ? 'sekundo' : 'sekundi';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';
                } else {
                    result += 'sekund';
                }
                return result;
            case 'm':
                return withoutSuffix ? 'ena minuta' : 'eno minuto';
            case 'mm':
                if (number === 1) {
                    result += withoutSuffix ? 'minuta' : 'minuto';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'minute' : 'minutami';
                } else {
                    result += withoutSuffix || isFuture ? 'minut' : 'minutami';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'ena ura' : 'eno uro';
            case 'hh':
                if (number === 1) {
                    result += withoutSuffix ? 'ura' : 'uro';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'uri' : 'urama';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'ure' : 'urami';
                } else {
                    result += withoutSuffix || isFuture ? 'ur' : 'urami';
                }
                return result;
            case 'd':
                return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
            case 'dd':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'dan' : 'dnem';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
                } else {
                    result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
                }
                return result;
            case 'M':
                return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
            case 'MM':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
                } else {
                    result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
                }
                return result;
            case 'y':
                return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
            case 'yy':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'leto' : 'letom';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'leti' : 'letoma';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'leta' : 'leti';
                } else {
                    result += withoutSuffix || isFuture ? 'let' : 'leti';
                }
                return result;
        }
    }

    var sl = moment.defineLocale('sl', {
        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
        weekdaysShort : 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
        weekdaysMin : 'ne_po_to_sr_če_pe_so'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danes ob] LT',
            nextDay  : '[jutri ob] LT',

            nextWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[v] [nedeljo] [ob] LT';
                    case 3:
                        return '[v] [sredo] [ob] LT';
                    case 6:
                        return '[v] [soboto] [ob] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[v] dddd [ob] LT';
                }
            },
            lastDay  : '[včeraj ob] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[prejšnjo] [nedeljo] [ob] LT';
                    case 3:
                        return '[prejšnjo] [sredo] [ob] LT';
                    case 6:
                        return '[prejšnjo] [soboto] [ob] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[prejšnji] dddd [ob] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'čez %s',
            past   : 'pred %s',
            s      : processRelativeTime,
            ss     : processRelativeTime,
            m      : processRelativeTime,
            mm     : processRelativeTime,
            h      : processRelativeTime,
            hh     : processRelativeTime,
            d      : processRelativeTime,
            dd     : processRelativeTime,
            M      : processRelativeTime,
            MM     : processRelativeTime,
            y      : processRelativeTime,
            yy     : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return sl;

})));


/***/ }),

/***/ "81e9":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(' '),
        numbersFuture = [
            'nolla', 'yhden', 'kahden', 'kolmen', 'neljän', 'viiden', 'kuuden',
            numbersPast[7], numbersPast[8], numbersPast[9]
        ];
    function translate(number, withoutSuffix, key, isFuture) {
        var result = '';
        switch (key) {
            case 's':
                return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
            case 'ss':
                return isFuture ? 'sekunnin' : 'sekuntia';
            case 'm':
                return isFuture ? 'minuutin' : 'minuutti';
            case 'mm':
                result = isFuture ? 'minuutin' : 'minuuttia';
                break;
            case 'h':
                return isFuture ? 'tunnin' : 'tunti';
            case 'hh':
                result = isFuture ? 'tunnin' : 'tuntia';
                break;
            case 'd':
                return isFuture ? 'päivän' : 'päivä';
            case 'dd':
                result = isFuture ? 'päivän' : 'päivää';
                break;
            case 'M':
                return isFuture ? 'kuukauden' : 'kuukausi';
            case 'MM':
                result = isFuture ? 'kuukauden' : 'kuukautta';
                break;
            case 'y':
                return isFuture ? 'vuoden' : 'vuosi';
            case 'yy':
                result = isFuture ? 'vuoden' : 'vuotta';
                break;
        }
        result = verbalNumber(number, isFuture) + ' ' + result;
        return result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
    }

    var fi = moment.defineLocale('fi', {
        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
        monthsShort : 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'Do MMMM[ta] YYYY',
            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
            l : 'D.M.YYYY',
            ll : 'Do MMM YYYY',
            lll : 'Do MMM YYYY, [klo] HH.mm',
            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
        },
        calendar : {
            sameDay : '[tänään] [klo] LT',
            nextDay : '[huomenna] [klo] LT',
            nextWeek : 'dddd [klo] LT',
            lastDay : '[eilen] [klo] LT',
            lastWeek : '[viime] dddd[na] [klo] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s päästä',
            past : '%s sitten',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fi;

})));


/***/ }),

/***/ "8230":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '١',
        '2': '٢',
        '3': '٣',
        '4': '٤',
        '5': '٥',
        '6': '٦',
        '7': '٧',
        '8': '٨',
        '9': '٩',
        '0': '٠'
    }, numberMap = {
        '١': '1',
        '٢': '2',
        '٣': '3',
        '٤': '4',
        '٥': '5',
        '٦': '6',
        '٧': '7',
        '٨': '8',
        '٩': '9',
        '٠': '0'
    };

    var arSa = moment.defineLocale('ar-sa', {
        months : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        monthsShort : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /ص|م/,
        isPM : function (input) {
            return 'م' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar : {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'في %s',
            past : 'منذ %s',
            s : 'ثوان',
            ss : '%d ثانية',
            m : 'دقيقة',
            mm : '%d دقائق',
            h : 'ساعة',
            hh : '%d ساعات',
            d : 'يوم',
            dd : '%d أيام',
            M : 'شهر',
            MM : '%d أشهر',
            y : 'سنة',
            yy : '%d سنوات'
        },
        preparse: function (string) {
            return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                return numberMap[match];
            }).replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '،');
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return arSa;

})));


/***/ }),

/***/ "8296":
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__("656b"),
    baseSlice = __webpack_require__("2b10");

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;


/***/ }),

/***/ "84aa":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var bg = moment.defineLocale('bg', {
        months : 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split('_'),
        monthsShort : 'янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
        weekdays : 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split('_'),
        weekdaysShort : 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : '[Днес в] LT',
            nextDay : '[Утре в] LT',
            nextWeek : 'dddd [в] LT',
            lastDay : '[Вчера в] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 6:
                        return '[В изминалата] dddd [в] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[В изминалия] dddd [в] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'след %s',
            past : 'преди %s',
            s : 'няколко секунди',
            ss : '%d секунди',
            m : 'минута',
            mm : '%d минути',
            h : 'час',
            hh : '%d часа',
            d : 'ден',
            dd : '%d дни',
            M : 'месец',
            MM : '%d месеца',
            y : 'година',
            yy : '%d години'
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-ев';
            } else if (last2Digits === 0) {
                return number + '-ен';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-ти';
            } else if (lastDigit === 1) {
                return number + '-ви';
            } else if (lastDigit === 2) {
                return number + '-ри';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-ми';
            } else {
                return number + '-ти';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return bg;

})));


/***/ }),

/***/ "85e3":
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),

/***/ "8604":
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__("26e8"),
    hasPath = __webpack_require__("e2c0");

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),

/***/ "8689":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '၁',
        '2': '၂',
        '3': '၃',
        '4': '၄',
        '5': '၅',
        '6': '၆',
        '7': '၇',
        '8': '၈',
        '9': '၉',
        '0': '၀'
    }, numberMap = {
        '၁': '1',
        '၂': '2',
        '၃': '3',
        '၄': '4',
        '၅': '5',
        '၆': '6',
        '၇': '7',
        '၈': '8',
        '၉': '9',
        '၀': '0'
    };

    var my = moment.defineLocale('my', {
        months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split('_'),
        monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
        weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split('_'),
        weekdaysShort: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
        weekdaysMin: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),

        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[ယနေ.] LT [မှာ]',
            nextDay: '[မနက်ဖြန်] LT [မှာ]',
            nextWeek: 'dddd LT [မှာ]',
            lastDay: '[မနေ.က] LT [မှာ]',
            lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'လာမည့် %s မှာ',
            past: 'လွန်ခဲ့သော %s က',
            s: 'စက္ကန်.အနည်းငယ်',
            ss : '%d စက္ကန့်',
            m: 'တစ်မိနစ်',
            mm: '%d မိနစ်',
            h: 'တစ်နာရီ',
            hh: '%d နာရီ',
            d: 'တစ်ရက်',
            dd: '%d ရက်',
            M: 'တစ်လ',
            MM: '%d လ',
            y: 'တစ်နှစ်',
            yy: '%d နှစ်'
        },
        preparse: function (string) {
            return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return my;

})));


/***/ }),

/***/ "872a":
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__("3b4a");

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ "8827":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),

/***/ "8840":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var gl = moment.defineLocale('gl', {
        months : 'xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
        monthsShort : 'xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'domingo_luns_martes_mércores_xoves_venres_sábado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mér._xov._ven._sáb.'.split('_'),
        weekdaysMin : 'do_lu_ma_mé_xo_ve_sá'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY H:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[hoxe ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
            },
            nextDay : function () {
                return '[mañá ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
            },
            lastDay : function () {
                return '[onte ' + ((this.hours() !== 1) ? 'á' : 'a') + '] LT';
            },
            lastWeek : function () {
                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : function (str) {
                if (str.indexOf('un') === 0) {
                    return 'n' + str;
                }
                return 'en ' + str;
            },
            past : 'hai %s',
            s : 'uns segundos',
            ss : '%d segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'unha hora',
            hh : '%d horas',
            d : 'un día',
            dd : '%d días',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ano',
            yy : '%d anos'
        },
        dayOfMonthOrdinalParse : /\d{1,2}º/,
        ordinal : '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return gl;

})));


/***/ }),

/***/ "8875":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// addapted from the document.currentScript polyfill by Adam Miller
// MIT license
// source: https://github.com/amiller-gh/currentScript-polyfill

// added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505

(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(typeof self !== 'undefined' ? self : this, function () {
  function getCurrentScript () {
    if (document.currentScript) {
      return document.currentScript
    }
  
    // IE 8-10 support script readyState
    // IE 11+ & Firefox support stack trace
    try {
      throw new Error();
    }
    catch (err) {
      // Find the second match for the "at" string to get file src url from stack.
      var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig,
        ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig,
        stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack),
        scriptLocation = (stackDetails && stackDetails[1]) || false,
        line = (stackDetails && stackDetails[2]) || false,
        currentLocation = document.location.href.replace(document.location.hash, ''),
        pageSource,
        inlineScriptSourceRegExp,
        inlineScriptSource,
        scripts = document.getElementsByTagName('script'); // Live NodeList collection
  
      if (scriptLocation === currentLocation) {
        pageSource = document.documentElement.outerHTML;
        inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
        inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
      }
  
      for (var i = 0; i < scripts.length; i++) {
        // If ready state is interactive, return the script tag
        if (scripts[i].readyState === 'interactive') {
          return scripts[i];
        }
  
        // If src matches, return the script tag
        if (scripts[i].src === scriptLocation) {
          return scripts[i];
        }
  
        // If inline source matches, return the script tag
        if (
          scriptLocation === currentLocation &&
          scripts[i].innerHTML &&
          scripts[i].innerHTML.trim() === inlineScriptSource
        ) {
          return scripts[i];
        }
      }
  
      // If no match, return null
      return null;
    }
  };

  return getCurrentScript
}));


/***/ }),

/***/ "898b":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
    var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var es = moment.defineLocale('es', {
        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex : monthsRegex,
        monthsShortRegex : monthsRegex,
        monthsStrictRegex : /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex : /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,
        weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY H:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            ss : '%d segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un día',
            dd : '%d días',
            M : 'un mes',
            MM : '%d meses',
            y : 'un año',
            yy : '%d años'
        },
        dayOfMonthOrdinalParse : /\d{1,2}º/,
        ordinal : '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return es;

})));


/***/ }),

/***/ "89d9":
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__("656b"),
    baseSet = __webpack_require__("159a"),
    castPath = __webpack_require__("e2e4");

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),

/***/ "8bbf":
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__8bbf__;

/***/ }),

/***/ "8d47":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }


    var el = moment.defineLocale('el', {
        monthsNominativeEl : 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split('_'),
        monthsGenitiveEl : 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split('_'),
        months : function (momentToFormat, format) {
            if (!momentToFormat) {
                return this._monthsNominativeEl;
            } else if (typeof format === 'string' && /D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
                return this._monthsGenitiveEl[momentToFormat.month()];
            } else {
                return this._monthsNominativeEl[momentToFormat.month()];
            }
        },
        monthsShort : 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
        weekdays : 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
        weekdaysShort : 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
        weekdaysMin : 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'μμ' : 'ΜΜ';
            } else {
                return isLower ? 'πμ' : 'ΠΜ';
            }
        },
        isPM : function (input) {
            return ((input + '').toLowerCase()[0] === 'μ');
        },
        meridiemParse : /[ΠΜ]\.?Μ?\.?/i,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendarEl : {
            sameDay : '[Σήμερα {}] LT',
            nextDay : '[Αύριο {}] LT',
            nextWeek : 'dddd [{}] LT',
            lastDay : '[Χθες {}] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 6:
                        return '[το προηγούμενο] dddd [{}] LT';
                    default:
                        return '[την προηγούμενη] dddd [{}] LT';
                }
            },
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendarEl[key],
                hours = mom && mom.hours();
            if (isFunction(output)) {
                output = output.apply(mom);
            }
            return output.replace('{}', (hours % 12 === 1 ? 'στη' : 'στις'));
        },
        relativeTime : {
            future : 'σε %s',
            past : '%s πριν',
            s : 'λίγα δευτερόλεπτα',
            ss : '%d δευτερόλεπτα',
            m : 'ένα λεπτό',
            mm : '%d λεπτά',
            h : 'μία ώρα',
            hh : '%d ώρες',
            d : 'μία μέρα',
            dd : '%d μέρες',
            M : 'ένας μήνας',
            MM : '%d μήνες',
            y : 'ένας χρόνος',
            yy : '%d χρόνια'
        },
        dayOfMonthOrdinalParse: /\d{1,2}η/,
        ordinal: '%dη',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4st is the first week of the year.
        }
    });

    return el;

})));


/***/ }),

/***/ "8d57":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_'),
        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_');
    function plural(n) {
        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
    }
    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                return result + (plural(number) ? 'sekundy' : 'sekund');
            case 'm':
                return withoutSuffix ? 'minuta' : 'minutę';
            case 'mm':
                return result + (plural(number) ? 'minuty' : 'minut');
            case 'h':
                return withoutSuffix  ? 'godzina'  : 'godzinę';
            case 'hh':
                return result + (plural(number) ? 'godziny' : 'godzin');
            case 'MM':
                return result + (plural(number) ? 'miesiące' : 'miesięcy');
            case 'yy':
                return result + (plural(number) ? 'lata' : 'lat');
        }
    }

    var pl = moment.defineLocale('pl', {
        months : function (momentToFormat, format) {
            if (!momentToFormat) {
                return monthsNominative;
            } else if (format === '') {
                // Hack: if format empty we know this is used to generate
                // RegExp by moment. Give then back both valid forms of months
                // in RegExp ready format.
                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
            } else if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
        weekdays : 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
        weekdaysShort : 'ndz_pon_wt_śr_czw_pt_sob'.split('_'),
        weekdaysMin : 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Dziś o] LT',
            nextDay: '[Jutro o] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[W niedzielę o] LT';

                    case 2:
                        return '[We wtorek o] LT';

                    case 3:
                        return '[W środę o] LT';

                    case 6:
                        return '[W sobotę o] LT';

                    default:
                        return '[W] dddd [o] LT';
                }
            },
            lastDay: '[Wczoraj o] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[W zeszłą niedzielę o] LT';
                    case 3:
                        return '[W zeszłą środę o] LT';
                    case 6:
                        return '[W zeszłą sobotę o] LT';
                    default:
                        return '[W zeszły] dddd [o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : '%s temu',
            s : 'kilka sekund',
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : '1 dzień',
            dd : '%d dni',
            M : 'miesiąc',
            MM : translate,
            y : 'rok',
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return pl;

})));


/***/ }),

/***/ "8db3":
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf = __webpack_require__("47f5");

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;


/***/ }),

/***/ "8df4":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '۱',
        '2': '۲',
        '3': '۳',
        '4': '۴',
        '5': '۵',
        '6': '۶',
        '7': '۷',
        '8': '۸',
        '9': '۹',
        '0': '۰'
    }, numberMap = {
        '۱': '1',
        '۲': '2',
        '۳': '3',
        '۴': '4',
        '۵': '5',
        '۶': '6',
        '۷': '7',
        '۸': '8',
        '۹': '9',
        '۰': '0'
    };

    var fa = moment.defineLocale('fa', {
        months : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
        monthsShort : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
        weekdays : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
        weekdaysShort : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
        weekdaysMin : 'ی_د_س_چ_پ_ج_ش'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        meridiemParse: /قبل از ظهر|بعد از ظهر/,
        isPM: function (input) {
            return /بعد از ظهر/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'قبل از ظهر';
            } else {
                return 'بعد از ظهر';
            }
        },
        calendar : {
            sameDay : '[امروز ساعت] LT',
            nextDay : '[فردا ساعت] LT',
            nextWeek : 'dddd [ساعت] LT',
            lastDay : '[دیروز ساعت] LT',
            lastWeek : 'dddd [پیش] [ساعت] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'در %s',
            past : '%s پیش',
            s : 'چند ثانیه',
            ss : 'ثانیه d%',
            m : 'یک دقیقه',
            mm : '%d دقیقه',
            h : 'یک ساعت',
            hh : '%d ساعت',
            d : 'یک روز',
            dd : '%d روز',
            M : 'یک ماه',
            MM : '%d ماه',
            y : 'یک سال',
            yy : '%d سال'
        },
        preparse: function (string) {
            return string.replace(/[۰-۹]/g, function (match) {
                return numberMap[match];
            }).replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '،');
        },
        dayOfMonthOrdinalParse: /\d{1,2}م/,
        ordinal : '%dم',
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12 // The week that contains Jan 12th is the first week of the year.
        }
    });

    return fa;

})));


/***/ }),

/***/ "8df8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = isMobile
module.exports.isMobile = isMobile
module.exports.default = isMobile

var mobileRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i

var tabletRE = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino|android|ipad|playbook|silk/i

function isMobile (opts) {
  if (!opts) opts = {}
  var ua = opts.ua
  if (!ua && typeof navigator !== 'undefined') ua = navigator.userAgent
  if (ua && ua.headers && typeof ua.headers['user-agent'] === 'string') {
    ua = ua.headers['user-agent']
  }
  if (typeof ua !== 'string') return false

  var result = opts.tablet ? tabletRE.test(ua) : mobileRE.test(ua)

  if (
    !result &&
    opts.tablet &&
    opts.featureDetect &&
    navigator &&
    navigator.maxTouchPoints > 1 &&
    ua.indexOf('Macintosh') !== -1 &&
    ua.indexOf('Safari') !== -1
  ) {
    result = true
  }

  return result
}


/***/ }),

/***/ "8e60":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("294c")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "8e73":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '١',
        '2': '٢',
        '3': '٣',
        '4': '٤',
        '5': '٥',
        '6': '٦',
        '7': '٧',
        '8': '٨',
        '9': '٩',
        '0': '٠'
    }, numberMap = {
        '١': '1',
        '٢': '2',
        '٣': '3',
        '٤': '4',
        '٥': '5',
        '٦': '6',
        '٧': '7',
        '٨': '8',
        '٩': '9',
        '٠': '0'
    }, pluralForm = function (n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
        m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
        h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
        d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
        M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
        y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
    }, pluralize = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, months = [
        'يناير',
        'فبراير',
        'مارس',
        'أبريل',
        'مايو',
        'يونيو',
        'يوليو',
        'أغسطس',
        'سبتمبر',
        'أكتوبر',
        'نوفمبر',
        'ديسمبر'
    ];

    var ar = moment.defineLocale('ar', {
        months : months,
        monthsShort : months,
        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/\u200FM/\u200FYYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /ص|م/,
        isPM : function (input) {
            return 'م' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar : {
            sameDay: '[اليوم عند الساعة] LT',
            nextDay: '[غدًا عند الساعة] LT',
            nextWeek: 'dddd [عند الساعة] LT',
            lastDay: '[أمس عند الساعة] LT',
            lastWeek: 'dddd [عند الساعة] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'بعد %s',
            past : 'منذ %s',
            s : pluralize('s'),
            ss : pluralize('s'),
            m : pluralize('m'),
            mm : pluralize('m'),
            h : pluralize('h'),
            hh : pluralize('h'),
            d : pluralize('d'),
            dd : pluralize('d'),
            M : pluralize('M'),
            MM : pluralize('M'),
            y : pluralize('y'),
            yy : pluralize('y')
        },
        preparse: function (string) {
            return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                return numberMap[match];
            }).replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '،');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return ar;

})));


/***/ }),

/***/ "8eeb":
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__("32b3"),
    baseAssignValue = __webpack_require__("872a");

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ "9043":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '১',
        '2': '২',
        '3': '৩',
        '4': '৪',
        '5': '৫',
        '6': '৬',
        '7': '৭',
        '8': '৮',
        '9': '৯',
        '0': '০'
    },
    numberMap = {
        '১': '1',
        '২': '2',
        '৩': '3',
        '৪': '4',
        '৫': '5',
        '৬': '6',
        '৭': '7',
        '৮': '8',
        '৯': '9',
        '০': '0'
    };

    var bn = moment.defineLocale('bn', {
        months : 'জানুয়ারী_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split('_'),
        monthsShort : 'জানু_ফেব_মার্চ_এপ্র_মে_জুন_জুল_আগ_সেপ্ট_অক্টো_নভে_ডিসে'.split('_'),
        weekdays : 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার'.split('_'),
        weekdaysShort : 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি'.split('_'),
        weekdaysMin : 'রবি_সোম_মঙ্গ_বুধ_বৃহঃ_শুক্র_শনি'.split('_'),
        longDateFormat : {
            LT : 'A h:mm সময়',
            LTS : 'A h:mm:ss সময়',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm সময়',
            LLLL : 'dddd, D MMMM YYYY, A h:mm সময়'
        },
        calendar : {
            sameDay : '[আজ] LT',
            nextDay : '[আগামীকাল] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[গতকাল] LT',
            lastWeek : '[গত] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s পরে',
            past : '%s আগে',
            s : 'কয়েক সেকেন্ড',
            ss : '%d সেকেন্ড',
            m : 'এক মিনিট',
            mm : '%d মিনিট',
            h : 'এক ঘন্টা',
            hh : '%d ঘন্টা',
            d : 'এক দিন',
            dd : '%d দিন',
            M : 'এক মাস',
            MM : '%d মাস',
            y : 'এক বছর',
            yy : '%d বছর'
        },
        preparse: function (string) {
            return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === 'রাত' && hour >= 4) ||
                    (meridiem === 'দুপুর' && hour < 5) ||
                    meridiem === 'বিকাল') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'রাত';
            } else if (hour < 10) {
                return 'সকাল';
            } else if (hour < 17) {
                return 'দুপুর';
            } else if (hour < 20) {
                return 'বিকাল';
            } else {
                return 'রাত';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return bn;

})));


/***/ }),

/***/ "90ea":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var zhTw = moment.defineLocale('zh-tw', {
        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYY年M月D日',
            LLL : 'YYYY年M月D日 HH:mm',
            LLLL : 'YYYY年M月D日dddd HH:mm',
            l : 'YYYY/M/D',
            ll : 'YYYY年M月D日',
            lll : 'YYYY年M月D日 HH:mm',
            llll : 'YYYY年M月D日dddd HH:mm'
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                return hour;
            } else if (meridiem === '中午') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1130) {
                return '上午';
            } else if (hm < 1230) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar : {
            sameDay : '[今天] LT',
            nextDay : '[明天] LT',
            nextWeek : '[下]dddd LT',
            lastDay : '[昨天] LT',
            lastWeek : '[上]dddd LT',
            sameElse : 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd' :
                case 'D' :
                case 'DDD' :
                    return number + '日';
                case 'M' :
                    return number + '月';
                case 'w' :
                case 'W' :
                    return number + '週';
                default :
                    return number;
            }
        },
        relativeTime : {
            future : '%s內',
            past : '%s前',
            s : '幾秒',
            ss : '%d 秒',
            m : '1 分鐘',
            mm : '%d 分鐘',
            h : '1 小時',
            hh : '%d 小時',
            d : '1 天',
            dd : '%d 天',
            M : '1 個月',
            MM : '%d 個月',
            y : '1 年',
            yy : '%d 年'
        }
    });

    return zhTw;

})));


/***/ }),

/***/ "91e9":
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "9306":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__("8e60");
var getKeys = __webpack_require__("c3a1");
var gOPS = __webpack_require__("9aa9");
var pIE = __webpack_require__("355d");
var toObject = __webpack_require__("241e");
var IObject = __webpack_require__("335c");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__("294c")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "93ed":
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__("4245");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "950a":
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__("30c9");

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),

/***/ "9520":
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__("3729"),
    isObject = __webpack_require__("1a8c");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "9523":
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "957c":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'ss': withoutSuffix ? 'секунда_секунды_секунд' : 'секунду_секунды_секунд',
            'mm': withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
            'hh': 'час_часа_часов',
            'dd': 'день_дня_дней',
            'MM': 'месяц_месяца_месяцев',
            'yy': 'год_года_лет'
        };
        if (key === 'm') {
            return withoutSuffix ? 'минута' : 'минуту';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    var monthsParse = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i];

    // http://new.gramota.ru/spravka/rules/139-prop : § 103
    // Сокращения месяцев: http://new.gramota.ru/spravka/buro/search-answer?s=242637
    // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
    var ru = moment.defineLocale('ru', {
        months : {
            format: 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split('_'),
            standalone: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_')
        },
        monthsShort : {
            // по CLDR именно "июл." и "июн.", но какой смысл менять букву на точку ?
            format: 'янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.'.split('_'),
            standalone: 'янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.'.split('_')
        },
        weekdays : {
            standalone: 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split('_'),
            format: 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split('_'),
            isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/
        },
        weekdaysShort : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
        weekdaysMin : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,

        // полные названия с падежами, по три буквы, для некоторых, по 4 буквы, сокращения с точкой и без точки
        monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

        // копия предыдущего
        monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

        // полные названия с падежами
        monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,

        // Выражение, которое соотвествует только сокращённым формам
        monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY г.',
            LLL : 'D MMMM YYYY г., H:mm',
            LLLL : 'dddd, D MMMM YYYY г., H:mm'
        },
        calendar : {
            sameDay: '[Сегодня, в] LT',
            nextDay: '[Завтра, в] LT',
            lastDay: '[Вчера, в] LT',
            nextWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                        case 0:
                            return '[В следующее] dddd, [в] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[В следующий] dddd, [в] LT';
                        case 3:
                        case 5:
                        case 6:
                            return '[В следующую] dddd, [в] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[Во] dddd, [в] LT';
                    } else {
                        return '[В] dddd, [в] LT';
                    }
                }
            },
            lastWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                        case 0:
                            return '[В прошлое] dddd, [в] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[В прошлый] dddd, [в] LT';
                        case 3:
                        case 5:
                        case 6:
                            return '[В прошлую] dddd, [в] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[Во] dddd, [в] LT';
                    } else {
                        return '[В] dddd, [в] LT';
                    }
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'через %s',
            past : '%s назад',
            s : 'несколько секунд',
            ss : relativeTimeWithPlural,
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : 'час',
            hh : relativeTimeWithPlural,
            d : 'день',
            dd : relativeTimeWithPlural,
            M : 'месяц',
            MM : relativeTimeWithPlural,
            y : 'год',
            yy : relativeTimeWithPlural
        },
        meridiemParse: /ночи|утра|дня|вечера/i,
        isPM : function (input) {
            return /^(дня|вечера)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ночи';
            } else if (hour < 12) {
                return 'утра';
            } else if (hour < 17) {
                return 'дня';
            } else {
                return 'вечера';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                    return number + '-й';
                case 'D':
                    return number + '-го';
                case 'w':
                case 'W':
                    return number + '-я';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ru;

})));


/***/ }),

/***/ "958b":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function translate(number, withoutSuffix, key, isFuture) {
        switch (key) {
            case 's':
                return withoutSuffix ? 'хэдхэн секунд' : 'хэдхэн секундын';
            case 'ss':
                return number + (withoutSuffix ? ' секунд' : ' секундын');
            case 'm':
            case 'mm':
                return number + (withoutSuffix ? ' минут' : ' минутын');
            case 'h':
            case 'hh':
                return number + (withoutSuffix ? ' цаг' : ' цагийн');
            case 'd':
            case 'dd':
                return number + (withoutSuffix ? ' өдөр' : ' өдрийн');
            case 'M':
            case 'MM':
                return number + (withoutSuffix ? ' сар' : ' сарын');
            case 'y':
            case 'yy':
                return number + (withoutSuffix ? ' жил' : ' жилийн');
            default:
                return number;
        }
    }

    var mn = moment.defineLocale('mn', {
        months : 'Нэгдүгээр сар_Хоёрдугаар сар_Гуравдугаар сар_Дөрөвдүгээр сар_Тавдугаар сар_Зургадугаар сар_Долдугаар сар_Наймдугаар сар_Есдүгээр сар_Аравдугаар сар_Арван нэгдүгээр сар_Арван хоёрдугаар сар'.split('_'),
        monthsShort : '1 сар_2 сар_3 сар_4 сар_5 сар_6 сар_7 сар_8 сар_9 сар_10 сар_11 сар_12 сар'.split('_'),
        monthsParseExact : true,
        weekdays : 'Ням_Даваа_Мягмар_Лхагва_Пүрэв_Баасан_Бямба'.split('_'),
        weekdaysShort : 'Ням_Дав_Мяг_Лха_Пүр_Баа_Бям'.split('_'),
        weekdaysMin : 'Ня_Да_Мя_Лх_Пү_Ба_Бя'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY оны MMMMын D',
            LLL : 'YYYY оны MMMMын D HH:mm',
            LLLL : 'dddd, YYYY оны MMMMын D HH:mm'
        },
        meridiemParse: /ҮӨ|ҮХ/i,
        isPM : function (input) {
            return input === 'ҮХ';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ҮӨ';
            } else {
                return 'ҮХ';
            }
        },
        calendar : {
            sameDay : '[Өнөөдөр] LT',
            nextDay : '[Маргааш] LT',
            nextWeek : '[Ирэх] dddd LT',
            lastDay : '[Өчигдөр] LT',
            lastWeek : '[Өнгөрсөн] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s дараа',
            past : '%s өмнө',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2} өдөр/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + ' өдөр';
                default:
                    return number;
            }
        }
    });

    return mn;

})));


/***/ }),

/***/ "9609":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var suffixes = {
        0: '-чү',
        1: '-чи',
        2: '-чи',
        3: '-чү',
        4: '-чү',
        5: '-чи',
        6: '-чы',
        7: '-чи',
        8: '-чи',
        9: '-чу',
        10: '-чу',
        20: '-чы',
        30: '-чу',
        40: '-чы',
        50: '-чү',
        60: '-чы',
        70: '-чи',
        80: '-чи',
        90: '-чу',
        100: '-чү'
    };

    var ky = moment.defineLocale('ky', {
        months : 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
        monthsShort : 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split('_'),
        weekdays : 'Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби'.split('_'),
        weekdaysShort : 'Жек_Дүй_Шей_Шар_Бей_Жум_Ише'.split('_'),
        weekdaysMin : 'Жк_Дй_Шй_Шр_Бй_Жм_Иш'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Бүгүн саат] LT',
            nextDay : '[Эртең саат] LT',
            nextWeek : 'dddd [саат] LT',
            lastDay : '[Кечээ саат] LT',
            lastWeek : '[Өткөн аптанын] dddd [күнү] [саат] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ичинде',
            past : '%s мурун',
            s : 'бирнече секунд',
            ss : '%d секунд',
            m : 'бир мүнөт',
            mm : '%d мүнөт',
            h : 'бир саат',
            hh : '%d саат',
            d : 'бир күн',
            dd : '%d күн',
            M : 'бир ай',
            MM : '%d ай',
            y : 'бир жыл',
            yy : '%d жыл'
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
        ordinal : function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return ky;

})));


/***/ }),

/***/ "9638":
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "966f":
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__("7e64"),
    baseIsEqual = __webpack_require__("c05f");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),

/***/ "96cf":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "972c":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
                'ss': 'secunde',
                'mm': 'minute',
                'hh': 'ore',
                'dd': 'zile',
                'MM': 'luni',
                'yy': 'ani'
            },
            separator = ' ';
        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
            separator = ' de ';
        }
        return number + separator + format[key];
    }

    var ro = moment.defineLocale('ro', {
        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[azi la] LT',
            nextDay: '[mâine la] LT',
            nextWeek: 'dddd [la] LT',
            lastDay: '[ieri la] LT',
            lastWeek: '[fosta] dddd [la] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'peste %s',
            past : '%s în urmă',
            s : 'câteva secunde',
            ss : relativeTimeWithPlural,
            m : 'un minut',
            mm : relativeTimeWithPlural,
            h : 'o oră',
            hh : relativeTimeWithPlural,
            d : 'o zi',
            dd : relativeTimeWithPlural,
            M : 'o lună',
            MM : relativeTimeWithPlural,
            y : 'un an',
            yy : relativeTimeWithPlural
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return ro;

})));


/***/ }),

/***/ "9797":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var cy = moment.defineLocale('cy', {
        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
        weekdaysParseExact : true,
        // time formats are the same as en-gb
        longDateFormat: {
            LT: 'HH:mm',
            LTS : 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Heddiw am] LT',
            nextDay: '[Yfory am] LT',
            nextWeek: 'dddd [am] LT',
            lastDay: '[Ddoe am] LT',
            lastWeek: 'dddd [diwethaf am] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'mewn %s',
            past: '%s yn ôl',
            s: 'ychydig eiliadau',
            ss: '%d eiliad',
            m: 'munud',
            mm: '%d munud',
            h: 'awr',
            hh: '%d awr',
            d: 'diwrnod',
            dd: '%d diwrnod',
            M: 'mis',
            MM: '%d mis',
            y: 'blwyddyn',
            yy: '%d flynedd'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
        ordinal: function (number) {
            var b = number,
                output = '',
                lookup = [
                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
                ];
            if (b > 20) {
                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                    output = 'fed'; // not 30ain, 70ain or 90ain
                } else {
                    output = 'ain';
                }
            } else if (b > 0) {
                output = lookup[b];
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return cy;

})));


/***/ }),

/***/ "9934":
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__("6fcd"),
    baseKeysIn = __webpack_require__("41c3"),
    isArrayLike = __webpack_require__("30c9");

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ "99cd":
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),

/***/ "99d3":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__("585a");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("62e4")(module)))

/***/ }),

/***/ "9aa9":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "9b02":
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__("656b");

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ "9b42":
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "9e69":
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__("2b3e");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "9f26":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var fr = moment.defineLocale('fr', {
        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Aujourd’hui à] LT',
            nextDay : '[Demain à] LT',
            nextWeek : 'dddd [à] LT',
            lastDay : '[Hier à] LT',
            lastWeek : 'dddd [dernier à] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            ss : '%d secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
        ordinal : function (number, period) {
            switch (period) {
                // TODO: Return 'e' when day of month > 1. Move this case inside
                // block for masculine words below.
                // See https://github.com/moment/moment/issues/3375
                case 'D':
                    return number + (number === 1 ? 'er' : '');

                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fr;

})));


/***/ }),

/***/ "a029":
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__("087d"),
    getPrototype = __webpack_require__("2dcb"),
    getSymbols = __webpack_require__("32f4"),
    stubArray = __webpack_require__("d327");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ "a0c4":
/***/ (function(module, exports) {

/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}

module.exports = arrayAggregator;


/***/ }),

/***/ "a2be":
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__("d612"),
    arraySome = __webpack_require__("4284"),
    cacheHas = __webpack_require__("c584");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ "a2db":
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__("9e69");

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ "a34a":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("96cf");


/***/ }),

/***/ "a356":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var arDz = moment.defineLocale('ar-dz', {
        months : 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        monthsShort : 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
        weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort : 'احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin : 'أح_إث_ثلا_أر_خم_جم_سب'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'في %s',
            past : 'منذ %s',
            s : 'ثوان',
            ss : '%d ثانية',
            m : 'دقيقة',
            mm : '%d دقائق',
            h : 'ساعة',
            hh : '%d ساعات',
            d : 'يوم',
            dd : '%d أيام',
            M : 'شهر',
            MM : '%d أشهر',
            y : 'سنة',
            yy : '%d سنوات'
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return arDz;

})));


/***/ }),

/***/ "a3c3":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__("63b6");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__("9306") });


/***/ }),

/***/ "a454":
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__("72f0"),
    defineProperty = __webpack_require__("3b4a"),
    identity = __webpack_require__("cd9d");

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),

/***/ "a524":
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__("4245");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "a7fa":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var bm = moment.defineLocale('bm', {
        months : 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mɛkalo_Zuwɛnkalo_Zuluyekalo_Utikalo_Sɛtanburukalo_ɔkutɔburukalo_Nowanburukalo_Desanburukalo'.split('_'),
        monthsShort : 'Zan_Few_Mar_Awi_Mɛ_Zuw_Zul_Uti_Sɛt_ɔku_Now_Des'.split('_'),
        weekdays : 'Kari_Ntɛnɛn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
        weekdaysShort : 'Kar_Ntɛ_Tar_Ara_Ala_Jum_Sib'.split('_'),
        weekdaysMin : 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'MMMM [tile] D [san] YYYY',
            LLL : 'MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm',
            LLLL : 'dddd MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm'
        },
        calendar : {
            sameDay : '[Bi lɛrɛ] LT',
            nextDay : '[Sini lɛrɛ] LT',
            nextWeek : 'dddd [don lɛrɛ] LT',
            lastDay : '[Kunu lɛrɛ] LT',
            lastWeek : 'dddd [tɛmɛnen lɛrɛ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s kɔnɔ',
            past : 'a bɛ %s bɔ',
            s : 'sanga dama dama',
            ss : 'sekondi %d',
            m : 'miniti kelen',
            mm : 'miniti %d',
            h : 'lɛrɛ kelen',
            hh : 'lɛrɛ %d',
            d : 'tile kelen',
            dd : 'tile %d',
            M : 'kalo kelen',
            MM : 'kalo %d',
            y : 'san kelen',
            yy : 'san %d'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return bm;

})));


/***/ }),

/***/ "a8fc":
/***/ (function(module, exports, __webpack_require__) {

var baseIteratee = __webpack_require__("badf"),
    baseUniq = __webpack_require__("2c66");

/**
 * This method is like `_.uniq` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * uniqueness is computed. The order of result values is determined by the
 * order they occur in the array. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
function uniqBy(array, iteratee) {
  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];
}

module.exports = uniqBy;


/***/ }),

/***/ "a994":
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__("7d1f"),
    getSymbols = __webpack_require__("32f4"),
    keys = __webpack_require__("ec69");

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ "ac41":
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ "ada2":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'ss': withoutSuffix ? 'секунда_секунди_секунд' : 'секунду_секунди_секунд',
            'mm': withoutSuffix ? 'хвилина_хвилини_хвилин' : 'хвилину_хвилини_хвилин',
            'hh': withoutSuffix ? 'година_години_годин' : 'годину_години_годин',
            'dd': 'день_дні_днів',
            'MM': 'місяць_місяці_місяців',
            'yy': 'рік_роки_років'
        };
        if (key === 'm') {
            return withoutSuffix ? 'хвилина' : 'хвилину';
        }
        else if (key === 'h') {
            return withoutSuffix ? 'година' : 'годину';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    function weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split('_'),
            'accusative': 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split('_'),
            'genitive': 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split('_')
        };

        if (m === true) {
            return weekdays['nominative'].slice(1, 7).concat(weekdays['nominative'].slice(0, 1));
        }
        if (!m) {
            return weekdays['nominative'];
        }

        var nounCase = (/(\[[ВвУу]\]) ?dddd/).test(format) ?
            'accusative' :
            ((/\[?(?:минулої|наступної)? ?\] ?dddd/).test(format) ?
                'genitive' :
                'nominative');
        return weekdays[nounCase][m.day()];
    }
    function processHoursFunction(str) {
        return function () {
            return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
        };
    }

    var uk = moment.defineLocale('uk', {
        months : {
            'format': 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split('_'),
            'standalone': 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split('_')
        },
        monthsShort : 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split('_'),
        weekdays : weekdaysCaseReplace,
        weekdaysShort : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY р.',
            LLL : 'D MMMM YYYY р., HH:mm',
            LLLL : 'dddd, D MMMM YYYY р., HH:mm'
        },
        calendar : {
            sameDay: processHoursFunction('[Сьогодні '),
            nextDay: processHoursFunction('[Завтра '),
            lastDay: processHoursFunction('[Вчора '),
            nextWeek: processHoursFunction('[У] dddd ['),
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 5:
                    case 6:
                        return processHoursFunction('[Минулої] dddd [').call(this);
                    case 1:
                    case 2:
                    case 4:
                        return processHoursFunction('[Минулого] dddd [').call(this);
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'за %s',
            past : '%s тому',
            s : 'декілька секунд',
            ss : relativeTimeWithPlural,
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : 'годину',
            hh : relativeTimeWithPlural,
            d : 'день',
            dd : relativeTimeWithPlural,
            M : 'місяць',
            MM : relativeTimeWithPlural,
            y : 'рік',
            yy : relativeTimeWithPlural
        },
        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
        meridiemParse: /ночі|ранку|дня|вечора/,
        isPM: function (input) {
            return /^(дня|вечора)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ночі';
            } else if (hour < 12) {
                return 'ранку';
            } else if (hour < 17) {
                return 'дня';
            } else {
                return 'вечора';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                case 'w':
                case 'W':
                    return number + '-й';
                case 'D':
                    return number + '-го';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return uk;

})));


/***/ }),

/***/ "aebd":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "b047":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("1a8c"),
    now = __webpack_require__("408c"),
    toNumber = __webpack_require__("b4b0");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),

/***/ "b047f":
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "b1e5":
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys = __webpack_require__("a994");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ "b218":
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "b29d":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var lo = moment.defineLocale('lo', {
        months : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
        monthsShort : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
        weekdays : 'ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
        weekdaysShort : 'ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
        weekdaysMin : 'ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'ວັນdddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
        isPM: function (input) {
            return input === 'ຕອນແລງ';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ຕອນເຊົ້າ';
            } else {
                return 'ຕອນແລງ';
            }
        },
        calendar : {
            sameDay : '[ມື້ນີ້ເວລາ] LT',
            nextDay : '[ມື້ອື່ນເວລາ] LT',
            nextWeek : '[ວັນ]dddd[ໜ້າເວລາ] LT',
            lastDay : '[ມື້ວານນີ້ເວລາ] LT',
            lastWeek : '[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ອີກ %s',
            past : '%sຜ່ານມາ',
            s : 'ບໍ່ເທົ່າໃດວິນາທີ',
            ss : '%d ວິນາທີ' ,
            m : '1 ນາທີ',
            mm : '%d ນາທີ',
            h : '1 ຊົ່ວໂມງ',
            hh : '%d ຊົ່ວໂມງ',
            d : '1 ມື້',
            dd : '%d ມື້',
            M : '1 ເດືອນ',
            MM : '%d ເດືອນ',
            y : '1 ປີ',
            yy : '%d ປີ'
        },
        dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/,
        ordinal : function (number) {
            return 'ທີ່' + number;
        }
    });

    return lo;

})));


/***/ }),

/***/ "b3eb":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var deAt = moment.defineLocale('de-at', {
        months : 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jän._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            ss : '%d Sekunden',
            m : processRelativeTime,
            mm : '%d Minuten',
            h : processRelativeTime,
            hh : '%d Stunden',
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return deAt;

})));


/***/ }),

/***/ "b447":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__("3a38");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "b469":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de = moment.defineLocale('de', {
        months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            ss : '%d Sekunden',
            m : processRelativeTime,
            mm : '%d Minuten',
            h : processRelativeTime,
            hh : '%d Stunden',
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return de;

})));


/***/ }),

/***/ "b4b0":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("1a8c"),
    isSymbol = __webpack_require__("ffd6");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "b4c0":
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__("cb5a");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "b53d":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var tzmLatn = moment.defineLocale('tzm-latn', {
        months : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
        monthsShort : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[asdkh g] LT',
            nextDay: '[aska g] LT',
            nextWeek: 'dddd [g] LT',
            lastDay: '[assant g] LT',
            lastWeek: 'dddd [g] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dadkh s yan %s',
            past : 'yan %s',
            s : 'imik',
            ss : '%d imik',
            m : 'minuḍ',
            mm : '%d minuḍ',
            h : 'saɛa',
            hh : '%d tassaɛin',
            d : 'ass',
            dd : '%d ossan',
            M : 'ayowr',
            MM : '%d iyyirn',
            y : 'asgas',
            yy : '%d isgasn'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return tzmLatn;

})));


/***/ }),

/***/ "b540":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var jv = moment.defineLocale('jv', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'enjing') {
                return hour;
            } else if (meridiem === 'siyang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'enjing';
            } else if (hours < 15) {
                return 'siyang';
            } else if (hours < 19) {
                return 'sonten';
            } else {
                return 'ndalu';
            }
        },
        calendar : {
            sameDay : '[Dinten puniko pukul] LT',
            nextDay : '[Mbenjang pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kala wingi pukul] LT',
            lastWeek : 'dddd [kepengker pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'wonten ing %s',
            past : '%s ingkang kepengker',
            s : 'sawetawis detik',
            ss : '%d detik',
            m : 'setunggal menit',
            mm : '%d menit',
            h : 'setunggal jam',
            hh : '%d jam',
            d : 'sedinten',
            dd : '%d dinten',
            M : 'sewulan',
            MM : '%d wulan',
            y : 'setaun',
            yy : '%d taun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return jv;

})));


/***/ }),

/***/ "b5a7":
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__("0b07"),
    root = __webpack_require__("2b3e");

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ "b84c":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var nn = moment.defineLocale('nn', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
        weekdaysShort : 'sun_mån_tys_ons_tor_fre_lau'.split('_'),
        weekdaysMin : 'su_må_ty_on_to_fr_lø'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] H:mm',
            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar : {
            sameDay: '[I dag klokka] LT',
            nextDay: '[I morgon klokka] LT',
            nextWeek: 'dddd [klokka] LT',
            lastDay: '[I går klokka] LT',
            lastWeek: '[Føregåande] dddd [klokka] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s sidan',
            s : 'nokre sekund',
            ss : '%d sekund',
            m : 'eit minutt',
            mm : '%d minutt',
            h : 'ein time',
            hh : '%d timar',
            d : 'ein dag',
            dd : '%d dagar',
            M : 'ein månad',
            MM : '%d månader',
            y : 'eit år',
            yy : '%d år'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nn;

})));


/***/ }),

/***/ "b897":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = generate;

var _tinycolor = __webpack_require__("66cb");

var _tinycolor2 = _interopRequireDefault(_tinycolor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hueStep = 2; // 色相阶梯
var saturationStep = 16; // 饱和度阶梯，浅色部分
var saturationStep2 = 5; // 饱和度阶梯，深色部分
var brightnessStep1 = 5; // 亮度阶梯，浅色部分
var brightnessStep2 = 15; // 亮度阶梯，深色部分
var lightColorCount = 5; // 浅色数量，主色上
var darkColorCount = 4; // 深色数量，主色下

function getHue(hsv, i, light) {
  var hue = void 0;
  // 根据色相不同，色相转向不同
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i;
  }
  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }
  return hue;
}

function getSaturation(hsv, i, light) {
  // grey color don't change saturation
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  var saturation = void 0;
  if (light) {
    saturation = Math.round(hsv.s * 100) - saturationStep * i;
  } else if (i === darkColorCount) {
    saturation = Math.round(hsv.s * 100) + saturationStep;
  } else {
    saturation = Math.round(hsv.s * 100) + saturationStep2 * i;
  }
  // 边界值修正
  if (saturation > 100) {
    saturation = 100;
  }
  // 第一格的 s 限制在 6-10 之间
  if (light && i === lightColorCount && saturation > 10) {
    saturation = 10;
  }
  if (saturation < 6) {
    saturation = 6;
  }
  return saturation;
}

function getValue(hsv, i, light) {
  if (light) {
    return Math.round(hsv.v * 100) + brightnessStep1 * i;
  }
  return Math.round(hsv.v * 100) - brightnessStep2 * i;
}

function generate(color) {
  var patterns = [];
  var pColor = (0, _tinycolor2.default)(color);
  for (var i = lightColorCount; i > 0; i -= 1) {
    var hsv = pColor.toHsv();
    var colorString = (0, _tinycolor2.default)({
      h: getHue(hsv, i, true),
      s: getSaturation(hsv, i, true),
      v: getValue(hsv, i, true)
    }).toHexString();
    patterns.push(colorString);
  }
  patterns.push(pColor.toHexString());
  for (var _i = 1; _i <= darkColorCount; _i += 1) {
    var _hsv = pColor.toHsv();
    var _colorString = (0, _tinycolor2.default)({
      h: getHue(_hsv, _i),
      s: getSaturation(_hsv, _i),
      v: getValue(_hsv, _i)
    }).toHexString();
    patterns.push(_colorString);
  }
  return patterns;
}

/***/ }),

/***/ "b8ad":
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? module.exports = factory() :
	undefined;
}(this, (function () { 'use strict';

function arrayTreeFilter(data, filterFn, options) {
    options = options || {};
    options.childrenKeyName = options.childrenKeyName || "children";
    var children = data || [];
    var result = [];
    var level = 0;
    do {
        var foundItem = children.filter(function (item) {
            return filterFn(item, level);
        })[0];
        if (!foundItem) {
            break;
        }
        result.push(foundItem);
        children = foundItem[options.childrenKeyName] || [];
        level += 1;
    } while (children.length > 0);
    return result;
}

return arrayTreeFilter;

})));


/***/ }),

/***/ "b8e3":
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "b97c":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var units = {
        'ss': 'sekundes_sekundēm_sekunde_sekundes'.split('_'),
        'm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
        'mm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
        'h': 'stundas_stundām_stunda_stundas'.split('_'),
        'hh': 'stundas_stundām_stunda_stundas'.split('_'),
        'd': 'dienas_dienām_diena_dienas'.split('_'),
        'dd': 'dienas_dienām_diena_dienas'.split('_'),
        'M': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
        'MM': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
        'y': 'gada_gadiem_gads_gadi'.split('_'),
        'yy': 'gada_gadiem_gads_gadi'.split('_')
    };
    /**
     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
     */
    function format(forms, number, withoutSuffix) {
        if (withoutSuffix) {
            // E.g. "21 minūte", "3 minūtes".
            return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
        } else {
            // E.g. "21 minūtes" as in "pēc 21 minūtes".
            // E.g. "3 minūtēm" as in "pēc 3 minūtēm".
            return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
        }
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        return number + ' ' + format(units[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
        return format(units[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
        return withoutSuffix ? 'dažas sekundes' : 'dažām sekundēm';
    }

    var lv = moment.defineLocale('lv', {
        months : 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split('_'),
        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY.',
            LL : 'YYYY. [gada] D. MMMM',
            LLL : 'YYYY. [gada] D. MMMM, HH:mm',
            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
        },
        calendar : {
            sameDay : '[Šodien pulksten] LT',
            nextDay : '[Rīt pulksten] LT',
            nextWeek : 'dddd [pulksten] LT',
            lastDay : '[Vakar pulksten] LT',
            lastWeek : '[Pagājušā] dddd [pulksten] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'pēc %s',
            past : 'pirms %s',
            s : relativeSeconds,
            ss : relativeTimeWithPlural,
            m : relativeTimeWithSingular,
            mm : relativeTimeWithPlural,
            h : relativeTimeWithSingular,
            hh : relativeTimeWithPlural,
            d : relativeTimeWithSingular,
            dd : relativeTimeWithPlural,
            M : relativeTimeWithSingular,
            MM : relativeTimeWithPlural,
            y : relativeTimeWithSingular,
            yy : relativeTimeWithPlural
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lv;

})));


/***/ }),

/***/ "badf":
/***/ (function(module, exports, __webpack_require__) {

var baseMatches = __webpack_require__("642a"),
    baseMatchesProperty = __webpack_require__("1838"),
    identity = __webpack_require__("cd9d"),
    isArray = __webpack_require__("6747"),
    property = __webpack_require__("f9ce");

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),

/***/ "bb71":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var deCh = moment.defineLocale('de-ch', {
        months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            ss : '%d Sekunden',
            m : processRelativeTime,
            mm : '%d Minuten',
            h : processRelativeTime,
            hh : '%d Stunden',
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return deCh;

})));


/***/ }),

/***/ "bbc0":
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__("6044");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "bcdf":
/***/ (function(module, exports) {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ }),

/***/ "c05f":
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__("7b97"),
    isObjectLike = __webpack_require__("1310");

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ "c098":
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "c109":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var tzm = moment.defineLocale('tzm', {
        months : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
        monthsShort : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
        weekdays : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        weekdaysShort : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        weekdaysMin : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
            nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
            nextWeek: 'dddd [ⴴ] LT',
            lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
            lastWeek: 'dddd [ⴴ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
            past : 'ⵢⴰⵏ %s',
            s : 'ⵉⵎⵉⴽ',
            ss : '%d ⵉⵎⵉⴽ',
            m : 'ⵎⵉⵏⵓⴺ',
            mm : '%d ⵎⵉⵏⵓⴺ',
            h : 'ⵙⴰⵄⴰ',
            hh : '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
            d : 'ⴰⵙⵙ',
            dd : '%d oⵙⵙⴰⵏ',
            M : 'ⴰⵢoⵓⵔ',
            MM : '%d ⵉⵢⵢⵉⵔⵏ',
            y : 'ⴰⵙⴳⴰⵙ',
            yy : '%d ⵉⵙⴳⴰⵙⵏ'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return tzm;

})));


/***/ }),

/***/ "c135":
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "c1c9":
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__("a454"),
    shortOut = __webpack_require__("f3c1");

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),

/***/ "c1df":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var require;//! moment.js

;(function (global, factory) {
     true ? module.exports = factory() :
    undefined
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate (y) {
        var date;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            var args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays (ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays :
            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
            : (m) ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                __webpack_require__("4678")("./" + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':   return months;
                case 'quarter': return months / 3;
                case 'year':    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asQuarters     = makeAs('Q');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asQuarters     = asQuarters;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.24.0';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("62e4")(module)))

/***/ }),

/***/ "c240":
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "c2b3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function shallowEqualArrays(arrA, arrB) {
  if (arrA === arrB) {
    return true;
  }

  if (!arrA || !arrB) {
    return false;
  }

  var len = arrA.length;

  if (arrB.length !== len) {
    return false;
  }

  for (var i = 0; i < len; i++) {
    if (arrA[i] !== arrB[i]) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqualArrays;


/***/ }),

/***/ "c2b6":
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__("f8af"),
    cloneDataView = __webpack_require__("5d89"),
    cloneRegExp = __webpack_require__("6f6c"),
    cloneSymbol = __webpack_require__("a2db"),
    cloneTypedArray = __webpack_require__("c8fe");

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ "c3a1":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__("e6f3");
var enumBugKeys = __webpack_require__("1691");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "c3fc":
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__("42a2"),
    isObjectLike = __webpack_require__("1310");

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ "c449":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var now = __webpack_require__("6d08")
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf
  object.cancelAnimationFrame = caf
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "c584":
/***/ (function(module, exports) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ "c6cf":
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__("4d8c"),
    overRest = __webpack_require__("2286"),
    setToString = __webpack_require__("c1c9");

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),

/***/ "c7aa":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var he = moment.defineLocale('he', {
        months : 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split('_'),
        monthsShort : 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split('_'),
        weekdays : 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
        weekdaysShort : 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
        weekdaysMin : 'א_ב_ג_ד_ה_ו_ש'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [ב]MMMM YYYY',
            LLL : 'D [ב]MMMM YYYY HH:mm',
            LLLL : 'dddd, D [ב]MMMM YYYY HH:mm',
            l : 'D/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd, D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[היום ב־]LT',
            nextDay : '[מחר ב־]LT',
            nextWeek : 'dddd [בשעה] LT',
            lastDay : '[אתמול ב־]LT',
            lastWeek : '[ביום] dddd [האחרון בשעה] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'בעוד %s',
            past : 'לפני %s',
            s : 'מספר שניות',
            ss : '%d שניות',
            m : 'דקה',
            mm : '%d דקות',
            h : 'שעה',
            hh : function (number) {
                if (number === 2) {
                    return 'שעתיים';
                }
                return number + ' שעות';
            },
            d : 'יום',
            dd : function (number) {
                if (number === 2) {
                    return 'יומיים';
                }
                return number + ' ימים';
            },
            M : 'חודש',
            MM : function (number) {
                if (number === 2) {
                    return 'חודשיים';
                }
                return number + ' חודשים';
            },
            y : 'שנה',
            yy : function (number) {
                if (number === 2) {
                    return 'שנתיים';
                } else if (number % 10 === 0 && number !== 10) {
                    return number + ' שנה';
                }
                return number + ' שנים';
            }
        },
        meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
        isPM : function (input) {
            return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 5) {
                return 'לפנות בוקר';
            } else if (hour < 10) {
                return 'בבוקר';
            } else if (hour < 12) {
                return isLower ? 'לפנה"צ' : 'לפני הצהריים';
            } else if (hour < 18) {
                return isLower ? 'אחה"צ' : 'אחרי הצהריים';
            } else {
                return 'בערב';
            }
        }
    });

    return he;

})));


/***/ }),

/***/ "c869":
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__("0b07"),
    root = __webpack_require__("2b3e");

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ "c87c":
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ "c8ba":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "c8f3":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var sq = moment.defineLocale('sq', {
        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split('_'),
        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
        weekdays : 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split('_'),
        weekdaysShort : 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
        weekdaysMin : 'D_H_Ma_Më_E_P_Sh'.split('_'),
        weekdaysParseExact : true,
        meridiemParse: /PD|MD/,
        isPM: function (input) {
            return input.charAt(0) === 'M';
        },
        meridiem : function (hours, minutes, isLower) {
            return hours < 12 ? 'PD' : 'MD';
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Sot në] LT',
            nextDay : '[Nesër në] LT',
            nextWeek : 'dddd [në] LT',
            lastDay : '[Dje në] LT',
            lastWeek : 'dddd [e kaluar në] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'në %s',
            past : '%s më parë',
            s : 'disa sekonda',
            ss : '%d sekonda',
            m : 'një minutë',
            mm : '%d minuta',
            h : 'një orë',
            hh : '%d orë',
            d : 'një ditë',
            dd : '%d ditë',
            M : 'një muaj',
            MM : '%d muaj',
            y : 'një vit',
            yy : '%d vite'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sq;

})));


/***/ }),

/***/ "c8fe":
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__("f8af");

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ "cb5a":
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__("9638");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "cc45":
/***/ (function(module, exports, __webpack_require__) {

var baseIsMap = __webpack_require__("1a2d"),
    baseUnary = __webpack_require__("b047f"),
    nodeUtil = __webpack_require__("99d3");

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ "cd9d":
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "cdab":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var enSG = moment.defineLocale('en-SG', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enSG;

})));


/***/ }),

/***/ "ce86":
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__("9e69"),
    arrayMap = __webpack_require__("7948"),
    isArray = __webpack_require__("6747"),
    isSymbol = __webpack_require__("ffd6");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ "cecd":
/***/ (function(module, exports) {

module.exports = function(arr, obj){
  if (arr.indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),

/***/ "cf1e":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var translator = {
        words: { //Different grammatical cases
            ss: ['sekunda', 'sekunde', 'sekundi'],
            m: ['jedan minut', 'jedne minute'],
            mm: ['minut', 'minute', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mesec', 'meseca', 'meseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr = moment.defineLocale('sr', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sre._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedelju] [u] LT';
                    case 3:
                        return '[u] [sredu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juče u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[prošle] [nedelje] [u] LT',
                    '[prošlog] [ponedeljka] [u] LT',
                    '[prošlog] [utorka] [u] LT',
                    '[prošle] [srede] [u] LT',
                    '[prošlog] [četvrtka] [u] LT',
                    '[prošlog] [petka] [u] LT',
                    '[prošle] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'pre %s',
            s      : 'nekoliko sekundi',
            ss     : translator.translate,
            m      : translator.translate,
            mm     : translator.translate,
            h      : translator.translate,
            hh     : translator.translate,
            d      : 'dan',
            dd     : translator.translate,
            M      : 'mesec',
            MM     : translator.translate,
            y      : 'godinu',
            yy     : translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return sr;

})));


/***/ }),

/***/ "cf51":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
    // This is currently too difficult (maybe even impossible) to add.
    var tzl = moment.defineLocale('tzl', {
        months : 'Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
        weekdays : 'Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi'.split('_'),
        weekdaysShort : 'Súl_Lún_Mai_Már_Xhú_Vié_Sát'.split('_'),
        weekdaysMin : 'Sú_Lú_Ma_Má_Xh_Vi_Sá'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM [dallas] YYYY',
            LLL : 'D. MMMM [dallas] YYYY HH.mm',
            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
        },
        meridiemParse: /d\'o|d\'a/i,
        isPM : function (input) {
            return 'd\'o' === input.toLowerCase();
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'd\'o' : 'D\'O';
            } else {
                return isLower ? 'd\'a' : 'D\'A';
            }
        },
        calendar : {
            sameDay : '[oxhi à] LT',
            nextDay : '[demà à] LT',
            nextWeek : 'dddd [à] LT',
            lastDay : '[ieiri à] LT',
            lastWeek : '[sür el] dddd [lasteu à] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'osprei %s',
            past : 'ja%s',
            s : processRelativeTime,
            ss : processRelativeTime,
            m : processRelativeTime,
            mm : processRelativeTime,
            h : processRelativeTime,
            hh : processRelativeTime,
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's': ['viensas secunds', '\'iensas secunds'],
            'ss': [number + ' secunds', '' + number + ' secunds'],
            'm': ['\'n míut', '\'iens míut'],
            'mm': [number + ' míuts', '' + number + ' míuts'],
            'h': ['\'n þora', '\'iensa þora'],
            'hh': [number + ' þoras', '' + number + ' þoras'],
            'd': ['\'n ziua', '\'iensa ziua'],
            'dd': [number + ' ziuas', '' + number + ' ziuas'],
            'M': ['\'n mes', '\'iens mes'],
            'MM': [number + ' mesen', '' + number + ' mesen'],
            'y': ['\'n ar', '\'iens ar'],
            'yy': [number + ' ars', '' + number + ' ars']
        };
        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
    }

    return tzl;

})));


/***/ }),

/***/ "cf75":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var numbersNouns = 'pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

    function translateFuture(output) {
        var time = output;
        time = (output.indexOf('jaj') !== -1) ?
        time.slice(0, -3) + 'leS' :
        (output.indexOf('jar') !== -1) ?
        time.slice(0, -3) + 'waQ' :
        (output.indexOf('DIS') !== -1) ?
        time.slice(0, -3) + 'nem' :
        time + ' pIq';
        return time;
    }

    function translatePast(output) {
        var time = output;
        time = (output.indexOf('jaj') !== -1) ?
        time.slice(0, -3) + 'Hu’' :
        (output.indexOf('jar') !== -1) ?
        time.slice(0, -3) + 'wen' :
        (output.indexOf('DIS') !== -1) ?
        time.slice(0, -3) + 'ben' :
        time + ' ret';
        return time;
    }

    function translate(number, withoutSuffix, string, isFuture) {
        var numberNoun = numberAsNoun(number);
        switch (string) {
            case 'ss':
                return numberNoun + ' lup';
            case 'mm':
                return numberNoun + ' tup';
            case 'hh':
                return numberNoun + ' rep';
            case 'dd':
                return numberNoun + ' jaj';
            case 'MM':
                return numberNoun + ' jar';
            case 'yy':
                return numberNoun + ' DIS';
        }
    }

    function numberAsNoun(number) {
        var hundred = Math.floor((number % 1000) / 100),
        ten = Math.floor((number % 100) / 10),
        one = number % 10,
        word = '';
        if (hundred > 0) {
            word += numbersNouns[hundred] + 'vatlh';
        }
        if (ten > 0) {
            word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
        }
        if (one > 0) {
            word += ((word !== '') ? ' ' : '') + numbersNouns[one];
        }
        return (word === '') ? 'pagh' : word;
    }

    var tlh = moment.defineLocale('tlh', {
        months : 'tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’'.split('_'),
        monthsShort : 'jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’'.split('_'),
        monthsParseExact : true,
        weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[DaHjaj] LT',
            nextDay: '[wa’leS] LT',
            nextWeek: 'LLL',
            lastDay: '[wa’Hu’] LT',
            lastWeek: 'LLL',
            sameElse: 'L'
        },
        relativeTime : {
            future : translateFuture,
            past : translatePast,
            s : 'puS lup',
            ss : translate,
            m : 'wa’ tup',
            mm : translate,
            h : 'wa’ rep',
            hh : translate,
            d : 'wa’ jaj',
            dd : translate,
            M : 'wa’ jar',
            MM : translate,
            y : 'wa’ DIS',
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tlh;

})));


/***/ }),

/***/ "d02c":
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__("5e2e"),
    Map = __webpack_require__("79bc"),
    MapCache = __webpack_require__("7b83");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ "d26a":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '༡',
        '2': '༢',
        '3': '༣',
        '4': '༤',
        '5': '༥',
        '6': '༦',
        '7': '༧',
        '8': '༨',
        '9': '༩',
        '0': '༠'
    },
    numberMap = {
        '༡': '1',
        '༢': '2',
        '༣': '3',
        '༤': '4',
        '༥': '5',
        '༦': '6',
        '༧': '7',
        '༨': '8',
        '༩': '9',
        '༠': '0'
    };

    var bo = moment.defineLocale('bo', {
        months : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
        monthsShort : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
        weekdays : 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split('_'),
        weekdaysShort : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
        weekdaysMin : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[དི་རིང] LT',
            nextDay : '[སང་ཉིན] LT',
            nextWeek : '[བདུན་ཕྲག་རྗེས་མ], LT',
            lastDay : '[ཁ་སང] LT',
            lastWeek : '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ལ་',
            past : '%s སྔན་ལ',
            s : 'ལམ་སང',
            ss : '%d སྐར་ཆ།',
            m : 'སྐར་མ་གཅིག',
            mm : '%d སྐར་མ',
            h : 'ཆུ་ཚོད་གཅིག',
            hh : '%d ཆུ་ཚོད',
            d : 'ཉིན་གཅིག',
            dd : '%d ཉིན་',
            M : 'ཟླ་བ་གཅིག',
            MM : '%d ཟླ་བ',
            y : 'ལོ་གཅིག',
            yy : '%d ལོ'
        },
        preparse: function (string) {
            return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === 'མཚན་མོ' && hour >= 4) ||
                    (meridiem === 'ཉིན་གུང' && hour < 5) ||
                    meridiem === 'དགོང་དག') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'མཚན་མོ';
            } else if (hour < 10) {
                return 'ཞོགས་ཀས';
            } else if (hour < 17) {
                return 'ཉིན་གུང';
            } else if (hour < 20) {
                return 'དགོང་དག';
            } else {
                return 'མཚན་མོ';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return bo;

})));


/***/ }),

/***/ "d2d4":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var ptBr = moment.defineLocale('pt-br', {
        months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
        weekdaysMin : 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY [às] HH:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY [às] HH:mm'
        },
        calendar : {
            sameDay: '[Hoje às] LT',
            nextDay: '[Amanhã às] LT',
            nextWeek: 'dddd [às] LT',
            lastDay: '[Ontem às] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[Último] dddd [às] LT' : // Saturday + Sunday
                    '[Última] dddd [às] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : 'há %s',
            s : 'poucos segundos',
            ss : '%d segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um mês',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal : '%dº'
    });

    return ptBr;

})));


/***/ }),

/***/ "d327":
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "d370":
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__("253c"),
    isObjectLike = __webpack_require__("1310");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "d612":
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__("7b83"),
    setCacheAdd = __webpack_require__("7ed2"),
    setCacheHas = __webpack_require__("dc0f");

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ "d6b6":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var hyAm = moment.defineLocale('hy-am', {
        months : {
            format: 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split('_'),
            standalone: 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split('_')
        },
        monthsShort : 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_'),
        weekdays : 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split('_'),
        weekdaysShort : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
        weekdaysMin : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY թ.',
            LLL : 'D MMMM YYYY թ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY թ., HH:mm'
        },
        calendar : {
            sameDay: '[այսօր] LT',
            nextDay: '[վաղը] LT',
            lastDay: '[երեկ] LT',
            nextWeek: function () {
                return 'dddd [օրը ժամը] LT';
            },
            lastWeek: function () {
                return '[անցած] dddd [օրը ժամը] LT';
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s հետո',
            past : '%s առաջ',
            s : 'մի քանի վայրկյան',
            ss : '%d վայրկյան',
            m : 'րոպե',
            mm : '%d րոպե',
            h : 'ժամ',
            hh : '%d ժամ',
            d : 'օր',
            dd : '%d օր',
            M : 'ամիս',
            MM : '%d ամիս',
            y : 'տարի',
            yy : '%d տարի'
        },
        meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
        isPM: function (input) {
            return /^(ցերեկվա|երեկոյան)$/.test(input);
        },
        meridiem : function (hour) {
            if (hour < 4) {
                return 'գիշերվա';
            } else if (hour < 12) {
                return 'առավոտվա';
            } else if (hour < 17) {
                return 'ցերեկվա';
            } else {
                return 'երեկոյան';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'DDD':
                case 'w':
                case 'W':
                case 'DDDo':
                    if (number === 1) {
                        return number + '-ին';
                    }
                    return number + '-րդ';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return hyAm;

})));


/***/ }),

/***/ "d716":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var ca = moment.defineLocale('ca', {
        months : {
            standalone: 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
            format: 'de gener_de febrer_de març_d\'abril_de maig_de juny_de juliol_d\'agost_de setembre_d\'octubre_de novembre_de desembre'.split('_'),
            isFormat: /D[oD]?(\s)+MMMM/
        },
        monthsShort : 'gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
        monthsParseExact : true,
        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
        weekdaysMin : 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM [de] YYYY',
            ll : 'D MMM YYYY',
            LLL : 'D MMMM [de] YYYY [a les] H:mm',
            lll : 'D MMM YYYY, H:mm',
            LLLL : 'dddd D MMMM [de] YYYY [a les] H:mm',
            llll : 'ddd D MMM YYYY, H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextDay : function () {
                return '[demà a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastDay : function () {
                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'd\'aquí %s',
            past : 'fa %s',
            s : 'uns segons',
            ss : '%d segons',
            m : 'un minut',
            mm : '%d minuts',
            h : 'una hora',
            hh : '%d hores',
            d : 'un dia',
            dd : '%d dies',
            M : 'un mes',
            MM : '%d mesos',
            y : 'un any',
            yy : '%d anys'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
        ordinal : function (number, period) {
            var output = (number === 1) ? 'r' :
                (number === 2) ? 'n' :
                (number === 3) ? 'r' :
                (number === 4) ? 't' : 'è';
            if (period === 'w' || period === 'W') {
                output = 'a';
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ca;

})));


/***/ }),

/***/ "d7ee":
/***/ (function(module, exports, __webpack_require__) {

var baseIsSet = __webpack_require__("c3fc"),
    baseUnary = __webpack_require__("b047f"),
    nodeUtil = __webpack_require__("99d3");

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ "d864":
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__("79aa");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "d9a8":
/***/ (function(module, exports) {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


/***/ }),

/***/ "d9f6":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("e4ae");
var IE8_DOM_DEFINE = __webpack_require__("794b");
var toPrimitive = __webpack_require__("1bc3");
var dP = Object.defineProperty;

exports.f = __webpack_require__("8e60") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "d9f8":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var frCa = moment.defineLocale('fr-ca', {
        months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
        monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Aujourd’hui à] LT',
            nextDay : '[Demain à] LT',
            nextWeek : 'dddd [à] LT',
            lastDay : '[Hier à] LT',
            lastWeek : 'dddd [dernier à] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            ss : '%d secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal : function (number, period) {
            switch (period) {
                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'D':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        }
    });

    return frCa;

})));


/***/ }),

/***/ "da03":
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__("2b3e");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "db29":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
    var monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

    var nlBe = moment.defineLocale('nl-be', {
        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },

        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,

        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'over %s',
            past : '%s geleden',
            s : 'een paar seconden',
            ss : '%d seconden',
            m : 'één minuut',
            mm : '%d minuten',
            h : 'één uur',
            hh : '%d uur',
            d : 'één dag',
            dd : '%d dagen',
            M : 'één maand',
            MM : '%d maanden',
            y : 'één jaar',
            yy : '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nlBe;

})));


/***/ }),

/***/ "dbdb":
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__("584a");
var global = __webpack_require__("e53d");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__("b8e3") ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "dc0f":
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ "dc4d":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '१',
        '2': '२',
        '3': '३',
        '4': '४',
        '5': '५',
        '6': '६',
        '7': '७',
        '8': '८',
        '9': '९',
        '0': '०'
    },
    numberMap = {
        '१': '1',
        '२': '2',
        '३': '3',
        '४': '4',
        '५': '5',
        '६': '6',
        '७': '7',
        '८': '8',
        '९': '9',
        '०': '0'
    };

    var hi = moment.defineLocale('hi', {
        months : 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split('_'),
        monthsShort : 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split('_'),
        monthsParseExact: true,
        weekdays : 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
        weekdaysShort : 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
        weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
        longDateFormat : {
            LT : 'A h:mm बजे',
            LTS : 'A h:mm:ss बजे',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm बजे',
            LLLL : 'dddd, D MMMM YYYY, A h:mm बजे'
        },
        calendar : {
            sameDay : '[आज] LT',
            nextDay : '[कल] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[कल] LT',
            lastWeek : '[पिछले] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s में',
            past : '%s पहले',
            s : 'कुछ ही क्षण',
            ss : '%d सेकंड',
            m : 'एक मिनट',
            mm : '%d मिनट',
            h : 'एक घंटा',
            hh : '%d घंटे',
            d : 'एक दिन',
            dd : '%d दिन',
            M : 'एक महीने',
            MM : '%d महीने',
            y : 'एक वर्ष',
            yy : '%d वर्ष'
        },
        preparse: function (string) {
            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
        meridiemParse: /रात|सुबह|दोपहर|शाम/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'रात') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'सुबह') {
                return hour;
            } else if (meridiem === 'दोपहर') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'शाम') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'रात';
            } else if (hour < 10) {
                return 'सुबह';
            } else if (hour < 17) {
                return 'दोपहर';
            } else if (hour < 20) {
                return 'शाम';
            } else {
                return 'रात';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return hi;

})));


/***/ }),

/***/ "dc57":
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "df7c":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("4362")))

/***/ }),

/***/ "e0c5":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
            '1': '૧',
            '2': '૨',
            '3': '૩',
            '4': '૪',
            '5': '૫',
            '6': '૬',
            '7': '૭',
            '8': '૮',
            '9': '૯',
            '0': '૦'
        },
        numberMap = {
            '૧': '1',
            '૨': '2',
            '૩': '3',
            '૪': '4',
            '૫': '5',
            '૬': '6',
            '૭': '7',
            '૮': '8',
            '૯': '9',
            '૦': '0'
        };

    var gu = moment.defineLocale('gu', {
        months: 'જાન્યુઆરી_ફેબ્રુઆરી_માર્ચ_એપ્રિલ_મે_જૂન_જુલાઈ_ઑગસ્ટ_સપ્ટેમ્બર_ઑક્ટ્બર_નવેમ્બર_ડિસેમ્બર'.split('_'),
        monthsShort: 'જાન્યુ._ફેબ્રુ._માર્ચ_એપ્રિ._મે_જૂન_જુલા._ઑગ._સપ્ટે._ઑક્ટ્._નવે._ડિસે.'.split('_'),
        monthsParseExact: true,
        weekdays: 'રવિવાર_સોમવાર_મંગળવાર_બુધ્વાર_ગુરુવાર_શુક્રવાર_શનિવાર'.split('_'),
        weekdaysShort: 'રવિ_સોમ_મંગળ_બુધ્_ગુરુ_શુક્ર_શનિ'.split('_'),
        weekdaysMin: 'ર_સો_મં_બુ_ગુ_શુ_શ'.split('_'),
        longDateFormat: {
            LT: 'A h:mm વાગ્યે',
            LTS: 'A h:mm:ss વાગ્યે',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm વાગ્યે',
            LLLL: 'dddd, D MMMM YYYY, A h:mm વાગ્યે'
        },
        calendar: {
            sameDay: '[આજ] LT',
            nextDay: '[કાલે] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[ગઇકાલે] LT',
            lastWeek: '[પાછલા] dddd, LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s મા',
            past: '%s પેહલા',
            s: 'અમુક પળો',
            ss: '%d સેકંડ',
            m: 'એક મિનિટ',
            mm: '%d મિનિટ',
            h: 'એક કલાક',
            hh: '%d કલાક',
            d: 'એક દિવસ',
            dd: '%d દિવસ',
            M: 'એક મહિનો',
            MM: '%d મહિનો',
            y: 'એક વર્ષ',
            yy: '%d વર્ષ'
        },
        preparse: function (string) {
            return string.replace(/[૧૨૩૪૫૬૭૮૯૦]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
        meridiemParse: /રાત|બપોર|સવાર|સાંજ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'રાત') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'સવાર') {
                return hour;
            } else if (meridiem === 'બપોર') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'સાંજ') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'રાત';
            } else if (hour < 10) {
                return 'સવાર';
            } else if (hour < 17) {
                return 'બપોર';
            } else if (hour < 20) {
                return 'સાંજ';
            } else {
                return 'રાત';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6 // The week that contains Jan 6th is the first week of the year.
        }
    });

    return gu;

})));


/***/ }),

/***/ "e0e7":
/***/ (function(module, exports, __webpack_require__) {

var isPlainObject = __webpack_require__("60ed");

/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */
function customOmitClone(value) {
  return isPlainObject(value) ? undefined : value;
}

module.exports = customOmitClone;


/***/ }),

/***/ "e1d3":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var enIe = moment.defineLocale('en-ie', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enIe;

})));


/***/ }),

/***/ "e24b":
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__("49f4"),
    hashDelete = __webpack_require__("1efc"),
    hashGet = __webpack_require__("bbc0"),
    hashHas = __webpack_require__("7a48"),
    hashSet = __webpack_require__("2524");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "e2c0":
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__("e2e4"),
    isArguments = __webpack_require__("d370"),
    isArray = __webpack_require__("6747"),
    isIndex = __webpack_require__("c098"),
    isLength = __webpack_require__("b218"),
    toKey = __webpack_require__("f4d6");

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),

/***/ "e2e4":
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__("6747"),
    isKey = __webpack_require__("f608"),
    stringToPath = __webpack_require__("18d8"),
    toString = __webpack_require__("76dd");

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ "e380":
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__("7b83");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ "e3f8":
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__("656b");

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),

/***/ "e4ae":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("f772");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "e538":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__("2b3e");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("62e4")(module)))

/***/ }),

/***/ "e53d":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "e6f3":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("07e3");
var toIObject = __webpack_require__("36c3");
var arrayIndexOf = __webpack_require__("5b4e")(false);
var IE_PROTO = __webpack_require__("5559")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "e81d":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '១',
        '2': '២',
        '3': '៣',
        '4': '៤',
        '5': '៥',
        '6': '៦',
        '7': '៧',
        '8': '៨',
        '9': '៩',
        '0': '០'
    }, numberMap = {
        '១': '1',
        '២': '2',
        '៣': '3',
        '៤': '4',
        '៥': '5',
        '៦': '6',
        '៧': '7',
        '៨': '8',
        '៩': '9',
        '០': '0'
    };

    var km = moment.defineLocale('km', {
        months: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split(
            '_'
        ),
        monthsShort: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split(
            '_'
        ),
        weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
        weekdaysShort: 'អា_ច_អ_ព_ព្រ_សុ_ស'.split('_'),
        weekdaysMin: 'អា_ច_អ_ព_ព្រ_សុ_ស'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        meridiemParse: /ព្រឹក|ល្ងាច/,
        isPM: function (input) {
            return input === 'ល្ងាច';
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ព្រឹក';
            } else {
                return 'ល្ងាច';
            }
        },
        calendar: {
            sameDay: '[ថ្ងៃនេះ ម៉ោង] LT',
            nextDay: '[ស្អែក ម៉ោង] LT',
            nextWeek: 'dddd [ម៉ោង] LT',
            lastDay: '[ម្សិលមិញ ម៉ោង] LT',
            lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%sទៀត',
            past: '%sមុន',
            s: 'ប៉ុន្មានវិនាទី',
            ss: '%d វិនាទី',
            m: 'មួយនាទី',
            mm: '%d នាទី',
            h: 'មួយម៉ោង',
            hh: '%d ម៉ោង',
            d: 'មួយថ្ងៃ',
            dd: '%d ថ្ងៃ',
            M: 'មួយខែ',
            MM: '%d ខែ',
            y: 'មួយឆ្នាំ',
            yy: '%d ឆ្នាំ'
        },
        dayOfMonthOrdinalParse : /ទី\d{1,2}/,
        ordinal : 'ទី%d',
        preparse: function (string) {
            return string.replace(/[១២៣៤៥៦៧៨៩០]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return km;

})));


/***/ }),

/***/ "eac5":
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "ebe4":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var ms = moment.defineLocale('ms', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            ss : '%d saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return ms;

})));


/***/ }),

/***/ "ec18":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's' : ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
            'ss': [number + 'sekundi', number + 'sekundit'],
            'm' : ['ühe minuti', 'üks minut'],
            'mm': [number + ' minuti', number + ' minutit'],
            'h' : ['ühe tunni', 'tund aega', 'üks tund'],
            'hh': [number + ' tunni', number + ' tundi'],
            'd' : ['ühe päeva', 'üks päev'],
            'M' : ['kuu aja', 'kuu aega', 'üks kuu'],
            'MM': [number + ' kuu', number + ' kuud'],
            'y' : ['ühe aasta', 'aasta', 'üks aasta'],
            'yy': [number + ' aasta', number + ' aastat']
        };
        if (withoutSuffix) {
            return format[key][2] ? format[key][2] : format[key][1];
        }
        return isFuture ? format[key][0] : format[key][1];
    }

    var et = moment.defineLocale('et', {
        months        : 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
        monthsShort   : 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
        weekdays      : 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split('_'),
        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
        longDateFormat : {
            LT   : 'H:mm',
            LTS : 'H:mm:ss',
            L    : 'DD.MM.YYYY',
            LL   : 'D. MMMM YYYY',
            LLL  : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[Täna,] LT',
            nextDay  : '[Homme,] LT',
            nextWeek : '[Järgmine] dddd LT',
            lastDay  : '[Eile,] LT',
            lastWeek : '[Eelmine] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s pärast',
            past   : '%s tagasi',
            s      : processRelativeTime,
            ss     : processRelativeTime,
            m      : processRelativeTime,
            mm     : processRelativeTime,
            h      : processRelativeTime,
            hh     : processRelativeTime,
            d      : processRelativeTime,
            dd     : '%d päeva',
            M      : processRelativeTime,
            MM     : processRelativeTime,
            y      : processRelativeTime,
            yy     : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return et;

})));


/***/ }),

/***/ "ec69":
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__("6fcd"),
    baseKeys = __webpack_require__("03dd"),
    isArrayLike = __webpack_require__("30c9");

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ "ec8c":
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ "eda5":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    /*jshint -W100*/
    var si = moment.defineLocale('si', {
        months : 'ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්'.split('_'),
        monthsShort : 'ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ'.split('_'),
        weekdays : 'ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා'.split('_'),
        weekdaysShort : 'ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන'.split('_'),
        weekdaysMin : 'ඉ_ස_අ_බ_බ්‍ර_සි_සෙ'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'a h:mm',
            LTS : 'a h:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYY MMMM D',
            LLL : 'YYYY MMMM D, a h:mm',
            LLLL : 'YYYY MMMM D [වැනි] dddd, a h:mm:ss'
        },
        calendar : {
            sameDay : '[අද] LT[ට]',
            nextDay : '[හෙට] LT[ට]',
            nextWeek : 'dddd LT[ට]',
            lastDay : '[ඊයේ] LT[ට]',
            lastWeek : '[පසුගිය] dddd LT[ට]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%sකින්',
            past : '%sකට පෙර',
            s : 'තත්පර කිහිපය',
            ss : 'තත්පර %d',
            m : 'මිනිත්තුව',
            mm : 'මිනිත්තු %d',
            h : 'පැය',
            hh : 'පැය %d',
            d : 'දිනය',
            dd : 'දින %d',
            M : 'මාසය',
            MM : 'මාස %d',
            y : 'වසර',
            yy : 'වසර %d'
        },
        dayOfMonthOrdinalParse: /\d{1,2} වැනි/,
        ordinal : function (number) {
            return number + ' වැනි';
        },
        meridiemParse : /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
        isPM : function (input) {
            return input === 'ප.ව.' || input === 'පස් වරු';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'ප.ව.' : 'පස් වරු';
            } else {
                return isLower ? 'පෙ.ව.' : 'පෙර වරු';
            }
        }
    });

    return si;

})));


/***/ }),

/***/ "edfa":
/***/ (function(module, exports) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ "ef5d":
/***/ (function(module, exports) {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),

/***/ "efb6":
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__("5e2e");

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ "f260":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var pt = moment.defineLocale('pt', {
        months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
        weekdaysMin : 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY HH:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Hoje às] LT',
            nextDay: '[Amanhã às] LT',
            nextWeek: 'dddd [às] LT',
            lastDay: '[Ontem às] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[Último] dddd [às] LT' : // Saturday + Sunday
                    '[Última] dddd [às] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : 'há %s',
            s : 'segundos',
            ss : '%d segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um mês',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal : '%dº',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return pt;

})));


/***/ }),

/***/ "f3c1":
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),

/***/ "f3ff":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '੧',
        '2': '੨',
        '3': '੩',
        '4': '੪',
        '5': '੫',
        '6': '੬',
        '7': '੭',
        '8': '੮',
        '9': '੯',
        '0': '੦'
    },
    numberMap = {
        '੧': '1',
        '੨': '2',
        '੩': '3',
        '੪': '4',
        '੫': '5',
        '੬': '6',
        '੭': '7',
        '੮': '8',
        '੯': '9',
        '੦': '0'
    };

    var paIn = moment.defineLocale('pa-in', {
        // There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
        months : 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
        monthsShort : 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
        weekdays : 'ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ'.split('_'),
        weekdaysShort : 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
        weekdaysMin : 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ਵਜੇ',
            LTS : 'A h:mm:ss ਵਜੇ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ਵਜੇ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm ਵਜੇ'
        },
        calendar : {
            sameDay : '[ਅਜ] LT',
            nextDay : '[ਕਲ] LT',
            nextWeek : '[ਅਗਲਾ] dddd, LT',
            lastDay : '[ਕਲ] LT',
            lastWeek : '[ਪਿਛਲੇ] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ਵਿੱਚ',
            past : '%s ਪਿਛਲੇ',
            s : 'ਕੁਝ ਸਕਿੰਟ',
            ss : '%d ਸਕਿੰਟ',
            m : 'ਇਕ ਮਿੰਟ',
            mm : '%d ਮਿੰਟ',
            h : 'ਇੱਕ ਘੰਟਾ',
            hh : '%d ਘੰਟੇ',
            d : 'ਇੱਕ ਦਿਨ',
            dd : '%d ਦਿਨ',
            M : 'ਇੱਕ ਮਹੀਨਾ',
            MM : '%d ਮਹੀਨੇ',
            y : 'ਇੱਕ ਸਾਲ',
            yy : '%d ਸਾਲ'
        },
        preparse: function (string) {
            return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
        meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ਰਾਤ') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'ਸਵੇਰ') {
                return hour;
            } else if (meridiem === 'ਦੁਪਹਿਰ') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'ਸ਼ਾਮ') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ਰਾਤ';
            } else if (hour < 10) {
                return 'ਸਵੇਰ';
            } else if (hour < 17) {
                return 'ਦੁਪਹਿਰ';
            } else if (hour < 20) {
                return 'ਸ਼ਾਮ';
            } else {
                return 'ਰਾਤ';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return paIn;

})));


/***/ }),

/***/ "f4d6":
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__("ffd6");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ "f608":
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__("6747"),
    isSymbol = __webpack_require__("ffd6");

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ "f6b4":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var months = [
        'Am Faoilleach', 'An Gearran', 'Am Màrt', 'An Giblean', 'An Cèitean', 'An t-Ògmhios', 'An t-Iuchar', 'An Lùnastal', 'An t-Sultain', 'An Dàmhair', 'An t-Samhain', 'An Dùbhlachd'
    ];

    var monthsShort = ['Faoi', 'Gear', 'Màrt', 'Gibl', 'Cèit', 'Ògmh', 'Iuch', 'Lùn', 'Sult', 'Dàmh', 'Samh', 'Dùbh'];

    var weekdays = ['Didòmhnaich', 'Diluain', 'Dimàirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

    var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

    var weekdaysMin = ['Dò', 'Lu', 'Mà', 'Ci', 'Ar', 'Ha', 'Sa'];

    var gd = moment.defineLocale('gd', {
        months : months,
        monthsShort : monthsShort,
        monthsParseExact : true,
        weekdays : weekdays,
        weekdaysShort : weekdaysShort,
        weekdaysMin : weekdaysMin,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[An-diugh aig] LT',
            nextDay : '[A-màireach aig] LT',
            nextWeek : 'dddd [aig] LT',
            lastDay : '[An-dè aig] LT',
            lastWeek : 'dddd [seo chaidh] [aig] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ann an %s',
            past : 'bho chionn %s',
            s : 'beagan diogan',
            ss : '%d diogan',
            m : 'mionaid',
            mm : '%d mionaidean',
            h : 'uair',
            hh : '%d uairean',
            d : 'latha',
            dd : '%d latha',
            M : 'mìos',
            MM : '%d mìosan',
            y : 'bliadhna',
            yy : '%d bliadhna'
        },
        dayOfMonthOrdinalParse : /\d{1,2}(d|na|mh)/,
        ordinal : function (number) {
            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return gd;

})));


/***/ }),

/***/ "f772":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "f8af":
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__("2474");

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ "f9ce":
/***/ (function(module, exports, __webpack_require__) {

var baseProperty = __webpack_require__("ef5d"),
    basePropertyDeep = __webpack_require__("e3f8"),
    isKey = __webpack_require__("f608"),
    toKey = __webpack_require__("f4d6");

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),

/***/ "fa21":
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__("7530"),
    getPrototype = __webpack_require__("2dcb"),
    isPrototype = __webpack_require__("eac5");

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ "facd":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
    var monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

    var nl = moment.defineLocale('nl', {
        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },

        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,

        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'over %s',
            past : '%s geleden',
            s : 'een paar seconden',
            ss : '%d seconden',
            m : 'één minuut',
            mm : '%d minuten',
            h : 'één uur',
            hh : '%d uur',
            d : 'één dag',
            dd : '%d dagen',
            M : 'één maand',
            MM : '%d maanden',
            y : 'één jaar',
            yy : '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nl;

})));


/***/ }),

/***/ "fb15":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "Button", function() { return /* reexport */ components_button; });
__webpack_require__.d(__webpack_exports__, "Affix", function() { return /* reexport */ components_affix; });
__webpack_require__.d(__webpack_exports__, "Tree", function() { return /* reexport */ components_tree; });
__webpack_require__.d(__webpack_exports__, "Cascader", function() { return /* reexport */ components_cascader; });
__webpack_require__.d(__webpack_exports__, "Calendar", function() { return /* reexport */ components_calendar; });
__webpack_require__.d(__webpack_exports__, "Select", function() { return /* reexport */ components_select; });
__webpack_require__.d(__webpack_exports__, "Card", function() { return /* reexport */ components_card; });
__webpack_require__.d(__webpack_exports__, "Dropdown", function() { return /* reexport */ components_dropdown; });
__webpack_require__.d(__webpack_exports__, "Breadcrumb", function() { return /* reexport */ components_breadcrumb; });
__webpack_require__.d(__webpack_exports__, "Checkbox", function() { return /* reexport */ components_checkbox; });
__webpack_require__.d(__webpack_exports__, "DatePicker", function() { return /* reexport */ date_picker; });
__webpack_require__.d(__webpack_exports__, "Grid", function() { return /* reexport */ components_grid; });
__webpack_require__.d(__webpack_exports__, "Layout", function() { return /* reexport */ components_layout; });
__webpack_require__.d(__webpack_exports__, "Icon", function() { return /* reexport */ components_icon; });
__webpack_require__.d(__webpack_exports__, "Input", function() { return /* reexport */ components_input; });
__webpack_require__.d(__webpack_exports__, "Menu", function() { return /* reexport */ components_menu; });
__webpack_require__.d(__webpack_exports__, "Modal", function() { return /* reexport */ components_modal; });
__webpack_require__.d(__webpack_exports__, "Pagination", function() { return /* reexport */ components_pagination; });
__webpack_require__.d(__webpack_exports__, "Progress", function() { return /* reexport */ components_progress; });
__webpack_require__.d(__webpack_exports__, "Radio", function() { return /* reexport */ components_radio; });
__webpack_require__.d(__webpack_exports__, "Switch", function() { return /* reexport */ components_switch; });
__webpack_require__.d(__webpack_exports__, "Tabs", function() { return /* reexport */ components_tabs; });
__webpack_require__.d(__webpack_exports__, "Tag", function() { return /* reexport */ components_tag; });
__webpack_require__.d(__webpack_exports__, "Upload", function() { return /* reexport */ components_upload; });

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (true) {
    var getCurrentScript = __webpack_require__("8875")
    currentScript = getCurrentScript()

    // for backward compatibility, because previously we directly included the polyfill
    if (!('currentScript' in document)) {
      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })
    }
  }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");

// EXTERNAL MODULE: ./node_modules/babel-runtime/helpers/extends.js
var helpers_extends = __webpack_require__("41b2");
var extends_default = /*#__PURE__*/__webpack_require__.n(helpers_extends);

// EXTERNAL MODULE: ./src/libs/icons-vue/utils.ts
var utils = __webpack_require__("78ce");

// CONCATENATED MODULE: ./src/libs/icons-vue/components/Icon.ts



var defaultTwoToneColorPalette = {
  primaryColor: '#333',
  secondaryColor: '#E6E6E6'
};
var Icon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AntdIcon',
  props: ['type', 'primaryColor', 'secondaryColor'],
  displayName: 'IconVue',
  definitions: new utils["a" /* MiniMap */](),
  setup: function setup() {
    var twoToneColorPalette = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(defaultTwoToneColorPalette);
    return {
      twoToneColorPalette: twoToneColorPalette
    };
  },
  add: function add() {
    for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {
      names[_key] = arguments[_key];
    }

    names.forEach(function (icon) {
      Icon.definitions.set(Object(utils["f" /* withSuffix */])(icon.name, icon.theme), icon);
    });
  },
  clear: function clear() {
    Icon.definitions.clear();
  },
  get: function get(key) {
    var colors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultTwoToneColorPalette;

    if (key) {
      var target = Icon.definitions.get(key);

      if (target && typeof target.icon === 'function') {
        target = extends_default()({}, target, {
          icon: target.icon(colors.primaryColor, colors.secondaryColor)
        });
      }

      return target;
    }
  },
  setTwoToneColors: function setTwoToneColors(_ref) {
    var primaryColor = _ref.primaryColor;
    var secondaryColor = _ref.secondaryColor;
    defaultTwoToneColorPalette.primaryColor = primaryColor;
    defaultTwoToneColorPalette.secondaryColor = secondaryColor || Object(utils["c" /* getSecondaryColor */])(primaryColor);
  },
  getTwoToneColors: function getTwoToneColors() {
    return extends_default()({}, defaultTwoToneColorPalette);
  },
  render: function render() {
    var _$props = this.$props;
    var type = _$props.type;
    var primaryColor = _$props.primaryColor;
    var secondaryColor = _$props.secondaryColor;
    var target = void 0;
    var colors = defaultTwoToneColorPalette;

    if (primaryColor) {
      colors = {
        primaryColor: primaryColor,
        secondaryColor: secondaryColor || Object(utils["c" /* getSecondaryColor */])(primaryColor)
      };
    }

    if (Object(utils["d" /* isIconDefinition */])(type)) {
      target = type;
    } else if (typeof type === 'string') {
      target = Icon.get(type, colors);

      if (!target) {
        // log(`Could not find icon: ${type}`);
        return null;
      }
    }

    if (!target) {
      Object(utils["e" /* log */])('type should be string or icon definiton, but got ' + type);
      return null;
    }

    if (target && typeof target.icon === 'function') {
      target = extends_default()({}, target, {
        icon: target.icon(colors.primaryColor, colors.secondaryColor)
      });
    }

    return Object(utils["b" /* generate */])(target.icon, 'svg-' + target.name, {
      'data-icon': target.name,
      width: '1em',
      height: '1em',
      fill: 'currentColor',
      'aria-hidden': 'true'
    });
  }
});
/* istanbul ignore next */

Icon.install = function (Vue) {
  Vue.component(Icon.name, Icon);
};

/* harmony default export */ var components_Icon = (Icon);
// CONCATENATED MODULE: ./src/libs/icons-vue/index.ts


/* harmony default export */ var icons_vue = (components_Icon);
// EXTERNAL MODULE: ./node_modules/moment/moment.js
var moment = __webpack_require__("c1df");
var moment_default = /*#__PURE__*/__webpack_require__.n(moment);

// CONCATENATED MODULE: ./src/components/moment-zh_CN.ts

/* harmony default export */ var moment_zh_CN = (window.moment && window.moment.defineLocale('zh-cn', {
  months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
  monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
  weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
  weekdaysShort: '周日_周一_周二_周三_周四_周五_周六'.split('_'),
  weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
  longDateFormat: {
    LT: 'HH:mm',
    LTS: 'HH:mm:ss',
    L: 'YYYY/MM/DD',
    LL: 'YYYY年M月D日',
    LLL: 'YYYY年M月D日Ah点mm分',
    LLLL: 'YYYY年M月D日ddddAh点mm分',
    l: 'YYYY/M/D',
    ll: 'YYYY年M月D日',
    lll: 'YYYY年M月D日 HH:mm',
    llll: 'YYYY年M月D日dddd HH:mm'
  },
  meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
  meridiemHour: function meridiemHour(hour, meridiem) {
    var copyHour = hour;

    if (copyHour === 12) {
      copyHour = 0;
    }

    if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
      return copyHour;
    } else if (meridiem === '下午' || meridiem === '晚上') {
      return copyHour + 12;
    } else {
      // '中午'
      return copyHour >= 11 ? copyHour : copyHour + 12;
    }
  },
  meridiem: function meridiem(hour, minute, isLower) {
    var hm = hour * 100 + minute;

    if (hm < 600) {
      return '凌晨';
    } else if (hm < 900) {
      return '早上';
    } else if (hm < 1130) {
      return '上午';
    } else if (hm < 1230) {
      return '中午';
    } else if (hm < 1800) {
      return '下午';
    } else {
      return '晚上';
    }
  },
  calendar: {
    sameDay: '[今天]LT',
    nextDay: '[明天]LT',
    nextWeek: '[下]ddddLT',
    lastDay: '[昨天]LT',
    lastWeek: '[上]ddddLT',
    sameElse: 'L'
  },
  dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/,
  ordinal: function ordinal(number, period) {
    switch (period) {
      case 'd':
      case 'D':
      case 'DDD':
        return number + '日';

      case 'M':
        return number + '月';

      case 'w':
      case 'W':
        return number + '周';

      default:
        return number;
    }
  },
  relativeTime: {
    future: '%s内',
    past: '%s前',
    s: '几秒',
    ss: '%d 秒',
    m: '1 分钟',
    mm: '%d 分钟',
    h: '1 小时',
    hh: '%d 小时',
    d: '1 天',
    dd: '%d 天',
    M: '1 个月',
    MM: '%d 个月',
    y: '1 年',
    yy: '%d 年'
  },
  week: {
    // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
    dow: 1,
    doy: 4 // The week that contains Jan 4th is the first week of the year.

  }
}));
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__("9523");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__("278c");
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__("7037");
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ./node_modules/lodash/isPlainObject.js
var isPlainObject = __webpack_require__("60ed");
var isPlainObject_default = /*#__PURE__*/__webpack_require__.n(isPlainObject);

// CONCATENATED MODULE: ./src/components/_util/props-util.ts





function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

var camelizeRE = /-(\w)/g;

var camelize = function camelize(str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
};

var parseStyleText = function parseStyleText() {
  var cssText = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var camel = arguments.length > 1 ? arguments[1] : undefined;
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);

      if (tmp.length > 1) {
        var k = camel ? camelize(tmp[0].trim()) : tmp[0].trim();
        res[k] = tmp[1].trim();
      }
    }
  });
  return res;
};

var hasProp = function hasProp(instance, prop) {
  return prop in instance.props;
};

var slotHasProp = function slotHasProp(slot, prop) {
  var $options = slot.componentOptions || {};
  var propsData = $options.propsData || {};
  return prop in propsData;
};

var filterProps = function filterProps(props) {
  var propsData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var res = {};
  Object.keys(props).forEach(function (k) {
    if (k in propsData || props[k] !== undefined) {
      res[k] = props[k];
    }
  });
  return res;
};

var getSlotsFromInstance = function getSlotsFromInstance(instance) {
  return instance.slots;
};

var getSlots = function getSlots(ele) {
  if (typeof ele.children === 'string' || Array.isArray(ele.children)) {
    return {
      "default": function _default() {
        return ele.children;
      }
    };
  } else {
    return ele.children;
  }
};

var getAllChildren = function getAllChildren(ele) {
  var componentOptions = ele.componentOptions || {};

  if (ele.$vnode) {
    componentOptions = ele.$vnode.componentOptions || {};
  }

  return ele.children || componentOptions.children || [];
};

var getSlotOptions = function getSlotOptions(ele) {
  if (ele.fnOptions) {
    // 函数式组件
    return ele.fnOptions;
  }

  var componentOptions = ele.componentOptions;

  if (ele.$vnode) {
    componentOptions = ele.$vnode.componentOptions;
  }

  return componentOptions ? componentOptions.Ctor.options || {} : {};
};

var getOptionProps = function getOptionProps(instance) {
  return instance.props;
};

var getComponentFromContext = function getComponentFromContext(context, prop) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : context;
  var execute = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var temp = context.$props[prop];

  if (temp !== undefined) {
    return typeof temp === 'function' && execute ? temp(options) : temp;
  }

  return context.$slots[prop] && execute && context.$slots[prop](options) || context.$slots[prop] || undefined;
};

var props_util_getComponentFromProp = function getComponentFromProp(instance, prop) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : instance;
  var execute = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  if (!instance) {
    return undefined;
  }

  if (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["isVNode"])(instance)) {
    var propOrSlot = instance.props[prop] || instance.children[prop];

    if (typeof propOrSlot === 'function') {
      return propOrSlot();
    }

    return propOrSlot;
  } else {
    var temp = instance.props[prop];

    if (temp !== undefined) {
      return typeof temp === 'function' && execute ? temp(options) : temp;
    }

    return instance.slots[prop] && execute && instance.slots[prop](options) || instance.slots[prop] || undefined;
  }
};

var getAllProps = function getAllProps(ele) {
  var data = ele.data || {};
  var componentOptions = ele.componentOptions || {};

  if (ele.$vnode) {
    data = ele.$vnode.data || {};
    componentOptions = ele.$vnode.componentOptions || {};
  }

  return Object.assign(Object.assign(Object.assign({}, data.props), data.attrs), componentOptions.propsData);
};

var getPropsData = function getPropsData(ele) {
  var componentOptions = ele.componentOptions;

  if (ele.$vnode) {
    componentOptions = ele.$vnode.componentOptions;
  }

  return componentOptions ? componentOptions.propsData || {} : {};
};

var getValueByProp = function getValueByProp(ele, prop) {
  return getPropsData(ele)[prop];
};

var getAttrs = function getAttrs(ele) {
  return ele.props;
};

var getKey = function getKey(ele) {
  var key = ele.key;

  if (ele.$vnode) {
    key = ele.$vnode.key;
  }

  return key;
}; // use getListeners instead this.$listeners
// https://github.com/vueComponent/ant-design-vue/issues/1705


function getListenersFromInstance(instance) {
  var context = Object.assign(Object.assign({}, instance.props), instance.attrs);
  return getListenersFromProps(context);
}
function getListenersFromContext(ctx) {
  return getListenersFromProps(Object.assign(Object.assign({}, ctx.$props), ctx.$attrs));
}
function getListenersFromVNode(node) {
  if (node && node.props) {
    return getListenersFromProps(node.props);
  }

  return {};
}
function getListenersFromProps(context) {
  var keys = Object.keys(context);
  var listeners = {};
  keys.forEach(function (key) {
    if (/^on[A-Z]+/.test(key)) {
      listeners[key] = context[key];
    }
  });
  return listeners;
}
function getClassFromInstance(instance) {
  return instance.attrs["class"];
}
function getClassFromContext(ctx) {
  return ctx.$attrs["class"];
}
function getClassFromVNode(ele) {
  return ele.props["class"];
}
function getStyleFromContext(instance) {
  return instance.$attrs.style;
}
function getStyleFromInstance(ele) {
  return ele.attrs.style;
}
function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}
function isEmptyElement(c) {
  return !(c.type || c.children && c.children.length !== 0);
}
function isStringElement(c) {
  return !c.tag;
}
function unwrapFragment(node) {
  if (!node) {
    return undefined;
  }

  if (Array.isArray(node)) {
    if (node.length > 1 || node.length === 0) {
      return node;
    }

    var onlyNode = node[0];

    if (Array.isArray(onlyNode)) {
      return unwrapFragment(onlyNode);
    }

    if (!isFragment(onlyNode)) {
      return node;
    }
  }

  if (Array.isArray(node)) {
    if (node.length === 1 && isFragment(node[0])) {
      return unwrapFragment(node[0].children);
    }

    return node;
  } else if (isFragment(node)) {
    return unwrapFragment(node.children);
  }

  return unwrapFragment([node]);
}
function isFragment(node) {
  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["isVNode"])(node) && typeof_default()(node.type) === 'symbol' && node.type.description === 'Fragment';
}
function filterEmpty(children) {
  if (children === undefined || children === null) {
    return [];
  }

  var items;

  if (Array.isArray(children)) {
    items = children;
  } else if (typeof children === 'function') {
    items = children();
  }

  if (items.length === 1 && isFragment(items[0])) {
    items = items[0].children;
  } // if (items.length === 1 && items[0].type === FRAGMENT)


  return items.filter(function (c) {
    return !isEmptyElement(c);
  });
}

var initDefaultProps = function initDefaultProps(propTypes, defaultProps) {
  Object.keys(defaultProps).forEach(function (k) {
    if (propTypes[k]) {
      propTypes[k].def && (propTypes[k] = propTypes[k].def(defaultProps[k]));
    } else {
      throw new Error("not have ".concat(k, " prop"));
    }
  });
  return propTypes;
};

function mergeProps() {
  var props = {};

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  args.forEach(function () {
    var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    for (var _i = 0, _Object$entries = Object.entries(p); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = slicedToArray_default()(_Object$entries[_i], 2),
          k = _Object$entries$_i[0],
          v = _Object$entries$_i[1];

      props[k] = props[k] || {};

      if (isPlainObject_default()(v)) {
        Object.assign(props[k], v);
      } else {
        props[k] = v;
      }
    }
  });
  return props;
}

function isValidElement(element) {
  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["isVNode"])(element);
}


/* harmony default export */ var props_util = (hasProp);
// EXTERNAL MODULE: ./node_modules/vue-ref/index.js
var vue_ref = __webpack_require__("46cf");
var vue_ref_default = /*#__PURE__*/__webpack_require__.n(vue_ref);

// CONCATENATED MODULE: ./src/components/_util/ant-directive.ts


/* harmony default export */ var ant_directive = ({
  install: function install(app) {
    app.use(vue_ref_default.a, {
      name: 'ant-ref'
    });
  }
});
// CONCATENATED MODULE: ./src/components/base/index.ts


/* harmony default export */ var base = ({
  install: function install(app) {
    app.use(ant_directive);
  }
});
// CONCATENATED MODULE: ./src/components/_util/interop-default.ts

// https://github.com/moment/moment/issues/3650
function interopDefault(m) {
  return m["default"] || m;
}
// CONCATENATED MODULE: ./src/components/_util/vue-types/utils.ts


var ObjProto = Object.prototype;
var utils_toString = ObjProto.toString;
var hasOwn = ObjProto.hasOwnProperty;
var FN_MATCH_REGEXP = /^\s*function (\w+)/; // https://github.com/vuejs/vue/blob/dev/src/core/util/props.js#L159

var utils_getType = function getType(fn) {
  var type = fn !== null && fn !== undefined ? fn.type ? fn.type : fn : null;
  var match = type && type.toString().match(FN_MATCH_REGEXP);
  return match && match[1];
};
var getNativeType = function getNativeType(value) {
  if (value === null || value === undefined) {
    return null;
  }

  var match = value.constructor.toString().match(FN_MATCH_REGEXP);
  return match && match[1];
};
/**
 * No-op function
 */

var noop = function noop() {};
/**
 * Checks for a own property in an object
 *
 * @param {object} obj - Object
 * @param {string} prop - Property to check
 */

var utils_has = function has(obj, prop) {
  return hasOwn.call(obj, prop);
};
/**
 * Determines whether the passed value is an integer. Uses `Number.isInteger` if available
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
 * @param {*} value - The value to be tested for being an integer.
 * @returns {boolean}
 */

var isInteger = Number.isInteger || function (value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
};
/**
 * Determines whether the passed value is an Array.
 *
 * @param {*} value - The value to be tested for being an array.
 * @returns {boolean}
 */

var isArray = Array.isArray || function (value) {
  return utils_toString.call(value) === '[object Array]';
};
/**
 * Checks if a value is a function
 *
 * @param {any} value - Value to check
 * @returns {boolean}
 */

var isFunction = function isFunction(value) {
  return utils_toString.call(value) === '[object Function]';
};
/**
 * Adds a `def` method to the object returning a new object with passed in argument as `default` property
 *
 * @param {object} type - Object to enhance
 */

var utils_withDefault = function withDefault(type) {
  Object.defineProperty(type, 'def', {
    value: function value(def) {
      if (def === undefined && this["default"] === undefined) {
        this["default"] = undefined;
        return this;
      }

      if (!isFunction(def) && !utils_validateType(this, def)) {
        warn("".concat(this._vueTypes_name, " - invalid default value: \"").concat(def, "\""), def);
        return this;
      }

      this["default"] = isArray(def) || isPlainObject_default()(def) ? function () {
        return def;
      } : def;
      return this;
    },
    enumerable: false,
    writable: false
  });
};
/**
 * Adds a `isRequired` getter returning a new object with `required: true` key-value
 *
 * @param {object} type - Object to enhance
 */

var withRequired = function withRequired(type) {
  Object.defineProperty(type, 'isRequired', {
    get: function get() {
      this.required = true;
      return this;
    },
    enumerable: false
  });
};
/**
 * Adds `isRequired` and `def` modifiers to an object
 *
 * @param {string} name - Type internal name
 * @param {object} obj - Object to enhance
 * @returns {object}
 */

var toType = function toType(name, obj) {
  Object.defineProperty(obj, '_vueTypes_name', {
    enumerable: false,
    writable: false,
    value: name
  });
  withRequired(obj);
  utils_withDefault(obj);

  if (isFunction(obj.validator)) {
    obj.validator = obj.validator.bind(obj);
  }

  return obj;
};
/**
 * Validates a given value against a prop type object
 *
 * @param {Object|*} type - Type to use for validation. Either a type object or a constructor
 * @param {*} value - Value to check
 * @param {boolean} silent - Silence warnings
 * @returns {boolean}
 */

var utils_validateType = function validateType(type, value) {
  var silent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var typeToCheck = type;
  var valid = true;
  var expectedType;

  if (!isPlainObject_default()(type)) {
    typeToCheck = {
      type: type
    };
  }

  var namePrefix = typeToCheck._vueTypes_name ? typeToCheck._vueTypes_name + ' - ' : '';

  if (hasOwn.call(typeToCheck, 'type') && typeToCheck.type !== null) {
    if (isArray(typeToCheck.type)) {
      valid = typeToCheck.type.some(function (type) {
        return validateType(type, value, true);
      });
      expectedType = typeToCheck.type.map(function (type) {
        return utils_getType(type);
      }).join(' or ');
    } else {
      expectedType = utils_getType(typeToCheck);

      if (expectedType === 'Array') {
        valid = isArray(value);
      } else if (expectedType === 'Object') {
        valid = isPlainObject_default()(value);
      } else if (expectedType === 'String' || expectedType === 'Number' || expectedType === 'Boolean' || expectedType === 'Function') {
        valid = getNativeType(value) === expectedType;
      } else {
        valid = value instanceof typeToCheck.type;
      }
    }
  }

  if (!valid) {
    silent === false && warn("".concat(namePrefix, "value \"").concat(value, "\" should be of type \"").concat(expectedType, "\""));
    return false;
  }

  if (hasOwn.call(typeToCheck, 'validator') && isFunction(typeToCheck.validator)) {
    valid = typeToCheck.validator(value);

    if (!valid && silent === false) {
      warn("".concat(namePrefix, "custom validation failed"));
    }

    return valid;
  }

  return valid;
};
var warn = noop;

if (false) { var hasConsole; }


// CONCATENATED MODULE: ./src/components/_util/vue-types/index.ts




var VuePropTypes = {
  get any() {
    return toType('any', {
      type: null
    });
  },

  get func() {
    return toType('function', {
      type: Function
    }).def(currentDefaults.func);
  },

  get bool() {
    return toType('boolean', {
      type: Boolean
    }).def(currentDefaults.bool);
  },

  get string() {
    return toType('string', {
      type: String
    }).def(currentDefaults.string);
  },

  get number() {
    return toType('number', {
      type: Number
    }).def(currentDefaults.number);
  },

  get array() {
    return toType('array', {
      type: Array
    }).def(currentDefaults.array);
  },

  get object() {
    return toType('object', {
      type: Object
    }).def(currentDefaults.object);
  },

  get integer() {
    return toType('integer', {
      type: Number,
      validator: function validator(value) {
        return isInteger(value);
      }
    }).def(currentDefaults.integer);
  },

  get symbol() {
    return toType('symbol', {
      type: null,
      validator: function validator(value) {
        return typeof_default()(value) === 'symbol';
      }
    });
  },

  custom: function custom(validatorFn) {
    var warnMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'custom validation failed';

    if (typeof validatorFn !== 'function') {
      throw new TypeError('[VueTypes error]: You must provide a function as argument');
    }

    return toType(validatorFn.name || '<<anonymous function>>', {
      validator: function validator() {
        var valid = validatorFn.apply(void 0, arguments);

        if (!valid) {
          warn("".concat(this._vueTypes_name, " - ").concat(warnMsg));
        }

        return valid;
      }
    });
  },
  oneOf: function oneOf(arr) {
    if (!isArray(arr)) {
      throw new TypeError('[VueTypes error]: You must provide an array as argument');
    }

    var msg = "oneOf - value should be one of \"".concat(arr.join('", "'), "\"");
    var allowedTypes = arr.reduce(function (ret, v) {
      if (v !== null && v !== undefined) {
        ret.indexOf(v.constructor) === -1 && ret.push(v.constructor);
      }

      return ret;
    }, []);
    return toType('oneOf', {
      type: allowedTypes.length > 0 ? allowedTypes : null,
      validator: function validator(value) {
        var valid = arr.indexOf(value) !== -1;

        if (!valid) {
          warn(msg);
        }

        return valid;
      }
    });
  },
  instanceOf: function instanceOf(instanceConstructor) {
    return toType('instanceOf', {
      type: instanceConstructor
    });
  },
  oneOfType: function oneOfType(arr) {
    if (!isArray(arr)) {
      throw new TypeError('[VueTypes error]: You must provide an array as argument');
    }

    var hasCustomValidators = false;
    var nativeChecks = arr.reduce(function (ret, type) {
      if (isPlainObject_default()(type)) {
        if (type._vueTypes_name === 'oneOf') {
          return ret.concat(type.type || []);
        }

        if (type.type && !isFunction(type.validator)) {
          if (isArray(type.type)) {
            return ret.concat(type.type);
          }

          ret.push(type.type);
        } else if (isFunction(type.validator)) {
          hasCustomValidators = true;
        }

        return ret;
      }

      ret.push(type);
      return ret;
    }, []);

    if (!hasCustomValidators) {
      // we got just native objects (ie: Array, Object)
      // delegate to Vue native prop check
      return toType('oneOfType', {
        type: nativeChecks
      }).def(undefined);
    }

    var typesStr = arr.map(function (type) {
      if (type && isArray(type.type)) {
        return type.type.map(utils_getType);
      }

      return utils_getType(type);
    }).reduce(function (ret, type) {
      return ret.concat(isArray(type) ? type : [type]);
    }, []).join('", "');
    return this.custom(function oneOfType(value) {
      var valid = arr.some(function (type) {
        if (type._vueTypes_name === 'oneOf') {
          return type.type ? utils_validateType(type.type, value, true) : true;
        }

        return utils_validateType(type, value, true);
      });

      if (!valid) {
        warn("oneOfType - value type should be one of \"".concat(typesStr, "\""));
      }

      return valid;
    }).def(undefined);
  },
  arrayOf: function arrayOf(type) {
    return toType('arrayOf', {
      type: Array,
      validator: function validator(values) {
        var valid = values.every(function (value) {
          return utils_validateType(type, value);
        });

        if (!valid) {
          warn("arrayOf - value must be an array of \"".concat(utils_getType(type), "\""));
        }

        return valid;
      }
    });
  },
  objectOf: function objectOf(type) {
    return toType('objectOf', {
      type: Object,
      validator: function validator(obj) {
        var valid = Object.keys(obj).every(function (key) {
          return utils_validateType(type, obj[key]);
        });

        if (!valid) {
          warn("objectOf - value must be an object of \"".concat(utils_getType(type), "\""));
        }

        return valid;
      }
    });
  },
  shape: function shape(obj) {
    var keys = Object.keys(obj);
    var requiredKeys = keys.filter(function (key) {
      return obj[key] && obj[key].required === true;
    });
    var type = toType('shape', {
      type: Object,
      validator: function validator(value) {
        var _this = this;

        if (!isPlainObject_default()(value)) {
          return false;
        }

        var valueKeys = Object.keys(value); // check for required keys (if any)

        if (requiredKeys.length > 0 && requiredKeys.some(function (req) {
          return valueKeys.indexOf(req) === -1;
        })) {
          warn("shape - at least one of required properties \"".concat(requiredKeys.join('", "'), "\" is not present"));
          return false;
        }

        return valueKeys.every(function (key) {
          if (keys.indexOf(key) === -1) {
            if (_this._vueTypes_isLoose === true) {
              return true;
            }

            warn("shape - object is missing \"".concat(key, "\" property"));
            return false;
          }

          var type = obj[key];
          return utils_validateType(type, value[key]);
        });
      }
    });
    Object.defineProperty(type, '_vueTypes_isLoose', {
      enumerable: false,
      writable: true,
      value: false
    });
    Object.defineProperty(type, 'loose', {
      get: function get() {
        this._vueTypes_isLoose = true;
        return this;
      },
      enumerable: false
    });
    return type;
  }
};

var typeDefaults = function typeDefaults() {
  return {
    func: undefined,
    bool: undefined,
    string: undefined,
    number: undefined,
    array: undefined,
    object: undefined,
    integer: undefined
  };
};

var currentDefaults = typeDefaults();
Object.defineProperty(VuePropTypes, 'sensibleDefaults', {
  enumerable: false,
  set: function set(value) {
    if (value === false) {
      currentDefaults = {};
    } else if (value === true) {
      currentDefaults = typeDefaults();
    } else if (isPlainObject_default()(value)) {
      currentDefaults = value;
    }
  },
  get: function get() {
    return currentDefaults;
  }
});
/* harmony default export */ var vue_types = (VuePropTypes);
// CONCATENATED MODULE: ./src/components/vc-util/warning.js


/* eslint-disable no-console */
var warned = {};
function warning_warning(valid, message) {
  // Support uglify
  if (false) {}
}
function note(valid, message) {
  // Support uglify
  if (false) {}
}
function resetWarned() {
  warned = {};
}
function call(method, valid, message) {
  if (!valid && !warned[message]) {
    method(false, message);
    warned[message] = true;
  }
}
function warningOnce(valid, message) {
  call(warning_warning, valid, message);
}
function noteOnce(valid, message) {
  call(note, valid, message);
}
/* harmony default export */ var vc_util_warning = (warningOnce);
/* eslint-enable */
// CONCATENATED MODULE: ./src/components/_util/warning.ts



/* harmony default export */ var _util_warning = (function (valid, component) {
  var message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  vc_util_warning(valid, "[antdv: ".concat(component, "] ").concat(message));
});
// CONCATENATED MODULE: ./src/components/vc-calendar/src/locale/zh_CN.js

/* harmony default export */ var zh_CN = ({
  today: '今天',
  now: '此刻',
  backToToday: '返回今天',
  ok: '确定',
  timeSelect: '选择时间',
  dateSelect: '选择日期',
  weekSelect: '选择周',
  clear: '清除',
  month: '月',
  year: '年',
  previousMonth: '上个月 (翻页上键)',
  nextMonth: '下个月 (翻页下键)',
  monthSelect: '选择月份',
  yearSelect: '选择年份',
  decadeSelect: '选择年代',
  yearFormat: 'YYYY年',
  dayFormat: 'D日',
  dateFormat: 'YYYY年M月D日',
  dateTimeFormat: 'YYYY年M月D日 HH时mm分ss秒',
  previousYear: '上一年 (Control键加左方向键)',
  nextYear: '下一年 (Control键加右方向键)',
  previousDecade: '上一年代',
  nextDecade: '下一年代',
  previousCentury: '上一世纪',
  nextCentury: '下一世纪'
});
// CONCATENATED MODULE: ./src/components/time-picker/locale/zh_CN.ts

var zh_CN_locale = {
  placeholder: '请选择时间'
};
/* harmony default export */ var locale_zh_CN = (zh_CN_locale);
// CONCATENATED MODULE: ./src/components/date-picker/locale/zh_CN.js



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



var locale_zh_CN_locale = {
  lang: _objectSpread({
    placeholder: '请选择日期',
    rangePlaceholder: ['开始日期', '结束日期']
  }, zh_CN),
  timePickerLocale: _objectSpread({}, locale_zh_CN)
}; // should add whitespace between char in Button

locale_zh_CN_locale.lang.ok = '确 定'; // All settings at:
// https://github.com/ant-design/ant-design/blob/master/components/date-picker/locale/example.json

/* harmony default export */ var date_picker_locale_zh_CN = (locale_zh_CN_locale);
// CONCATENATED MODULE: ./src/components/calendar/locale/zh_CN.js


/* harmony default export */ var calendar_locale_zh_CN = (date_picker_locale_zh_CN);
// CONCATENATED MODULE: ./src/components/vc-pagination/locale/zh_CN.ts

/* harmony default export */ var vc_pagination_locale_zh_CN = ({
  // Options.jsx
  items_per_page: '条/页',
  jump_to: '跳至',
  jump_to_confirm: '确定',
  page: '页',
  // Pagination.jsx
  prev_page: '上一页',
  next_page: '下一页',
  prev_5: '向前 5 页',
  next_5: '向后 5 页',
  prev_3: '向前 3 页',
  next_3: '向后 3 页'
});
// CONCATENATED MODULE: ./src/components/locale/default.ts





var local = {
  locale: 'en',
  Pagination: vc_pagination_locale_zh_CN,
  DatePicker: date_picker_locale_zh_CN,
  TimePicker: locale_zh_CN,
  Calendar: calendar_locale_zh_CN,
  global: {
    placeholder: '请选择'
  },
  Table: {
    filterTitle: '筛选',
    filterConfirm: '确定',
    filterReset: '重置',
    selectAll: '全选当页',
    selectInvert: '反选当页',
    sortTitle: '排序',
    expand: '展开行',
    collapse: '关闭行'
  },
  Modal: {
    okText: '确定',
    cancelText: '取消',
    justOkText: '知道了'
  },
  Popconfirm: {
    cancelText: '取消',
    okText: '确定'
  },
  Transfer: {
    titles: ['', ''],
    searchPlaceholder: '请输入搜索内容',
    itemUnit: '项',
    itemsUnit: '项'
  },
  Upload: {
    uploading: '文件上传中',
    removeFile: '删除文件',
    uploadError: '上传错误',
    previewFile: '预览文件',
    downloadFile: '下载文件'
  },
  Empty: {
    description: '暂无数据'
  },
  Icon: {
    icon: '图标'
  },
  Text: {
    edit: '编辑',
    copy: '复制',
    copied: '复制成功',
    expand: '展开'
  },
  PageHeader: {
    back: '返回'
  }
};
/* harmony default export */ var locale_default = (local);
// CONCATENATED MODULE: ./src/components/modal/locale.ts

 // export interface ModalLocale {
//   okText: string;
//   cancelText: string;
//   justOkText: string;
// }

var locale_runtimeLocale = Object.assign({}, locale_default.Modal);
function changeConfirmLocale(newLocale) {
  if (newLocale) {
    locale_runtimeLocale = Object.assign(Object.assign({}, locale_runtimeLocale), newLocale);
  } else {
    locale_runtimeLocale = Object.assign({}, locale_default.Modal);
  }
}
function getConfirmLocale() {
  return locale_runtimeLocale;
}
// CONCATENATED MODULE: ./src/components/locale-provider/index.tsx






 // export interface Locale {
//   locale: string;
//   Pagination?: Object;
//   DatePicker?: Object;
//   TimePicker?: Object;
//   Calendar?: Object;
//   Table?: Object;
//   Modal?: ModalLocale;
//   Popconfirm?: Object;
//   Transfer?: Object;
//   Select?: Object;
//   Upload?: Object;
// }

var ANT_MARK = 'internalMark';

function setMomentLocale(locale) {
  if (locale && locale.locale) {
    interopDefault(moment).locale(locale.locale);
  } else {
    interopDefault(moment).locale('en');
  }
}

var COMPONENT_NAME = 'ALocaleProvider';
var LocaleProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: COMPONENT_NAME,
  props: {
    locale: vue_types.object.def(function () {
      return {};
    }),
    _ANT_MARK__: vue_types.string
  },
  setup: function setup(props) {
    _util_warning(props._ANT_MARK__ === ANT_MARK, 'LocaleProvider', '`LocaleProvider` is deprecated. Please use `locale`' + ' with `ConfigProvider` instead');

    var _getCurrentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])(),
        data = _getCurrentInstance.data;

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])('localeData', data);
    var antLocale = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(Object.assign(Object.assign({}, props.locale), {
      exist: true
    }));
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(props.locale, function (val) {
      antLocale.value = Object.assign(Object.assign({}, props.locale), {
        exist: true
      });
      setMomentLocale(val);
      changeConfirmLocale(val && val.Modal);
    });
    setMomentLocale(props.locale);
    changeConfirmLocale(props.locale && props.locale.Modal);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUnmounted"])(function () {
      changeConfirmLocale();
    });
    return {
      antLocale: antLocale
    };
  },
  render: function render() {
    return this.$slots["default"] ? this.$slots["default"][0] : null;
  }
}) && {
  install: function install(app) {}
};
/* istanbul ignore next */

LocaleProvider.install = function (app) {
  app.use(base);
  app.component(COMPONENT_NAME, LocaleProvider);
};

/* harmony default export */ var locale_provider = (LocaleProvider);
// CONCATENATED MODULE: ./src/components/locale-provider/default.ts


/* harmony default export */ var locale_provider_default = (locale_default);
// CONCATENATED MODULE: ./src/components/locale-provider/locale-receiver.tsx



/* harmony default export */ var locale_receiver = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'LocaleReceiver',
  props: {
    componentName: vue_types.string.def('global'),
    defaultLocale: vue_types.oneOfType([vue_types.object, vue_types.func]),
    children: vue_types.func
  },
  setup: function setup(props) {
    var localeData = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('localeData') || {};

    var getLocale = function getLocale() {
      var componentName = props.componentName,
          defaultLocale = props.defaultLocale;
      var locale = defaultLocale || locale_provider_default[componentName || 'global'];
      var antLocale = localeData.antLocale;
      var localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
      return Object.assign(Object.assign({}, typeof locale === 'function' ? locale() : locale), localeFromContext || {});
    };

    var getLocaleCode = function getLocaleCode() {
      var antLocale = localeData.antLocale;
      var localeCode = antLocale && antLocale.locale; // Had use LocaleProvide but didn't set locale

      if (antLocale && antLocale.exist && !localeCode) {
        return locale_provider_default.locale;
      }

      return localeCode;
    };

    return {
      getLocale: getLocale,
      getLocaleCode: getLocaleCode,
      localeData: localeData
    };
  },
  render: function render(ctx) {
    var children = this.children || this.$slots["default"];
    var antLocale = ctx.localeData.antLocale;
    return children(this.getLocale(), this.getLocaleCode(), antLocale);
  }
}));
// CONCATENATED MODULE: ./src/components/empty/empty.tsx

/* harmony default export */ var empty_empty = ({
  render: function render() {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", {
      "width": "184",
      "height": "152",
      "viewBox": "0 0 184 152"
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", {
      "fill": "none",
      "fill-rule": "evenodd"
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", {
      "transform": "translate(24 31.67)"
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("ellipse", {
      "fill-opacity": ".8",
      "fill": "#F5F5F7",
      "cx": "67.797",
      "cy": "106.89",
      "rx": "67.797",
      "ry": "12.668"
    }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", {
      "d": "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
      "fill": "#AEB8C2"
    }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", {
      "d": "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
      "fill": "url(#linearGradient-1)",
      "transform": "translate(13.56)"
    }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", {
      "d": "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
      "fill": "#F5F5F7"
    }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", {
      "d": "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
      "fill": "#DCE0E6"
    }, [])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", {
      "d": "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
      "fill": "#DCE0E6"
    }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", {
      "transform": "translate(149.65 15.383)",
      "fill": "#FFF"
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("ellipse", {
      "cx": "20.654",
      "cy": "3.167",
      "rx": "2.849",
      "ry": "2.815"
    }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", {
      "d": "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
    }, [])])])]);
  }
});
// CONCATENATED MODULE: ./src/components/empty/simple.tsx

/* harmony default export */ var simple = ({
  functional: true,
  PRESENTED_IMAGE_SIMPLE: true,
  render: function render() {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", {
      "width": "64",
      "height": "41",
      "viewBox": "0 0 64 41"
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", {
      "transform": "translate(0 1)",
      "fill": "none",
      "fill-rule": "evenodd"
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("ellipse", {
      "fill": "#F5F5F5",
      "cx": "32",
      "cy": "33",
      "rx": "32",
      "ry": "7"
    }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("g", {
      "fill-rule": "nonzero",
      "stroke": "#D9D9D9"
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", {
      "d": "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", {
      "d": "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
      "fill": "#FAFAFA"
    }, [])])])]);
  }
});
// CONCATENATED MODULE: ./src/components/empty/index.tsx



function empty_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function empty_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { empty_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { empty_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }









var empty_EmptyProps = function EmptyProps() {
  return {
    prefixCls: vue_types.string,
    image: vue_types.any,
    description: vue_types.any,
    imageStyle: vue_types.object
  };
};
var Empty = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AEmpty',
  inheritAttrs: false,
  props: Object.assign({}, empty_EmptyProps()),
  render: function render(ctx) {
    var componentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var customizePrefixCls = ctx.prefixCls,
        imageStyle = ctx.imageStyle;
    var prefixCls = ConfigConsumerProps.getPrefixCls('empty', customizePrefixCls);
    var image = props_util_getComponentFromProp(componentInstance, 'image') || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(empty_empty, {}, []);
    var description = props_util_getComponentFromProp(componentInstance, 'description');
    var des = typeof description === 'undefined' ? locale_provider_default.Empty.description : description;
    var alt = typeof des === 'string' ? des : 'empty';

    var cls = defineProperty_default()({}, prefixCls, true);

    var imageNode = null;

    if (typeof image === 'string') {
      imageNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("img", {
        "alt": alt,
        "src": image
      }, []);
    } else if (typeof_default()(image) === 'object' && image.PRESENTED_IMAGE_SIMPLE) {
      var Image = image;
      imageNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Image, {}, []);
      cls["".concat(prefixCls, "-normal")] = true;
    } else {
      imageNode = image;
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", empty_objectSpread({
      "class": cls
    }, this.$attrs), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-image"),
      "style": imageStyle
    }, [imageNode]), des && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("p", {
      "class": "".concat(prefixCls, "-description")
    }, [des]), ",", this.$slots["default"] ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-footer")
    }, [this.$slots["default"]()]) : null]);
  }
});
Empty.PRESENTED_IMAGE_DEFAULT = empty_empty;
Empty.PRESENTED_IMAGE_SIMPLE = simple;
/* istanbul ignore next */

Empty.install = function (app) {
  app.use(base);
  app.component(Empty.name, Empty);
};

/* harmony default export */ var components_empty = (Empty);
// CONCATENATED MODULE: ./src/components/config-provider/renderEmpty.tsx




var renderEmpty_RenderEmpty = function RenderEmpty(props) {
  var configProvider = config_provider_useConfigProvider();

  function renderHtml(componentName) {
    var getPrefixCls = configProvider.getPrefixCls;
    var prefix = getPrefixCls('empty');

    switch (componentName) {
      case 'Table':
      case 'List':
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_empty, {
          "image": components_empty.PRESENTED_IMAGE_SIMPLE
        }, []);

      case 'Select':
      case 'TreeSelect':
      case 'Cascader':
      case 'Transfer':
      case 'Mentions':
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_empty, {
          "image": components_empty.PRESENTED_IMAGE_SIMPLE,
          "class": "".concat(prefix, "-small")
        }, []);

      default:
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_empty, {}, []);
    }
  }

  return renderHtml(props.componentName);
};

/* harmony default export */ var config_provider_renderEmpty = (function (componentName) {
  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(renderEmpty_RenderEmpty, {
    "componentName": componentName
  }, []);
});
// CONCATENATED MODULE: ./src/components/config-provider/index.tsx






var ConfigProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AConfigProvider',
  setup: function setup(props, ctx) {
    var componentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var renderEmptyComponent = function renderEmptyComponent(name) {
      var renderEmpty = props_util_getComponentFromProp(componentInstance, 'renderEmpty', {}, false) || config_provider_renderEmpty;
      return renderEmpty(name);
    };

    var getPrefixCls = function getPrefixCls(suffixCls, customizePrefixCls) {
      var _props$prefixCls = props.prefixCls,
          prefixCls = _props$prefixCls === void 0 ? 'ant' : _props$prefixCls;

      if (customizePrefixCls) {
        return customizePrefixCls;
      }

      return suffixCls ? "".concat(prefixCls, "-").concat(suffixCls) : prefixCls;
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])('configProvider', Object.assign(Object.assign({}, props), {
      getPrefixCls: getPrefixCls,
      renderEmptyComponent: renderEmptyComponent
    }));

    var renderProvider = function renderProvider(legacyLocale) {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(locale_provider, {
        "locale": props.locale || legacyLocale,
        "_ANT_MARK__": ANT_MARK
      }, [ctx.slots["default"] ? filterEmpty(ctx.slots["default"])[0] : null]);
    };

    return {
      renderProvider: renderProvider
    };
  },
  render: function render() {
    var _this = this;

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(locale_receiver, {}, {
      "default": function _default(_, __, legacyLocale) {
        return _this.renderProvider(legacyLocale);
      }
    });
  }
});
var ConfigConsumerProps = {
  getPrefixCls: function getPrefixCls(suffixCls, customizePrefixCls) {
    if (customizePrefixCls) {
      return customizePrefixCls;
    }

    return "ant-".concat(suffixCls);
  },
  renderEmpty: config_provider_renderEmpty,
  autoInsertSpaceInButton: true,
  getPopupContainer: function getPopupContainer() {
    return document.body;
  }
};
var config_provider_useConfigProvider = function useConfigProvider() {
  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('configProvider', ConfigConsumerProps);
};
/* istanbul ignore next */

ConfigProvider.install = function (app) {
  app.use(base);
  app.component(ConfigProvider.name, ConfigProvider);
};

/* harmony default export */ var config_provider = (ConfigProvider);
// CONCATENATED MODULE: ./src/components/_util/css-animation/event.ts

var START_EVENT_NAME_MAP = {
  transitionstart: {
    transition: 'transitionstart',
    WebkitTransition: 'webkitTransitionStart',
    MozTransition: 'mozTransitionStart',
    OTransition: 'oTransitionStart',
    msTransition: 'MSTransitionStart'
  },
  animationstart: {
    animation: 'animationstart',
    WebkitAnimation: 'webkitAnimationStart',
    MozAnimation: 'mozAnimationStart',
    OAnimation: 'oAnimationStart',
    msAnimation: 'MSAnimationStart'
  }
};
var END_EVENT_NAME_MAP = {
  transitionend: {
    transition: 'transitionend',
    WebkitTransition: 'webkitTransitionEnd',
    MozTransition: 'mozTransitionEnd',
    OTransition: 'oTransitionEnd',
    msTransition: 'MSTransitionEnd'
  },
  animationend: {
    animation: 'animationend',
    WebkitAnimation: 'webkitAnimationEnd',
    MozAnimation: 'mozAnimationEnd',
    OAnimation: 'oAnimationEnd',
    msAnimation: 'MSAnimationEnd'
  }
};
var startEvents = [];
var endEvents = [];

function detectEvents() {
  var testEl = document.createElement('div');
  var style = testEl.style;

  if (!('AnimationEvent' in window)) {
    delete START_EVENT_NAME_MAP.animationstart.animation;
    delete END_EVENT_NAME_MAP.animationend.animation;
  }

  if (!('TransitionEvent' in window)) {
    delete START_EVENT_NAME_MAP.transitionstart.transition;
    delete END_EVENT_NAME_MAP.transitionend.transition;
  }

  function process(EVENT_NAME_MAP, events) {
    for (var baseEventName in EVENT_NAME_MAP) {
      if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
        var baseEvents = EVENT_NAME_MAP[baseEventName];

        for (var styleName in baseEvents) {
          if (styleName in style) {
            events.push(baseEvents[styleName]);
            break;
          }
        }
      }
    }
  }

  process(START_EVENT_NAME_MAP, startEvents);
  process(END_EVENT_NAME_MAP, endEvents);
}

if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  detectEvents();
}

function addEventListener(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}

function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}

var TransitionEvents = {
  // Start events
  startEvents: startEvents,
  addStartEventListener: function addStartEventListener(node, eventListener) {
    if (startEvents.length === 0) {
      window.setTimeout(eventListener, 0);
      return;
    }

    startEvents.forEach(function (startEvent) {
      addEventListener(node, startEvent, eventListener);
    });
  },
  removeStartEventListener: function removeStartEventListener(node, eventListener) {
    if (startEvents.length === 0) {
      return;
    }

    startEvents.forEach(function (startEvent) {
      removeEventListener(node, startEvent, eventListener);
    });
  },
  // End events
  endEvents: endEvents,
  addEndEventListener: function addEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      window.setTimeout(eventListener, 0);
      return;
    }

    endEvents.forEach(function (endEvent) {
      addEventListener(node, endEvent, eventListener);
    });
  },
  removeEndEventListener: function removeEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }

    endEvents.forEach(function (endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};
/* harmony default export */ var css_animation_event = (TransitionEvents);
// EXTERNAL MODULE: ./node_modules/raf/index.js
var raf = __webpack_require__("c449");
var raf_default = /*#__PURE__*/__webpack_require__.n(raf);

// CONCATENATED MODULE: ./src/components/_util/raf.ts


var raf_id = 0;
var ids = {}; // Support call raf with delay specified frame

function wrapperRaf(callback) {
  var delayFrames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var myId = raf_id++;
  var restFrames = delayFrames;

  function internalCallback() {
    restFrames -= 1;

    if (restFrames <= 0) {
      callback();
      delete ids[myId];
    } else {
      ids[myId] = raf_default()(internalCallback);
    }
  }

  ids[myId] = raf_default()(internalCallback);
  return myId;
}

wrapperRaf.cancel = function (pid) {
  if (pid === undefined) {
    return;
  }

  raf_default.a.cancel(ids[pid]);
  delete ids[pid];
};

wrapperRaf.ids = ids; // export this for test usage
// CONCATENATED MODULE: ./src/components/_util/wave.tsx




var styleForPesudo; // Where el is the DOM element you'd like to test for visibility

function isHidden(element) {
  if (false) {}

  return !element || element.offsetParent === null;
}

function isNotGrey(color) {
  // eslint-disable-next-line no-useless-escape
  var match = (color || '').match(/rgba?\((\d*), (\d*), (\d*)(, [\.\d]*)?\)/);

  if (match && match[1] && match[2] && match[3]) {
    return !(match[1] === match[2] && match[2] === match[3]);
  }

  return true;
}

/* harmony default export */ var wave = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'Wave',
  props: ['insertExtraNode'],
  setup: function setup(props, ctx) {
    var componentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var configProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('configProvider') || ConfigConsumerProps;
    var csp = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(configProvider.csp);
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var clickWaveTimeoutId = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var animationStart = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var destroy = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        var node = componentInstance.vnode.el;

        if (node.nodeType !== 1) {
          return;
        }

        instance.value = bindAnimationEvent(node);
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      if (instance.value) {
        instance.value.cancel();
      }

      if (clickWaveTimeoutId.value) {
        clearTimeout(clickWaveTimeoutId.value);
      }

      destroy.value = true;
    });
    var extraNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(document.createElement('div'));

    var onClick = function onClick(node, waveColor) {
      if (!node || isHidden(node) || node.className.indexOf('-leave') >= 0) {
        return;
      }

      var insertExtraNode = props.insertExtraNode;
      extraNode.value.className = 'ant-click-animating-node';
      var attributeName = getAttributeName();
      node.removeAttribute(attributeName);
      node.setAttribute(attributeName, 'true'); // Not white or transparnt or grey

      styleForPesudo = styleForPesudo || document.createElement('style');

      if (waveColor && waveColor !== '#ffffff' && waveColor !== 'rgb(255, 255, 255)' && isNotGrey(waveColor) && !/rgba\(\d*, \d*, \d*, 0\)/.test(waveColor) && // any transparent rgba color
      waveColor !== 'transparent') {
        // Add nonce if CSP exist
        if (csp.value && csp.value.nonce) {
          styleForPesudo.nonce = csp.value.nonce;
        }

        extraNode.value.style.borderColor = waveColor;
        styleForPesudo.innerHTML = "\n        [ant-click-animating-without-extra-node='true']::after, .ant-click-animating-node {\n          --antd-wave-shadow-color: ".concat(waveColor, ";\n        }");

        if (!document.body.contains(styleForPesudo)) {
          document.body.appendChild(styleForPesudo);
        }
      }

      if (insertExtraNode) {
        node.appendChild(extraNode.value);
      }

      css_animation_event.addStartEventListener(node, onTransitionStart);
      css_animation_event.addEndEventListener(node, onTransitionEnd);
    };

    var onTransitionStart = function onTransitionStart(e) {
      if (destroy.value) {
        return;
      }

      var node = componentInstance.vnode.el;

      if (!e || e.target !== node) {
        return;
      }

      if (!animationStart) {
        resetEffect(node);
      }
    };

    var onTransitionEnd = function onTransitionEnd(e) {
      if (!e || e.animationName !== 'fadeEffect') {
        return;
      }

      resetEffect(e.target);
    };

    var getAttributeName = function getAttributeName() {
      var insertExtraNode = props.insertExtraNode;
      return insertExtraNode ? 'ant-click-animating' : 'ant-click-animating-without-extra-node';
    };

    var animationStartId = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var bindAnimationEvent = function bindAnimationEvent(node) {
      if (!node || !node.getAttribute || node.getAttribute('disabled') || node.className.indexOf('disabled') >= 0) {
        return;
      }

      var clickEventHandler = function clickEventHandler(e) {
        // Fix radio button click twice
        if (e.target.tagName === 'INPUT' || isHidden(e.target)) {
          return;
        }

        resetEffect(node); // Get wave color from target

        var waveColor = getComputedStyle(node).getPropertyValue('border-top-color') || // Firefox Compatible
        getComputedStyle(node).getPropertyValue('border-color') || getComputedStyle(node).getPropertyValue('background-color');
        clickWaveTimeoutId.value = window.setTimeout(function () {
          return onClick(node, waveColor);
        }, 0);
        wrapperRaf.cancel(animationStartId.value);
        animationStart.value = true; // Render to trigger transition event cost 3 frames. Let's delay 10 frames to reset this.

        animationStartId.value = wrapperRaf(function () {
          animationStart.value = false;
        }, 10);
      };

      node.addEventListener('click', clickEventHandler, true);
      return {
        cancel: function cancel() {
          node.removeEventListener('click', clickEventHandler, true);
        }
      };
    };

    var resetEffect = function resetEffect(node) {
      if (!node || node === extraNode.value || !(node instanceof Element)) {
        return;
      }

      var insertExtraNode = props.insertExtraNode;
      var attributeName = getAttributeName();
      node.setAttribute(attributeName, 'false'); // edge has bug on `removeAttribute` #14466

      if (styleForPesudo) {
        styleForPesudo.innerHTML = '';
      }

      if (insertExtraNode && extraNode.value && node.contains(extraNode.value)) {
        node.removeChild(extraNode.value);
      }

      css_animation_event.removeStartEventListener(node, onTransitionStart);
      css_animation_event.removeEndEventListener(node, onTransitionEnd);
    };

    return {
      configProvider: configProvider,
      onClick: onClick,
      csp: csp
    };
  },
  render: function render() {
    if (this.configProvider.csp) {
      this.csp = this.configProvider.csp;
    }

    return this.$slots["default"] && this.$slots["default"]()[0];
  }
}));
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__("4d26");
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);

// CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}

// CONCATENATED MODULE: ./src/components/icon/IconFont.tsx


function IconFont_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function IconFont_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { IconFont_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { IconFont_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }





var customCache = new Set();
function create(options) {
  var scriptUrl = options.scriptUrl,
      _options$extraCommonP = options.extraCommonProps,
      extraCommonProps = _options$extraCommonP === void 0 ? {} : _options$extraCommonP;
  /**
   * DOM API required.
   * Make sure in browser environment.
   * The Custom Icon will create a <script/>
   * that loads SVG symbols and insert the SVG Element into the document body.
   */

  if (typeof document !== 'undefined' && typeof window !== 'undefined' && typeof document.createElement === 'function' && typeof scriptUrl === 'string' && scriptUrl.length && !customCache.has(scriptUrl)) {
    var script = document.createElement('script');
    script.setAttribute('src', scriptUrl);
    script.setAttribute('data-namespace', scriptUrl);
    customCache.add(scriptUrl);
    document.body.appendChild(script);
  }

  var iconfont = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    name: 'AIconfont',
    props: components_icon.props,
    render: function render(context) {
      var props = context.props,
          slots = context.slots,
          listeners = context.listeners,
          data = context.data;

      var type = props.type,
          restProps = __rest(props, ["type"]);

      var slotsMap = slots();
      var children = slotsMap["default"]; // component > children > type

      var content = null;

      if (type) {
        // @ts-ignore
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("use", IconFont_objectSpread({}, defineProperty_default()({}, 'xlink:href', "#".concat(type))), []);
      }

      if (children) {
        content = children;
      }

      var iconProps = mergeProps(extraCommonProps, data, {
        props: restProps,
        on: listeners
      });
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, IconFont_objectSpread({}, iconProps), [context]);
    }
  });
  return iconfont;
}
// CONCATENATED MODULE: ./src/components/icon/twoTonePrimaryColor.ts


function setTwoToneColor(primaryColor) {
  return icons_vue.setTwoToneColors({
    primaryColor: primaryColor
  });
}
function getTwoToneColor() {
  var colors = icons_vue.getTwoToneColors();
  return colors.primaryColor;
}
// CONCATENATED MODULE: ./src/components/icon/utils.ts

 // These props make sure that the SVG behaviours like general text.
// Reference: https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4

var svgBaseProps = {
  width: '1em',
  height: '1em',
  fill: 'currentColor',
  'aria-hidden': 'true',
  focusable: 'false'
};
var fillTester = /-fill$/;
var outlineTester = /-o$/;
var twoToneTester = /-twotone$/;
function getThemeFromTypeName(type) {
  var result = null;

  if (fillTester.test(type)) {
    result = 'filled';
  } else if (outlineTester.test(type)) {
    result = 'outlined';
  } else if (twoToneTester.test(type)) {
    result = 'twoTone';
  }

  return result;
}
function removeTypeTheme(type) {
  return type.replace(fillTester, '').replace(outlineTester, '').replace(twoToneTester, '');
}
function withThemeSuffix(type, theme) {
  var result = type;

  if (theme === 'filled') {
    result += '-fill';
  } else if (theme === 'outlined') {
    result += '-o';
  } else if (theme === 'twoTone') {
    result += '-twotone';
  } else {
    _util_warning(false, 'Icon', "This icon '".concat(type, "' has unknown theme '").concat(theme, "'"));
  }

  return result;
} // For alias or compatibility

function alias(type) {
  var newType = type;

  switch (type) {
    case 'cross':
      newType = 'close';
      break;
    // https://github.com/ant-design/ant-design/issues/13007

    case 'interation':
      newType = 'interaction';
      break;
    // https://github.com/ant-design/ant-design/issues/16810

    case 'canlendar':
      newType = 'calendar';
      break;
    // https://github.com/ant-design/ant-design/issues/17448

    case 'colum-height':
      newType = 'column-height';
      break;

    default:
  }

  _util_warning(newType === type, 'Icon', "Icon '".concat(type, "' was a typo and is now deprecated, please use '").concat(newType, "' instead."));
  return newType;
}
// CONCATENATED MODULE: ./src/components/icon/index.tsx


function icon_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function icon_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { icon_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { icon_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }











 // Initial setting

setTwoToneColor('#1890ff');
var defaultTheme = 'outlined';

function icon_renderIcon(locale, context) {
  var _classNames;

  var props = context.props,
      slots = context.slots;
  var type = props.type,
      Component = props.component,
      viewBox = props.viewBox,
      spin = props.spin,
      theme = props.theme,
      twoToneColor = props.twoToneColor,
      rotate = props.rotate,
      tabIndex = props.tabIndex;
  var children = filterEmpty(slots["default"]);
  children = children.length === 0 ? undefined : children;
  _util_warning(Boolean(type || Component || children), 'Icon', 'Icon should have `type` prop or `component` prop or `children`.');
  var classString = classnames_default()((_classNames = {}, defineProperty_default()(_classNames, "anticon", true), defineProperty_default()(_classNames, "anticon-".concat(type), !!type), _classNames));
  var svgClassString = classnames_default()(defineProperty_default()({}, "anticon-spin", !!spin || type === 'loading'));
  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : undefined;
  var innerSvgProps = {
    attrs: Object.assign(Object.assign({}, svgBaseProps), {
      viewBox: viewBox
    }),
    "class": svgClassString,
    style: svgStyle
  };

  if (!viewBox) {
    delete innerSvgProps.attrs.viewBox;
  }

  var renderInnerNode = function renderInnerNode() {
    // component > children > type
    if (Component) {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Component, icon_objectSpread({}, innerSvgProps), [children]);
    }

    if (children && children.length) {
      _util_warning(Boolean(viewBox) || children.length === 1 && children[0].type === 'use', 'Icon', 'Make sure that you provide correct `viewBox`' + ' prop (default `0 0 1024 1024`) to the icon.');
      var _innerSvgProps = {
        attrs: Object.assign({}, svgBaseProps),
        "class": svgClassString,
        style: svgStyle
      };
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", icon_objectSpread({}, _innerSvgProps, {
        "view-box": viewBox
      }), [children]);
    }

    if (typeof type === 'string') {
      var computedType = type;

      if (theme) {
        var themeInName = getThemeFromTypeName(type);
        _util_warning(!themeInName || theme === themeInName, 'Icon', "The icon name '".concat(type, "' already specify a theme '").concat(themeInName, "',") + " the 'theme' prop '".concat(theme, "' will be ignored."));
      }

      computedType = withThemeSuffix(removeTypeTheme(alias(computedType)), theme || defaultTheme);
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(icons_vue, {
        "focusable": false,
        "class": svgClassString,
        "type": computedType,
        "primaryColor": twoToneColor,
        "style": svgStyle
      }, []);
    }
  };

  var iconTabIndex = tabIndex;

  if (iconTabIndex === undefined && 'onClick' in props) {
    iconTabIndex = -1;
  } // functional component not support nativeOn，https://github.com/vuejs/vue/issues/7526


  var iProps = Object.assign(Object.assign({
    'aria-label': type && "".concat(locale.Icon.icon, ": ").concat(type)
  }, context.attrs), {
    "class": classString,
    onClick: function onClick() {}
  });

  if (iconTabIndex !== undefined) {
    iProps.tabindex = iconTabIndex;
  }

  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("i", icon_objectSpread({}, iProps), [renderInnerNode()]);
}

var icon_COMPONENT_NAME = 'AIcon';
var icon_Icon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: icon_COMPONENT_NAME,
  props: {
    tabIndex: vue_types.number,
    type: vue_types.string,
    component: vue_types.any,
    viewBox: vue_types.any,
    spin: vue_types.bool.def(false),
    rotate: vue_types.number,
    theme: vue_types.oneOf(['filled', 'outlined', 'twoTone']),
    twoToneColor: vue_types.string,
    role: vue_types.string
  },
  render: function render() {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    return icon_renderIcon(locale_default, instance);
  }
});
icon_Icon.createFromIconfontCN = create;
icon_Icon.getTwoToneColor = getTwoToneColor;
icon_Icon.setTwoToneColor = setTwoToneColor;

icon_Icon.install = function (app) {
  app.use(base);
  app.component(icon_COMPONENT_NAME, icon_Icon);
};

/* harmony default export */ var components_icon = (icon_Icon);
// CONCATENATED MODULE: ./src/components/button/buttonTypes.tsx


/* harmony default export */ var buttonTypes = (function () {
  return {
    prefixCls: vue_types.string,
    type: vue_types.string,
    htmlType: vue_types.oneOf(['button', 'submit', 'reset']).def('button'),
    icon: vue_types.string,
    shape: vue_types.oneOf(['circle', 'circle-outline', 'round']),
    size: vue_types.oneOf(['small', 'large', 'default']).def('default'),
    loading: vue_types.oneOfType([vue_types.bool, vue_types.object]),
    disabled: vue_types.bool,
    ghost: vue_types.bool,
    block: vue_types.bool
  };
});
// CONCATENATED MODULE: ./src/components/button/button.tsx


function button_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function button_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { button_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { button_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }







var rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
var isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
/* harmony default export */ var button_button = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  inheritAttrs: false,
  name: 'AButton',
  props: buttonTypes(),
  setup: function setup(props, _ref) {
    var slots = _ref.slots,
        emit = _ref.emit;
    var configProvider = config_provider_useConfigProvider();
    var hasTwoCNChar = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var loading = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.loading); //     sLoading,

    var getClasses = function getClasses() {
      var _ref2;

      var customizePrefixCls = props.prefixCls,
          type = props.type,
          shape = props.shape,
          size = props.size,
          ghost = props.ghost,
          block = props.block,
          icon = props.icon;
      var getPrefixCls = configProvider.getPrefixCls;
      var prefixCls = getPrefixCls('btn', customizePrefixCls);
      var autoInsertSpace = configProvider.autoInsertSpaceInButton !== false; // large => lg
      // small => sm

      var sizeCls = '';

      switch (size) {
        case 'large':
          sizeCls = 'lg';
          break;

        case 'small':
          sizeCls = 'sm';
          break;

        default:
          break;
      }

      var iconType = loading.value ? 'loading' : icon;
      var children = filterEmpty(slots["default"]);
      return _ref2 = {}, defineProperty_default()(_ref2, "".concat(prefixCls), true), defineProperty_default()(_ref2, "".concat(prefixCls, "-").concat(type), type), defineProperty_default()(_ref2, "".concat(prefixCls, "-").concat(shape), shape), defineProperty_default()(_ref2, "".concat(prefixCls, "-").concat(sizeCls), sizeCls), defineProperty_default()(_ref2, "".concat(prefixCls, "-icon-only"), children.length === 0 && iconType), defineProperty_default()(_ref2, "".concat(prefixCls, "-loading"), loading.value), defineProperty_default()(_ref2, "".concat(prefixCls, "-background-ghost"), ghost || type === 'ghost'), defineProperty_default()(_ref2, "".concat(prefixCls, "-two-chinese-chars"), hasTwoCNChar.value && autoInsertSpace), defineProperty_default()(_ref2, "".concat(prefixCls, "-block"), block), _ref2;
    };

    var delayTimeout = null;
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.loading;
    }, function (val, preVal) {
      if (preVal && typeof preVal !== 'boolean' && delayTimeout) {
        clearTimeout(delayTimeout);
      }

      if (val && typeof val !== 'boolean' && val.delay) {
        delayTimeout = setTimeout(function () {
          loading.value = !!val;
        }, val.delay);
      } else {
        loading.value = !!val;
      }
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      fixTwoCNChar();
    });
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var fixTwoCNChar = function fixTwoCNChar() {
      // Fix for HOC usage like <FormatMessage />
      var node = instance.refs.buttonNode;

      if (!node) {
        return;
      }

      var buttonText = node.textContent;

      if (isNeedInserted() && isTwoCNChar(buttonText)) {
        if (!hasTwoCNChar.value) {
          hasTwoCNChar.value = true;
        }
      } else if (hasTwoCNChar.value) {
        hasTwoCNChar.value = false;
      }
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      fixTwoCNChar();
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      if (delayTimeout) {
        clearTimeout(delayTimeout);
      }
    });

    var isNeedInserted = function isNeedInserted() {
      var icon = props.icon,
          type = props.type;
      return slots["default"] && slots["default"]().length === 1 && !icon && type !== 'link';
    };

    var handleClick = function handleClick(event) {
      if (loading.value) {
        return;
      }

      emit('click', event);
    };

    var insertSpace = function insertSpace(child, needInserted) {
      var SPACE = needInserted ? ' ' : '';

      if (typeof child.children === 'string') {
        var text = child.children.trim();

        if (isTwoCNChar(text)) {
          text = text.split('').join(SPACE);
        }

        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {}, [text]);
      }

      return child;
    };

    return {
      insertSpace: insertSpace,
      loading: loading,
      isNeedInserted: isNeedInserted,
      configProvider: configProvider,
      getClasses: getClasses,
      handleClick: handleClick
    };
  },
  render: function render(ctx) {
    var _this = this;

    var attrs = ctx.$attrs;
    var type = this.type,
        isNeedInserted = this.isNeedInserted,
        configProvider = this.configProvider,
        htmlType = this.htmlType,
        getClasses = this.getClasses,
        icon = this.icon,
        disabled = this.disabled,
        handleClick = this.handleClick,
        $slots = this.$slots,
        $attrs = this.$attrs;
    var buttonProps = Object.assign(Object.assign({}, $attrs), {
      disabled: disabled,
      "class": Object.assign(getClasses(), attrs["class"] ? defineProperty_default()({}, attrs["class"], true) : {}),
      onClick: handleClick
    });
    var iconType = this.loading ? 'loading' : icon;
    var iconNode = iconType ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
      "type": iconType
    }, []) : null;
    var children = filterEmpty($slots["default"]);
    var autoInsertSpace = configProvider.autoInsertSpaceInButton !== false;
    var kids = children.map(function (child) {
      return _this.insertSpace(child, isNeedInserted() && autoInsertSpace);
    });

    if ($attrs.href !== undefined) {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", button_objectSpread({}, buttonProps, {
        "ref": "buttonNode"
      }), [iconNode, kids]);
    }

    var buttonNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("button", button_objectSpread({}, buttonProps, {
      "ref": "buttonNode",
      "type": htmlType || 'button'
    }), [iconNode, kids]);

    if (type === 'link') {
      return buttonNode;
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(wave, {}, [buttonNode]);
  }
}));
// CONCATENATED MODULE: ./src/components/button/button-group.tsx





var ButtonGroupProps = {
  prefixCls: vue_types.string,
  size: {
    validator: function validator(value) {
      return ['small', 'large', 'default'].includes(value);
    }
  }
};

/* harmony default export */ var button_group = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AButtonGroup',
  props: ButtonGroupProps,
  setup: function setup() {
    var configProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('configProvider') || ConfigConsumerProps;
    return {
      configProvider: configProvider
    };
  },
  render: function render() {
    var _classes;

    var customizePrefixCls = this.prefixCls,
        size = this.size,
        $slots = this.$slots;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('btn-group', customizePrefixCls); // large => lg
    // small => sm

    var sizeCls = '';

    switch (size) {
      case 'large':
        sizeCls = 'lg';
        break;

      case 'small':
        sizeCls = 'sm';
        break;

      default:
        break;
    }

    var classes = (_classes = {}, defineProperty_default()(_classes, "".concat(prefixCls), true), defineProperty_default()(_classes, "".concat(prefixCls, "-").concat(sizeCls), sizeCls), _classes);
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": classes
    }, [filterEmpty($slots["default"])]);
  }
}));
// CONCATENATED MODULE: ./src/components/button/index.tsx




button_button.Group = button_group;
/* istanbul ignore next */

button_button.install = function (app) {
  app.use(base);
  app.component(button_button.name, button_button);
  app.component(button_group.name, button_group);
};

/* harmony default export */ var components_button = (button_button);
// CONCATENATED MODULE: ./src/components/vc-tabs/src/save-ref.tsx

var save_ref_useRefs = function useRefs() {
  var refs = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["reactive"])({});
  return {
    getRef: function getRef(name) {
      return refs[name];
    },
    saveRef: function saveRef(name) {
      return function (node) {
        if (node) {
          refs[name] = node;
        }
      };
    },
    getRefs: function getRefs() {
      return refs;
    }
  };
};
// CONCATENATED MODULE: ./src/tools/state.ts

var state_useState = function useState(initialState) {
  // @ts-ignore
  var initState = (typeof initialState === 'function' ? initialState() : initialState) || {};
  var localState = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["reactive"])(initState);

  var setState = function setState(state, callback) {
    var newState = typeof state === 'function' ? state(localState) : state;
    Object.keys(newState).forEach(function (key) {
      localState[key] = newState[key];
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
      callback && callback();
    });
    return localState;
  };

  return {
    setState: setState,
    state: localState
  };
};
// CONCATENATED MODULE: ./node_modules/omit.js/es/index.js

function omit(obj, fields) {
  var shallowCopy = extends_default()({}, obj);
  for (var i = 0; i < fields.length; i++) {
    var key = fields[i];
    delete shallowCopy[key];
  }
  return shallowCopy;
}

/* harmony default export */ var es = (omit);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__("448a");
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// CONCATENATED MODULE: ./src/components/_util/throttle-by-animation-frame.ts



function throttleByAnimationFrame(fn) {
  var requestId;

  var later = function later(args) {
    return function () {
      requestId = null;
      fn.apply(void 0, toConsumableArray_default()(args));
    };
  };

  var throttled = function throttled() {
    if (requestId == null) {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      requestId = raf_default()(later(args));
    }
  };

  throttled.cancel = function () {
    return raf_default.a.cancel(requestId);
  };

  return throttled;
}
function throttleByAnimationFrameDecorator() {
  return function (target, key, descriptor) {
    var fn = descriptor.value;
    var definingProperty = false;
    return {
      configurable: true,
      get: function get() {
        if (definingProperty || this === target.prototype || this.hasOwnProperty(key)) {
          return fn;
        }

        var boundFn = throttleByAnimationFrame(fn.bind(this));
        definingProperty = true;
        Object.defineProperty(this, key, {
          value: boundFn,
          configurable: true,
          writable: true
        });
        definingProperty = false;
        return boundFn;
      }
    };
  };
}
// EXTERNAL MODULE: ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var ResizeObserver_es = __webpack_require__("6dd8");

// CONCATENATED MODULE: ./src/components/vc-resize-observer/index.tsx
// based on rc-resize-observer 0.1.3

 // Still need to be compatible with React 15, we use class component here

var VueResizeObserver = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ResizeObserver',
  props: {
    disabled: Boolean
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var componentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var currentElement = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var resizeObserver = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var sWidth = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
    var sHeight = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
    var root = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var setRootNode = function setRootNode(children) {
      if (Array.isArray(children)) {
        root.value = children[0];
      }
    };

    var onComponentUpdated = function onComponentUpdated() {
      var disabled = props.disabled; // Unregister if disabled

      if (disabled) {
        destroyObserver();
        return;
      } // Unregister if element changed


      var element = root.value.el;
      var elementChanged = element !== currentElement.value;

      if (elementChanged) {
        destroyObserver();
        currentElement.value = element;
      }

      if (!resizeObserver.value && element) {
        resizeObserver.value = new ResizeObserver_es["a" /* default */](onResize);
        resizeObserver.value.observe(element);
      }
    };

    var onResize = function onResize(entries) {
      var target = entries[0].target;

      var _target$getBoundingCl = target.getBoundingClientRect(),
          width = _target$getBoundingCl.width,
          height = _target$getBoundingCl.height;
      /**
       * Resize observer trigger when content size changed.
       * In most case we just care about element size,
       * let's use `boundary` instead of `contentRect` here to avoid shaking.
       */


      var fixedWidth = Math.floor(width);
      var fixedHeight = Math.floor(height);

      if (sWidth.value !== fixedWidth || sHeight.value !== fixedHeight) {
        var size = {
          width: fixedWidth,
          height: fixedHeight
        };
        sWidth.value = fixedWidth;
        sHeight.value = fixedHeight;
        emit('resize', size);
      }
    };

    var destroyObserver = function destroyObserver() {
      if (resizeObserver.value) {
        resizeObserver.value.disconnect();
        resizeObserver.value = null;
      }
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      onComponentUpdated();
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      onComponentUpdated();
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      destroyObserver();
    });
    return {
      setRootNode: setRootNode
    };
  },
  render: function render() {
    var children = this.$slots["default"] && this.$slots["default"]();
    this.setRootNode(children);
    return children;
  }
});
/* harmony default export */ var vc_resize_observer = (VueResizeObserver);
// EXTERNAL MODULE: ./node_modules/add-dom-event-listener/lib/index.js
var lib = __webpack_require__("2c80");
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);

// CONCATENATED MODULE: ./src/components/vc-util/Dom/addEventListener.js


function addEventListenerWrap(target, eventType, cb, option) {
  return lib_default()(target, eventType, cb, option);
}
// CONCATENATED MODULE: ./src/components/affix/utils.ts


function getTargetRect(target) {
  return target !== window ? target.getBoundingClientRect() : {
    top: 0,
    bottom: window.innerHeight
  };
}
function getFixedTop(placeholderReact, targetRect, offsetTop) {
  if (offsetTop !== undefined && targetRect.top > placeholderReact.top - offsetTop) {
    return offsetTop + targetRect.top + 'px';
  }

  return undefined;
}
function getFixedBottom(placeholderReact, targetRect, offsetBottom) {
  if (offsetBottom !== undefined && targetRect.bottom < placeholderReact.bottom + offsetBottom) {
    var targetBottomOffset = window.innerHeight - targetRect.bottom;
    return offsetBottom + targetBottomOffset + 'px';
  }

  return undefined;
} // ======================== Observer ========================

var TRIGGER_EVENTS = ['resize', 'scroll', 'touchstart', 'touchmove', 'touchend', 'pageshow', 'load'];
var observerEntities = [];
function getObserverEntities() {
  // Only used in test env. Can be removed if refactor.
  return observerEntities;
}
function addObserveTarget(target, affix) {
  if (!target) {
    return;
  }

  var entity = observerEntities.find(function (item) {
    return item.target === target;
  });

  if (entity) {
    entity.affixList.push(affix);
  } else {
    entity = {
      target: target,
      affixList: [affix],
      eventHandlers: {}
    };
    observerEntities.push(entity); // Add listener

    TRIGGER_EVENTS.forEach(function (eventName) {
      entity.eventHandlers[eventName] = addEventListenerWrap(target, eventName, function () {
        entity.affixList.forEach(function (targetAffix) {
          targetAffix.ctx.lazyUpdatePosition();
        });
      });
    });
  }
}
function removeObserveTarget(affix) {
  var observerEntity = observerEntities.find(function (oriObserverEntity) {
    var hasAffix = oriObserverEntity.affixList.some(function (item) {
      return item === affix;
    });

    if (hasAffix) {
      oriObserverEntity.affixList = oriObserverEntity.affixList.filter(function (item) {
        return item !== affix;
      });
    }

    return hasAffix;
  });

  if (observerEntity && observerEntity.affixList.length === 0) {
    observerEntities = observerEntities.filter(function (item) {
      return item !== observerEntity;
    }); // Remove listener

    TRIGGER_EVENTS.forEach(function (eventName) {
      var handler = observerEntity.eventHandlers[eventName];

      if (handler && handler.remove) {
        handler.remove();
      }
    });
  }
}
// CONCATENATED MODULE: ./src/components/affix/index.tsx


function affix_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function affix_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { affix_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { affix_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }














function getDefaultTarget() {
  return typeof window !== 'undefined' ? window : null;
} // Affix


var AffixProps = {
  /**
   * 距离窗口顶部达到指定偏移量后触发
   */
  offsetTop: vue_types.number,
  offset: vue_types.number,

  /** 距离窗口底部达到指定偏移量后触发 */
  offsetBottom: vue_types.number,

  /** 固定状态改变时触发的回调函数 */
  // onChange?: (affixed?: boolean) => void;

  /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */
  target: vue_types.func.def(function () {
    return getDefaultTarget;
  }),
  prefixCls: vue_types.string
};
var AffixStatus = {
  None: 'none',
  Prepare: 'Prepare'
};
var Affix = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AAffix',
  props: AffixProps,
  watch: {
    offsetTop: function offsetTop() {},
    offsetBottom: function offsetBottom() {}
  },
  setup: function setup($props, _ref) {
    var emit = _ref.emit;
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $props.offsetTop;
    }, function () {
      updatePosition();
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $props.offsetBottom;
    }, function () {
      updatePosition();
    });

    var _useState = state_useState({
      affixStyle: undefined,
      placeholderStyle: undefined,
      status: AffixStatus.None,
      lastAffix: false,
      prevTarget: null,
      timeout: null
    }),
        $state = _useState.state,
        setState = _useState.setState;

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $props.target;
    }, function (val) {
      var newTarget = null;

      if (val) {
        newTarget = val() || null;
      }

      if ($state.prevTarget !== newTarget) {
        removeObserveTarget(instance);

        if (newTarget) {
          addObserveTarget(newTarget, instance); // Mock Event object.

          updatePosition();
        }

        $state.prevTarget = newTarget;
      }
    });

    var getOffsetTop = function getOffsetTop() {
      var offset = $props.offset,
          offsetBottom = $props.offsetBottom;
      var offsetTop = $props.offsetTop;

      if (typeof offsetTop === 'undefined') {
        offsetTop = offset;
        _util_warning(typeof offset === 'undefined', 'Affix', '`offset` is deprecated. Please use `offsetTop` instead.');
      }

      if (offsetBottom === undefined && offsetTop === undefined) {
        offsetTop = 0;
      }

      return offsetTop;
    };

    var getOffsetBottom = function getOffsetBottom() {
      return $props.offsetBottom;
    };

    var _useRefs = save_ref_useRefs(),
        getRef = _useRefs.getRef,
        saveRef = _useRefs.saveRef;

    var measure = function measure() {
      var status = $state.status,
          lastAffix = $state.lastAffix;
      var target = $props.target;

      if (status !== AffixStatus.Prepare || !getRef('fixedNode') || !getRef('placeholderNode') || !target) {
        return;
      }

      var offsetTop = getOffsetTop();
      var offsetBottom = getOffsetBottom();
      var targetNode = target();

      if (!targetNode) {
        return;
      }

      var newState = {
        status: AffixStatus.None
      };
      var targetRect = getTargetRect(targetNode);
      var placeholderReact = getTargetRect(getRef('placeholderNode'));
      var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop);
      var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom);

      if (fixedTop !== undefined) {
        newState.affixStyle = {
          position: 'fixed',
          top: fixedTop,
          width: placeholderReact.width + 'px',
          height: placeholderReact.height + 'px'
        };
        newState.placeholderStyle = {
          width: placeholderReact.width + 'px',
          height: placeholderReact.height + 'px'
        };
      } else if (fixedBottom !== undefined) {
        newState.affixStyle = {
          position: 'fixed',
          bottom: fixedBottom,
          width: placeholderReact.width + 'px',
          height: placeholderReact.height + 'px'
        };
        newState.placeholderStyle = {
          width: placeholderReact.width + 'px',
          height: placeholderReact.height + 'px'
        };
      }

      newState.lastAffix = !!newState.affixStyle;

      if (lastAffix !== newState.lastAffix) {
        emit('change', newState.lastAffix);
      }

      setState(newState);
    };

    var prepareMeasure = function prepareMeasure() {
      setState({
        status: AffixStatus.Prepare,
        affixStyle: undefined,
        placeholderStyle: undefined
      });
      measure(); // Test if `updatePosition` called

      if (false) {}
    };

    var updatePosition = throttleByAnimationFrame(function () {
      prepareMeasure();
    });
    var lazyUpdatePosition = throttleByAnimationFrame(function () {
      var target = $props.target;
      var affixStyle = $state.affixStyle; // Check position change before measure to make Safari smooth

      if (target && affixStyle) {
        var offsetTop = getOffsetTop();
        var offsetBottom = getOffsetBottom();
        var targetNode = target();

        if (targetNode && getRef('placeholderNode')) {
          var targetRect = getTargetRect(targetNode);
          var placeholderReact = getTargetRect(getRef('placeholderNode'));
          var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop);
          var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom);

          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {
            return;
          }
        }
      } // Directly call prepare measure since it's already throttled.


      prepareMeasure();
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      var target = $props.target;

      if (target) {
        // [Legacy] Wait for parent component ref has its value.
        // We should use target as directly element instead of function which makes element check hard.
        $state.timeout = setTimeout(function () {
          addObserveTarget(target(), instance); // Mock Event object.

          updatePosition();
        });
      }
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      measure();
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      clearTimeout($state.timeout);
      removeObserveTarget(instance);
      updatePosition.cancel();
    });
    return {
      getOffsetTop: getOffsetTop,
      getOffsetBottom: getOffsetBottom,
      measure: measure,
      prepareMeasure: prepareMeasure,
      updatePosition: updatePosition,
      lazyUpdatePosition: lazyUpdatePosition,
      saveRef: saveRef,
      $state: $state,
      configProvider: config_provider_useConfigProvider(),
      getAffixStyle: function getAffixStyle() {
        return $state.affixStyle;
      }
    };
  },
  render: function render() {
    var _this = this;

    var affixStyle = this.getAffixStyle();
    var prefixCls = this.prefixCls,
        $slots = this.$slots,
        $props = this.$props;
    var placeholderStyle = this.$state.placeholderStyle;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var className = classnames_default()(defineProperty_default()({}, getPrefixCls('affix', prefixCls), affixStyle));
    var props = Object.assign({}, es($props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target']));
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_resize_observer, {
      "onResize": function onResize() {
        _this.updatePosition();
      }
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", affix_objectSpread({}, props, {
      "style": placeholderStyle,
      "ref": this.saveRef('placeholderNode')
    }), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": className,
      "ref": this.saveRef('fixedNode'),
      "style": affixStyle
    }, [$slots["default"] && $slots["default"]()])])]);
  }
});
/* istanbul ignore next */

Affix.install = function (Vue) {
  Vue.use(base);
  Vue.component(Affix.name, Affix);
};

/* harmony default export */ var components_affix = (Affix);
// EXTERNAL MODULE: ./node_modules/component-classes/index.js
var component_classes = __webpack_require__("3c55");
var component_classes_default = /*#__PURE__*/__webpack_require__.n(component_classes);

// CONCATENATED MODULE: ./src/components/_util/get-request-animation-frame.ts

var availablePrefixs = ['moz', 'ms', 'webkit'];

function requestAnimationFramePolyfill() {
  var lastTime = 0;
  return function (callback) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = window.setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
}

function getRequestAnimationFrame() {
  if (typeof window === 'undefined') {
    return function () {};
  }

  if (window.requestAnimationFrame) {
    // https://github.com/vuejs/vue/issues/4465
    return window.requestAnimationFrame.bind(window);
  }

  var prefix = availablePrefixs.filter(function (key) {
    return "".concat(key, "RequestAnimationFrame") in window;
  })[0];
  return prefix ? window["".concat(prefix, "RequestAnimationFrame")] : requestAnimationFramePolyfill();
}
function cancelRequestAnimationFrame(id) {
  if (typeof window === 'undefined') {
    return null;
  }

  if (window.cancelAnimationFrame) {
    return window.cancelAnimationFrame(id);
  }

  var prefix = availablePrefixs.filter(function (key) {
    return "".concat(key, "CancelAnimationFrame") in window || "".concat(key, "CancelRequestAnimationFrame") in window;
  })[0];
  return prefix ? (window["".concat(prefix, "CancelAnimationFrame")] || window["".concat(prefix, "CancelRequestAnimationFrame")]).call(null, id) : clearTimeout(id);
}
// CONCATENATED MODULE: ./src/components/_util/request-animation-timeout.ts


var request_animation_timeout_raf = getRequestAnimationFrame();
var request_animation_timeout_cancelAnimationTimeout = function cancelAnimationTimeout(frame) {
  return cancelRequestAnimationFrame(frame.id);
};
var requestAnimationTimeout = function requestAnimationTimeout(callback, delay) {
  var start = Date.now();

  function timeout() {
    if (Date.now() - start >= delay) {
      callback.call();
    } else {
      frame.id = request_animation_timeout_raf(timeout);
    }
  }

  var frame = {
    id: request_animation_timeout_raf(timeout)
  };
  return frame;
};
// CONCATENATED MODULE: ./src/components/_util/css-animation/index.ts


// https://github.com/yiminghe/css-animation 1.5.0



var isCssAnimationSupported = css_animation_event.endEvents.length !== 0;
var capitalPrefixes = ['Webkit', 'Moz', 'O', // ms is special .... !
'ms'];
var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];

function getStyleProperty(node, name) {
  // old ff need null, https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle
  var style = window.getComputedStyle(node, null);
  var ret = '';

  for (var i = 0; i < prefixes.length; i++) {
    ret = style.getPropertyValue(prefixes[i] + name);

    if (ret) {
      break;
    }
  }

  return ret;
}

function fixBrowserByTimeout(node) {
  if (isCssAnimationSupported) {
    var transitionDelay = parseFloat(getStyleProperty(node, 'transition-delay')) || 0;
    var transitionDuration = parseFloat(getStyleProperty(node, 'transition-duration')) || 0;
    var animationDelay = parseFloat(getStyleProperty(node, 'animation-delay')) || 0;
    var animationDuration = parseFloat(getStyleProperty(node, 'animation-duration')) || 0;
    var time = Math.max(transitionDuration + transitionDelay, animationDuration + animationDelay); // sometimes, browser bug

    node.rcEndAnimTimeout = setTimeout(function () {
      node.rcEndAnimTimeout = null;

      if (node.rcEndListener) {
        node.rcEndListener();
      }
    }, time * 1000 + 200);
  }
}

function clearBrowserBugTimeout(node) {
  if (node.rcEndAnimTimeout) {
    clearTimeout(node.rcEndAnimTimeout);
    node.rcEndAnimTimeout = null;
  }
}

var css_animation_cssAnimation = function cssAnimation(node, transitionName, endCallback) {
  var nameIsObj = typeof_default()(transitionName) === 'object';
  var className = nameIsObj ? transitionName.name : transitionName;
  var activeClassName = nameIsObj ? transitionName.active : "".concat(transitionName, "-active");
  var end = endCallback;
  var start;
  var active;
  var nodeClasses = component_classes_default()(node);

  if (endCallback && Object.prototype.toString.call(endCallback) === '[object Object]') {
    end = endCallback.end;
    start = endCallback.start;
    active = endCallback.active;
  }

  if (node.rcEndListener) {
    node.rcEndListener();
  }

  node.rcEndListener = function (e) {
    if (e && e.target !== node) {
      return;
    }

    if (node.rcAnimTimeout) {
      request_animation_timeout_cancelAnimationTimeout(node.rcAnimTimeout);
      node.rcAnimTimeout = null;
    }

    clearBrowserBugTimeout(node);
    nodeClasses.remove(className);
    nodeClasses.remove(activeClassName);
    css_animation_event.removeEndEventListener(node, node.rcEndListener);
    node.rcEndListener = null; // Usually this optional end is used for informing an owner of
    // a leave animation and telling it to remove the child.

    if (end) {
      end();
    }
  };

  css_animation_event.addEndEventListener(node, node.rcEndListener);

  if (start) {
    start();
  }

  nodeClasses.add(className);
  node.rcAnimTimeout = requestAnimationTimeout(function () {
    node.rcAnimTimeout = null;
    nodeClasses.add(className);
    nodeClasses.add(activeClassName);

    if (active) {
      requestAnimationTimeout(active, 0);
    }

    fixBrowserByTimeout(node); // 30ms for firefox
  }, 30);
  return {
    stop: function stop() {
      if (node.rcEndListener) {
        node.rcEndListener();
      }
    }
  };
};

css_animation_cssAnimation.style = function (node, style, callback) {
  if (node.rcEndListener) {
    node.rcEndListener();
  }

  node.rcEndListener = function (e) {
    if (e && e.target !== node) {
      return;
    }

    if (node.rcAnimTimeout) {
      request_animation_timeout_cancelAnimationTimeout(node.rcAnimTimeout);
      node.rcAnimTimeout = null;
    }

    clearBrowserBugTimeout(node);
    css_animation_event.removeEndEventListener(node, node.rcEndListener);
    node.rcEndListener = null; // Usually this optional callback is used for informing an owner of
    // a leave animation and telling it to remove the child.

    if (callback) {
      callback();
    }
  };

  css_animation_event.addEndEventListener(node, node.rcEndListener);
  node.rcAnimTimeout = requestAnimationTimeout(function () {
    for (var s in style) {
      if (style.hasOwnProperty(s)) {
        node.style[s] = style[s];
      }
    }

    node.rcAnimTimeout = null;
    fixBrowserByTimeout(node);
  }, 0);
};

css_animation_cssAnimation.setTransition = function (node, p, value) {
  var property = p;
  var v = value;

  if (value === undefined) {
    v = property;
    property = '';
  }

  property = property || '';
  capitalPrefixes.forEach(function (prefix) {
    node.style["".concat(prefix, "Transition").concat(property)] = v;
  });
};

css_animation_cssAnimation.isCssAnimationSupported = isCssAnimationSupported;

/* harmony default export */ var css_animation = (css_animation_cssAnimation);
// CONCATENATED MODULE: ./src/components/_util/openAnimation.ts




function animate(node, show, done) {
  var height;
  var requestAnimationFrameId;
  var appearRequestAnimationFrameId;
  return css_animation(node, 'ant-motion-collapse-legacy', {
    start: function start() {
      if (appearRequestAnimationFrameId) {
        raf_default.a.cancel(appearRequestAnimationFrameId);
      }

      if (!show) {
        node.style.height = "".concat(node.offsetHeight, "px");
        node.style.opacity = '1';
      } else {
        height = node.offsetHeight; // not get offsetHeight when appear
        // set it into raf get correct offsetHeight

        if (height === 0) {
          appearRequestAnimationFrameId = raf_default()(function () {
            height = node.offsetHeight;
            node.style.height = '0px';
            node.style.opacity = '0';
          });
        } else {
          node.style.height = '0px';
          node.style.opacity = '0';
        }
      }
    },
    active: function active() {
      if (requestAnimationFrameId) {
        raf_default.a.cancel(requestAnimationFrameId);
      }

      requestAnimationFrameId = raf_default()(function () {
        node.style.height = "".concat(show ? height : 0, "px");
        node.style.opacity = show ? '1' : '0';
      });
    },
    end: function end() {
      if (appearRequestAnimationFrameId) {
        raf_default.a.cancel(appearRequestAnimationFrameId);
      }

      if (requestAnimationFrameId) {
        raf_default.a.cancel(requestAnimationFrameId);
      }

      node.style.height = '';
      node.style.opacity = '';
      done && done();
    }
  });
}

var openAnimation_animation = {
  onEnter: function onEnter(node, done) {
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
      animate(node, true, done);
    });
  },
  onLeave: function onLeave(node, done) {
    return animate(node, false, done);
  }
};
/* harmony default export */ var _util_openAnimation = (openAnimation_animation);
// CONCATENATED MODULE: ./src/utils/chain.ts

function chaining() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    // eslint-disable-line
    // eslint-disable-line
    for (var i = 0; i < fns.length; i++) {
      if (fns[i] && typeof fns[i] === 'function') {
        fns[i].apply(chaining, args);
      }
    }
  };
}
// CONCATENATED MODULE: ./src/components/_util/vnode.ts



function addListener(instance, event, callback) {
  var obj = instance.attrs;
  var originEventListener = obj[event];

  if (originEventListener) {
    obj[event] = chaining(originEventListener, callback);
  } else {
    obj[event] = callback;
  }
}
function cloneElement(n) {
  var nodeProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (Array.isArray(n)) {
    return n.map(function (item) {
      return cloneElement(item, nodeProps);
    });
  }

  if (isFragment(n)) {
    var newFragmentNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(n, nodeProps);

    if (n.children) {
      if (n.children.length === 1) {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(n.children[0], nodeProps);
      }

      newFragmentNode.children = cloneElement(n.children, nodeProps);
    }

    return newFragmentNode;
  }

  var children = nodeProps.children;
  var clonedNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(n, nodeProps);

  if (children) {
    if (Array.isArray(children) && deep) {
      clonedNode.children = cloneElement(children);
    } else {
      clonedNode.children = children;
    }
  }

  return clonedNode;
}
function addEvent(node, event, callback) {
  if (!node.props) {
    node.props = {};
  }

  if (node.props[event]) {
    node.props[event] = [node.props[event], callback];
  } else {
    node.props[event] = callback;
  }
}
// CONCATENATED MODULE: ./src/components/_util/get-transition-props.ts



var get_transition_props_noop = function noop() {};

var get_transition_props_getTransitionProps = function getTransitionProps(transitionName) {
  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var beforeEnter = opt.beforeEnter,
      enter = opt.enter,
      afterEnter = opt.afterEnter,
      leave = opt.leave,
      afterLeave = opt.afterLeave,
      _opt$appear = opt.appear,
      appear = _opt$appear === void 0 ? true : _opt$appear,
      tag = opt.tag,
      nativeOn = opt.nativeOn;
  var transitionProps = Object.assign({
    appear: appear,
    css: false,
    onBeforeEnter: beforeEnter || get_transition_props_noop,
    onEnter: enter || function (el, done) {
      css_animation(el, "".concat(transitionName, "-enter"), done);
    },
    onAfterEnter: afterEnter || get_transition_props_noop,
    onLeave: leave || function (el, done) {
      css_animation(el, "".concat(transitionName, "-leave"), done);
    },
    onAfterLeave: afterLeave || get_transition_props_noop
  }, nativeOn); // transition-group

  if (tag) {
    transitionProps.tag = tag;
  }

  return transitionProps;
};

/* harmony default export */ var get_transition_props = (get_transition_props_getTransitionProps);
// CONCATENATED MODULE: ./src/components/vc-tree/src/tree-node.tsx



function tree_node_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tree_node_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tree_node_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tree_node_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }









function tree_node_noop() {}

var ICON_OPEN = 'open';
var ICON_CLOSE = 'close';
var defaultTitle = '---';
var TreeNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'TreeNode',
  __ANT_TREE_NODE: true,
  props: initDefaultProps({
    eventKey: vue_types.oneOfType([vue_types.string, vue_types.number]),
    prefixCls: vue_types.string,
    // className: PropTypes.string,
    root: vue_types.object,
    // onSelect: PropTypes.func,
    // By parent
    expanded: vue_types.bool,
    selected: vue_types.bool,
    checked: vue_types.bool,
    loaded: vue_types.bool,
    loading: vue_types.bool,
    halfChecked: vue_types.bool,
    title: vue_types.any,
    pos: vue_types.string,
    dragOver: vue_types.bool,
    dragOverGapTop: vue_types.bool,
    dragOverGapBottom: vue_types.bool,
    // By user
    isLeaf: vue_types.bool,
    checkable: vue_types.bool,
    selectable: vue_types.bool,
    disabled: vue_types.bool,
    disableCheckbox: vue_types.bool,
    icon: vue_types.any,
    dataRef: vue_types.object,
    switcherIcon: vue_types.any,
    label: vue_types.any,
    value: vue_types.any
  }, {}),
  setup: function setup($props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;
    var dragNodeHighlight = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var vcTreeNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('vcTreeNode');
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])('vcTreeNode', instance);
    var vcTree = tree_useTree();

    var onSelectorClick = function onSelectorClick(e) {
      // Click trigger before select/check operation
      var onNodeClick = vcTree.onNodeClick;
      onNodeClick(e, instance);

      if (isSelectable()) {
        onSelect(e);
      } else {
        onCheck(e);
      }
    };

    var onSelectorDoubleClick = function onSelectorDoubleClick(e) {
      var onNodeDoubleClick = vcTree.onNodeDoubleClick;
      onNodeDoubleClick(e, instance);
    };

    var onSelect = function onSelect(e) {
      if (isDisabled()) {
        return;
      }

      var onNodeSelect = vcTree.onNodeSelect;
      e.preventDefault();
      onNodeSelect(e, instance);
    };

    var onCheck = function onCheck(e) {
      if (isDisabled()) {
        return;
      }

      var disableCheckbox = $props.disableCheckbox,
          checked = $props.checked;
      var onNodeCheck = vcTree.onNodeCheck;

      if (!isCheckable() || disableCheckbox) {
        return;
      }

      e.preventDefault();
      var targetChecked = !checked;
      onNodeCheck(e, instance, targetChecked);
    };

    var onMouseEnter = function onMouseEnter(e) {
      var onNodeMouseEnter = vcTree.onNodeMouseEnter;
      onNodeMouseEnter(e, instance);
    };

    var onMouseLeave = function onMouseLeave(e) {
      var onNodeMouseLeave = vcTree.onNodeMouseLeave;
      onNodeMouseLeave(e, instance);
    };

    var onContextMenu = function onContextMenu(e) {
      var onNodeContextMenu = vcTree.onNodeContextMenu;
      onNodeContextMenu(e, instance);
    };

    var onDragStart = function onDragStart(e) {
      var onNodeDragStart = vcTree.onNodeDragStart;
      e.stopPropagation();
      dragNodeHighlight.value = true;
      onNodeDragStart(e, instance);

      try {
        // ie throw error
        // firefox-need-it
        e.dataTransfer.setData('text/plain', '');
      } catch (error) {// empty
      }
    };

    var onDragEnter = function onDragEnter(e) {
      var onNodeDragEnter = vcTree.onNodeDragEnter;
      e.preventDefault();
      e.stopPropagation();
      onNodeDragEnter(e, instance);
    };

    var onDragOver = function onDragOver(e) {
      var onNodeDragOver = vcTree.onNodeDragOver;
      e.preventDefault();
      e.stopPropagation();
      onNodeDragOver(e, instance);
    };

    var onDragLeave = function onDragLeave(e) {
      var onNodeDragLeave = vcTree.onNodeDragLeave;
      e.stopPropagation();
      onNodeDragLeave(e, instance);
    };

    var onDragEnd = function onDragEnd(e) {
      var onNodeDragEnd = vcTree.onNodeDragEnd;
      e.stopPropagation();
      dragNodeHighlight.value = false;
      onNodeDragEnd(e, instance);
    };

    var onDrop = function onDrop(e) {
      var onNodeDrop = vcTree.onNodeDrop;
      e.preventDefault();
      e.stopPropagation();
      dragNodeHighlight.value = false;
      onNodeDrop(e, instance);
    };

    var onExpand = function onExpand(e) {
      var onNodeExpand = vcTree.onNodeExpand;
      onNodeExpand(e, instance);
    };

    var getNodeChildren = function getNodeChildren() {
      var children = slots["default"] && slots["default"]();
      var originList = filterEmpty(children);
      var targetList = getRealNodeChildren(originList);

      if (originList.length !== targetList.length) {
        warnOnlyTreeNode();
      }

      return targetList;
    };

    var getNodeState = function getNodeState() {
      var expanded = $props.expanded;

      if (isLeaf2()) {
        return null;
      }

      return expanded ? ICON_OPEN : ICON_CLOSE;
    };

    var isLeaf2 = function isLeaf2() {
      var isLeaf = $props.isLeaf,
          loaded = $props.loaded;
      var loadData = vcTree.loadData;
      var hasChildren = getNodeChildren().length !== 0;

      if (isLeaf === false) {
        return false;
      }

      return isLeaf || !loadData && !hasChildren || loadData && loaded && !hasChildren;
    };

    var isDisabled = function isDisabled() {
      var disabled = $props.disabled;
      var treeDisabled = vcTree.disabled; // Follow the logic of Selectable

      if (disabled === false) {
        return false;
      }

      return !!(treeDisabled || disabled);
    };

    var isCheckable = function isCheckable() {
      var checkable = $props.checkable;
      var treeCheckable = vcTree.checkable; // Return false if tree or treeNode is not checkable

      if (!treeCheckable || checkable === false) {
        return false;
      }

      return treeCheckable;
    };

    var syncLoadData = function syncLoadData(props) {
      var expanded = props.expanded,
          loading = props.loading,
          loaded = props.loaded;
      var loadData = vcTree.loadData,
          onNodeLoad = vcTree.onNodeLoad;

      if (loading) {
        return;
      } // read from state to avoid loadData at same time


      if (loadData && expanded && !isLeaf2()) {
        // We needn't reload data when has children in sync logic
        // It's only needed in node expanded
        var hasChildren = getNodeChildren().length !== 0;

        if (!hasChildren && !loaded) {
          onNodeLoad(instance);
        }
      }
    };

    var isSelectable = function isSelectable() {
      var selectable = $props.selectable;
      var treeSelectable = vcTree.selectable; // Ignore when selectable is undefined or null

      if (typeof selectable === 'boolean') {
        return selectable;
      }

      return treeSelectable;
    };

    var renderSwitcher = function renderSwitcher() {
      var expanded = $props.expanded;
      var prefixCls = vcTree.prefixCls;
      var switcherIcon = getComponentFromContext({
        $props: $props,
        $slots: slots
      }, 'switcherIcon', {}, false) || getComponentFromContext(vcTree, 'switcherIcon', {}, false);

      if (isLeaf2()) {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
          "key": "switcher",
          "class": classnames_default()("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher-noop"))
        }, [typeof switcherIcon === 'function' ? switcherIcon(Object.assign(Object.assign(Object.assign({}, $props), $props.dataRef), {
          isLeaf: true
        })) : switcherIcon]);
      }

      var switcherCls = classnames_default()("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher_").concat(expanded ? ICON_OPEN : ICON_CLOSE));
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "key": "switcher",
        "onClick": onExpand,
        "class": switcherCls
      }, [typeof switcherIcon === 'function' ? switcherIcon(Object.assign(Object.assign(Object.assign({}, $props), $props.dataRef), {
        isLeaf: false
      })) : switcherIcon]);
    };

    var renderCheckbox = function renderCheckbox() {
      var checked = $props.checked,
          halfChecked = $props.halfChecked,
          disableCheckbox = $props.disableCheckbox;
      var prefixCls = vcTree.prefixCls;
      var disabled = isDisabled();
      var checkable = isCheckable();

      if (!checkable) {
        return null;
      } // [Legacy] Custom element should be separate with `checkable` in future


      var $custom = typeof checkable !== 'boolean' ? checkable : null;
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "key": "checkbox",
        "class": classnames_default()("".concat(prefixCls, "-checkbox"), checked && "".concat(prefixCls, "-checkbox-checked"), !checked && halfChecked && "".concat(prefixCls, "-checkbox-indeterminate"), (disabled || disableCheckbox) && "".concat(prefixCls, "-checkbox-disabled")),
        "onClick": onCheck
      }, [$custom]);
    };

    var renderIcon = function renderIcon() {
      var loading = $props.loading;
      var prefixCls = vcTree.prefixCls;
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "key": "icon",
        "class": classnames_default()("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__").concat(getNodeState() || 'docu'), loading && "".concat(prefixCls, "-icon_loading"))
      }, []);
    };

    var renderSelector = function renderSelector() {
      var selected = $props.selected,
          loading = $props.loading;
      var icon = getComponentFromContext({
        $props: $props,
        $slots: slots
      }, 'icon', {}, false);
      var prefixCls = vcTree.prefixCls,
          showIcon = vcTree.showIcon,
          treeIcon = vcTree.icon,
          draggable = vcTree.draggable,
          loadData = vcTree.loadData;
      var disabled = isDisabled();
      var title = getComponentFromContext({
        $props: $props,
        $slots: slots
      }, 'title', {}, false);
      var wrapClass = "".concat(prefixCls, "-node-content-wrapper"); // Icon - Still show loading icon when loading without showIcon

      var $icon;

      if (showIcon) {
        var currentIcon = icon || treeIcon;
        $icon = currentIcon ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
          "class": classnames_default()("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__customize"))
        }, [typeof currentIcon === 'function' ? currentIcon(Object.assign(Object.assign({}, $props), $props.dataRef)) : currentIcon]) : renderIcon();
      } else if (loadData && loading) {
        $icon = renderIcon();
      }

      var currentTitle = title;
      var $title = currentTitle ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-title")
      }, [typeof currentTitle === 'function' ? currentTitle(Object.assign(Object.assign({}, $props), $props.dataRef)) : currentTitle]) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-title")
      }, [defaultTitle]);
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "key": "selector",
        "ref": "selectHandle",
        "title": typeof title === 'string' ? title : '',
        "class": classnames_default()("".concat(wrapClass), "".concat(wrapClass, "-").concat(getNodeState() || 'normal'), !disabled && (selected || dragNodeHighlight.value) && "".concat(prefixCls, "-node-selected"), !disabled && draggable && 'draggable'),
        "draggable": !disabled && draggable || undefined,
        "aria-grabbed": !disabled && draggable || undefined,
        "onMouseenter": onMouseEnter,
        "onMouseleave": onMouseLeave,
        "onContextmenu": onContextMenu,
        "onClick": onSelectorClick,
        "onDblclick": onSelectorDoubleClick,
        "onDragstart": draggable ? onDragStart : tree_node_noop
      }, [$icon, $title]);
    };

    var renderChildren = function renderChildren() {
      var expanded = $props.expanded,
          pos = $props.pos;
      var prefixCls = vcTree.prefixCls,
          openTransitionName = vcTree.openTransitionName,
          openAnimation = vcTree.openAnimation,
          renderTreeNode = vcTree.renderTreeNode;
      var animProps = {};

      if (openTransitionName) {
        animProps = get_transition_props(openTransitionName);
      } else if (typeof_default()(openAnimation) === 'object') {
        animProps = Object.assign({}, openAnimation);
        Object.assign(animProps, Object.assign({
          css: false
        }, animProps));
      } // Children TreeNode


      var nodeList = getNodeChildren();

      if (nodeList.length === 0) {
        return null;
      }

      var $children;

      if (expanded) {
        $children = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("ul", {
          "class": classnames_default()("".concat(prefixCls, "-child-tree"), expanded && "".concat(prefixCls, "-child-tree-open")),
          "data-expanded": expanded,
          "role": "group"
        }, [mapChildren(unwrapFragment(nodeList), function (node, index) {
          return renderTreeNode(node, index, pos);
        })]);
      }

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], tree_node_objectSpread({}, animProps), [$children]);
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      var eventKey = $props.eventKey;
      var registerTreeNode = vcTree.registerTreeNode;
      syncLoadData($props);
      registerTreeNode && registerTreeNode(eventKey, instance);
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      syncLoadData($props);
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      var eventKey = $props.eventKey;
      var registerTreeNode = vcTree.registerTreeNode;
      registerTreeNode && registerTreeNode(eventKey, null);
    });
    return {
      onSelectorClick: onSelectorClick,
      onSelectorDoubleClick: onSelectorDoubleClick,
      onSelect: onSelect,
      onCheck: onCheck,
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave,
      onContextMenu: onContextMenu,
      onDragStart: onDragStart,
      onDragEnter: onDragEnter,
      onDragOver: onDragOver,
      onDragLeave: onDragLeave,
      onDragEnd: onDragEnd,
      onDrop: onDrop,
      onExpand: onExpand,
      getNodeChildren: getNodeChildren,
      getNodeState: getNodeState,
      isLeaf2: isLeaf2,
      isDisabled: isDisabled,
      isCheckable: isCheckable,
      syncLoadData: syncLoadData,
      isSelectable: isSelectable,
      renderSwitcher: renderSwitcher,
      renderCheckbox: renderCheckbox,
      renderIcon: renderIcon,
      renderSelector: renderSelector,
      renderChildren: renderChildren,
      vcTree: vcTree
    };
  },
  render: function render() {
    var _ref2;

    var _this$$props = this.$props,
        dragOver = _this$$props.dragOver,
        dragOverGapTop = _this$$props.dragOverGapTop,
        dragOverGapBottom = _this$$props.dragOverGapBottom,
        isLeaf = _this$$props.isLeaf,
        expanded = _this$$props.expanded,
        selected = _this$$props.selected,
        checked = _this$$props.checked,
        halfChecked = _this$$props.halfChecked,
        loading = _this$$props.loading;
    var _this$vcTree = this.vcTree,
        prefixCls = _this$vcTree.prefixCls,
        filterTreeNode = _this$vcTree.filterTreeNode,
        draggable = _this$vcTree.draggable;
    var disabled = this.isDisabled();
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
      "class": (_ref2 = {}, defineProperty_default()(_ref2, "".concat(prefixCls, "-treenode-disabled"), disabled), defineProperty_default()(_ref2, "".concat(prefixCls, "-treenode-switcher-").concat(expanded ? 'open' : 'close'), !isLeaf), defineProperty_default()(_ref2, "".concat(prefixCls, "-treenode-checkbox-checked"), checked), defineProperty_default()(_ref2, "".concat(prefixCls, "-treenode-checkbox-indeterminate"), halfChecked), defineProperty_default()(_ref2, "".concat(prefixCls, "-treenode-selected"), selected), defineProperty_default()(_ref2, "".concat(prefixCls, "-treenode-loading"), loading), defineProperty_default()(_ref2, 'drag-over', !disabled && dragOver), defineProperty_default()(_ref2, 'drag-over-gap-top', !disabled && dragOverGapTop), defineProperty_default()(_ref2, 'drag-over-gap-bottom', !disabled && dragOverGapBottom), defineProperty_default()(_ref2, 'filter-node', filterTreeNode && filterTreeNode(this)), _ref2),
      "role": "treeitem",
      "onDragenter": draggable ? this.onDragEnter : tree_node_noop,
      "onDragover": draggable ? this.onDragOver : tree_node_noop,
      "onDragleave": draggable ? this.onDragLeave : tree_node_noop,
      "onDrop": draggable ? this.onDrop : tree_node_noop,
      "onDragend": draggable ? this.onDragEnd : tree_node_noop
    }, [this.renderSwitcher(), this.renderCheckbox(), this.renderSelector(), this.renderChildren()]);
  }
});
TreeNode.isTreeNode = 1;
/* harmony default export */ var tree_node = (TreeNode);
// CONCATENATED MODULE: ./src/components/vc-tree/src/util.tsx






function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function util_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function util_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { util_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { util_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }





var DRAG_SIDE_RANGE = 0.25;
var DRAG_MIN_GAP = 2;
var onlyTreeNodeWarned = false;
function warnOnlyTreeNode() {
  if (onlyTreeNodeWarned) {
    return;
  }

  onlyTreeNodeWarned = true;
}
function arrDel(list, value) {
  var clone = list.slice();
  var index = clone.indexOf(value);

  if (index >= 0) {
    clone.splice(index, 1);
  }

  return clone;
}
function arrAdd(list, value) {
  var clone = list.slice();

  if (clone.indexOf(value) === -1) {
    clone.push(value);
  }

  return clone;
}
function posToArr(pos) {
  return pos.split('-');
}
function getPosition(level, index) {
  return "".concat(level, "-").concat(index);
}
function isTreeNode(node) {
  var type = node.type;
  return type && typeof_default()(type) === 'object' && type.isTreeNode;
}
function getRealNodeChildren() {
  var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (children.length === 1 && Array.isArray(children[0])) {
    return children[0].filter(isTreeNode);
  }

  if (Array.isArray(children)) {
    return children.filter(isTreeNode);
  }

  if (children['default']) {
    return children['default']().filter(isTreeNode);
  }

  return [];
}
function isCheckDisabled(node) {
  var _ref = getOptionProps(node) || {},
      disabled = _ref.disabled,
      disableCheckbox = _ref.disableCheckbox,
      checkable = _ref.checkable;

  return !!(disabled || disableCheckbox) || checkable === false;
}
function traverseTreeNodes(treeNodes, callback) {
  function processNode(node, index, parent) {
    var pos = node ? getPosition(parent.pos, index) : 0; // Filter children
    // Process node if is not root

    if (node) {
      var key = node.key;

      if (!key && (key === undefined || key === null)) {
        key = pos;
      }

      var data = {
        node: node,
        index: index,
        pos: pos,
        key: key,
        parentPos: parent.node ? parent.pos : null
      };
      callback(data);
    }

    var children = node ? node.children : treeNodes;

    if (!children) {
      return;
    }

    var childList = getRealNodeChildren(children); // Process children node

    childList.forEach(function (subNode, subIndex) {
      processNode(subNode, subIndex, {
        node: node,
        pos: pos
      });
    });
  }

  processNode(null);
}
/**
 * Use `rc-util` `toArray` to get the children list which keeps the key.
 * And return single node if children is only one(This can avoid `key` missing check).
 */

function mapChildren() {
  var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var func = arguments.length > 1 ? arguments[1] : undefined;
  var list = children.map(func);

  if (list.length === 1) {
    return list[0];
  }

  return list;
}
function getDragNodesKeys(treeNodes, node) {
  var _getOptionProps = getOptionProps(node),
      eventKey = _getOptionProps.eventKey,
      pos = _getOptionProps.pos;

  var dragNodesKeys = [];
  traverseTreeNodes(treeNodes, function (_ref2) {
    var key = _ref2.key;
    dragNodesKeys.push(key);
  });
  dragNodesKeys.push(eventKey || pos);
  return dragNodesKeys;
}
function calcDropPosition(event, treeNode) {
  var clientY = event.clientY;

  var _treeNode$refs$select = treeNode.refs.selectHandle.getBoundingClientRect(),
      top = _treeNode$refs$select.top,
      bottom = _treeNode$refs$select.bottom,
      height = _treeNode$refs$select.height;

  var des = Math.max(height * DRAG_SIDE_RANGE, DRAG_MIN_GAP);

  if (clientY <= top + des) {
    return -1;
  }

  if (clientY >= bottom - des) {
    return 1;
  }

  return 0;
}
/**
 * Return selectedKeys according with multiple prop
 * @param selectedKeys
 * @param props
 * @returns [string]
 */

function calcSelectedKeys(selectedKeys, props) {
  if (!selectedKeys) {
    return undefined;
  }

  var multiple = props.multiple;

  if (multiple) {
    return selectedKeys.slice();
  }

  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }

  return selectedKeys;
}
/**
 * Since React internal will convert key to string,
 * we need do this to avoid `checkStrictly` use number match
 */
// function keyListToString (keyList) {
//   if (!keyList) return keyList
//   return keyList.map(key => String(key))
// }

var util_internalProcessProps = function internalProcessProps() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return Object.assign(Object.assign({}, es(props, ['on', 'key', 'class', 'className', 'style'])), {
    "class": props["class"] || props.className,
    style: props.style,
    key: props.key
  });
};

function convertDataToTree(treeData, processor) {
  if (!treeData) {
    return [];
  }

  var _ref3 = processor || {},
      _ref3$processProps = _ref3.processProps,
      processProps = _ref3$processProps === void 0 ? util_internalProcessProps : _ref3$processProps;

  var list = Array.isArray(treeData) ? treeData : [treeData];
  return list.map(function (_a) {
    var children = _a.children,
        props = __rest(_a, ["children"]);

    var childrenNodes = convertDataToTree(children, processor);
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(tree_node, util_objectSpread({}, processProps(props)), [childrenNodes]);
  });
} // TODO: ========================= NEW LOGIC =========================

/**
 * Calculate treeNodes entities. `processTreeEntity` is used for `rc-tree-select`
 * @param treeNodes
 * @param processTreeEntity  User can customize the entity
 */

function convertTreeToEntities(treeNodes) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      initWrapper = _ref4.initWrapper,
      processEntity = _ref4.processEntity,
      onProcessFinished = _ref4.onProcessFinished;

  var posEntities = new Map();
  var keyEntities = new Map();
  var wrapper = {
    posEntities: posEntities,
    keyEntities: keyEntities
  };

  if (initWrapper) {
    wrapper = initWrapper(wrapper) || wrapper;
  }

  traverseTreeNodes(unwrapFragment(treeNodes), function (item) {
    var node = item.node,
        index = item.index,
        pos = item.pos,
        key = item.key,
        parentPos = item.parentPos;
    var entity = {
      node: node,
      index: index,
      key: key,
      pos: pos
    };
    posEntities.set(pos, entity);
    keyEntities.set(key, entity); // Fill children

    entity.parent = posEntities.get(parentPos);

    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }

    if (processEntity) {
      processEntity(entity, wrapper);
    }
  });

  if (onProcessFinished) {
    onProcessFinished(wrapper);
  }

  return wrapper;
}
/**
 * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style
 */

function parseCheckedKeys(keys) {
  if (!keys) {
    return null;
  } // Convert keys to object format


  var keyProps;

  if (Array.isArray(keys)) {
    // [Legacy] Follow the api doc
    keyProps = {
      checkedKeys: keys,
      halfCheckedKeys: undefined
    };
  } else if (typeof_default()(keys) === 'object') {
    keyProps = {
      checkedKeys: keys.checked || undefined,
      halfCheckedKeys: keys.halfChecked || undefined
    };
  } else {
    return null;
  } // keyProps.checkedKeys = keyListToString(keyProps.checkedKeys)
  // keyProps.halfCheckedKeys = keyListToString(keyProps.halfCheckedKeys)


  return keyProps;
}
/**
 * Conduct check state by the keyList. It will conduct up & from the provided key.
 * If the conduct path reach the disabled or already checked / unchecked node will stop conduct.
 * @param keyList       list of keys
 * @param isCheck       is check the node or not
 * @param keyEntities   parsed by `convertTreeToEntities` function in Tree
 * @param checkStatus   Can pass current checked status for process (usually for uncheck operation)
 * @returns {{checkedKeys: [], halfCheckedKeys: []}}
 */

function conductCheck(keyList, isCheck, keyEntities) {
  var checkStatus = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var checkedKeys = new Map();
  var halfCheckedKeys = new Map(); // Record the key has some child checked (include child half checked)

  (checkStatus.checkedKeys || []).forEach(function (key) {
    checkedKeys.set(key, true);
  });
  (checkStatus.halfCheckedKeys || []).forEach(function (key) {
    halfCheckedKeys.set(key, true);
  }); // Conduct up

  function conductUp(key) {
    if (checkedKeys.get(key) === isCheck) {
      return;
    }

    var entity = keyEntities.get(key);

    if (!entity) {
      return;
    }

    var children = entity.children,
        parent = entity.parent,
        node = entity.node;

    if (isCheckDisabled(node)) {
      return;
    } // Check child node checked status


    var everyChildChecked = true;
    var someChildChecked = false; // Child checked or half checked

    (children || []).filter(function (child) {
      return !isCheckDisabled(child.node);
    }).forEach(function (_ref5) {
      var childKey = _ref5.key;
      var childChecked = checkedKeys.get(childKey);
      var childHalfChecked = halfCheckedKeys.get(childKey);

      if (childChecked || childHalfChecked) {
        someChildChecked = true;
      }

      if (!childChecked) {
        everyChildChecked = false;
      }
    }); // Update checked status

    if (isCheck) {
      checkedKeys.set(key, everyChildChecked);
    } else {
      checkedKeys.set(key, false);
    }

    halfCheckedKeys.set(key, someChildChecked);

    if (parent) {
      conductUp(parent.key);
    }
  } // Conduct down


  function conductDown(key) {
    if (checkedKeys.get(key) === isCheck) {
      return;
    }

    var entity = keyEntities.get(key);

    if (!entity) {
      return;
    }

    var children = entity.children,
        node = entity.node;

    if (isCheckDisabled(node)) {
      return;
    }

    checkedKeys.set(key, isCheck);
    (children || []).forEach(function (child) {
      conductDown(child.key);
    });
  }

  function conduct(key) {
    var entity = keyEntities.get(key);

    if (!entity) {
      return;
    }

    var children = entity.children,
        parent = entity.parent,
        node = entity.node;
    checkedKeys.set(key, isCheck);

    if (isCheckDisabled(node)) {
      return;
    } // Conduct down


    (children || []).filter(function (child) {
      return !isCheckDisabled(child.node);
    }).forEach(function (child) {
      conductDown(child.key);
    }); // Conduct up

    if (parent) {
      conductUp(parent.key);
    }
  }

  (keyList || []).forEach(function (key) {
    conduct(key);
  });
  var checkedKeyList = [];
  var halfCheckedKeyList = []; // Fill checked list

  var _iterator = _createForOfIteratorHelper(checkedKeys),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = slicedToArray_default()(_step.value, 2),
          key = _step$value[0],
          value = _step$value[1];

      if (value) {
        checkedKeyList.push(key);
      }
    } // Fill half checked list

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var _iterator2 = _createForOfIteratorHelper(halfCheckedKeys),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = slicedToArray_default()(_step2.value, 2),
          _key = _step2$value[0],
          _value = _step2$value[1];

      if (!checkedKeys.get(_key) && _value) {
        halfCheckedKeyList.push(_key);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return {
    checkedKeys: checkedKeyList,
    halfCheckedKeys: halfCheckedKeyList
  };
}
/**
 * If user use `autoExpandParent` we should get the list of parent node
 * @param keyList
 * @param keyEntities
 */

function conductExpandParent(keyList, keyEntities) {
  var expandedKeys = new Map();

  function conductUp(key) {
    if (expandedKeys.get(key)) {
      return;
    }

    var entity = keyEntities.get(key);

    if (!entity) {
      return;
    }

    expandedKeys.set(key, true);
    var parent = entity.parent,
        node = entity.node;
    var props = getOptionProps(node);

    if (props && props.disabled) {
      return;
    }

    if (parent) {
      conductUp(parent.key);
    }
  }

  (keyList || []).forEach(function (key) {
    conductUp(key);
  });
  return toConsumableArray_default()(expandedKeys.keys());
}
/**
 * Returns only the data- and aria- key/value pairs
 * @param {object} props
 */

function getDataAndAria(props) {
  return Object.keys(props).reduce(function (prev, key) {
    if (key.substr(0, 5) === 'data-' || key.substr(0, 5) === 'aria-') {
      prev[key] = props[key];
    }

    return prev;
  }, {});
}
// CONCATENATED MODULE: ./src/components/vc-tree/src/tree.tsx









/**
 * Thought we still use `cloneElement` to pass `key`,
 * other props can pass with context for future refactor.
 */

var tree_useTree = function useTree() {
  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('vcTree');
};
var Tree = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'Tree',
  inheritAttrs: false,
  props: initDefaultProps({
    prefixCls: vue_types.string,
    tabIndex: vue_types.oneOfType([vue_types.string, vue_types.number]),
    treeData: vue_types.array,
    showLine: vue_types.bool,
    showIcon: vue_types.bool,
    icon: vue_types.oneOfType([vue_types.object, vue_types.func]),
    focusable: vue_types.bool,
    selectable: vue_types.bool,
    disabled: vue_types.bool,
    multiple: vue_types.bool,
    checkable: vue_types.oneOfType([vue_types.object, vue_types.bool]),
    checkStrictly: vue_types.bool,
    draggable: vue_types.bool,
    defaultExpandParent: vue_types.bool,
    autoExpandParent: vue_types.bool,
    defaultExpandAll: vue_types.bool,
    defaultExpandedKeys: vue_types.array,
    expandedKeys: vue_types.array,
    defaultCheckedKeys: vue_types.array,
    checkedKeys: vue_types.oneOfType([vue_types.array, vue_types.object]),
    defaultSelectedKeys: vue_types.array,
    selectedKeys: vue_types.array,
    loadData: vue_types.func,
    loadedKeys: vue_types.array,
    filterTreeNode: vue_types.func,
    openTransitionName: vue_types.string,
    openAnimation: vue_types.oneOfType([vue_types.string, vue_types.object]),
    switcherIcon: vue_types.any,
    _propsSymbol: vue_types.any
  }, {
    prefixCls: 'rc-tree',
    showLine: false,
    showIcon: true,
    selectable: true,
    multiple: false,
    checkable: false,
    disabled: false,
    checkStrictly: false,
    draggable: false,
    defaultExpandParent: true,
    autoExpandParent: false,
    defaultExpandAll: false,
    defaultExpandedKeys: [],
    defaultCheckedKeys: [],
    defaultSelectedKeys: []
  }),
  provide: function provide() {
    return {
      vcTree: this
    };
  },
  setup: function setup($props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])('vcTree', instance);

    var getDerivedStateFromProps = function getDerivedStateFromProps(prevState) {
      var _prevProps = prevState._prevProps;
      var newState = {
        _prevProps: Object.assign({}, $props)
      };

      function needSync(name) {
        return !_prevProps && $props[name] !== undefined || _prevProps;
      } // ================== Tree Node ==================


      var treeNode = null; // Check if `treeData` or `children` changed and save into the state.

      if (needSync('treeData')) {
        treeNode = convertDataToTree($props.treeData);
      } else {
        treeNode = slots["default"] && slots["default"]();
      } // Tree support filter function which will break the tree structure in the vdm.
      // We cache the treeNodes in state so that we can return the treeNode in event trigger.


      if (treeNode) {
        newState._treeNode = treeNode; // Calculate the entities data for quick match

        var entitiesMap = convertTreeToEntities(treeNode);
        newState._keyEntities = entitiesMap.keyEntities;
      }

      var keyEntities = newState._keyEntities || prevState._keyEntities; // ================ expandedKeys =================

      if ($props.expandedKeys || _prevProps && $props.autoExpandParent) {
        newState._expandedKeys = $props.autoExpandParent || !_prevProps && $props.defaultExpandParent ? conductExpandParent($props.expandedKeys, keyEntities) : $props.expandedKeys;
      } else if (!_prevProps && $props.defaultExpandAll) {
        newState._expandedKeys = toConsumableArray_default()(keyEntities.keys());
      } else if (!_prevProps && $props.defaultExpandedKeys) {
        newState._expandedKeys = $props.autoExpandParent || $props.defaultExpandParent ? conductExpandParent($props.defaultExpandedKeys, keyEntities) : $props.defaultExpandedKeys;
      } // ================ selectedKeys =================


      if ($props.selectable) {
        if (needSync('selectedKeys')) {
          newState._selectedKeys = calcSelectedKeys($props.selectedKeys, $props);
        } else if (!_prevProps && $props.defaultSelectedKeys) {
          newState._selectedKeys = calcSelectedKeys($props.defaultSelectedKeys, $props);
        }
      } // ================= checkedKeys =================


      if ($props.checkable) {
        var checkedKeyEntity;

        if (needSync('checkedKeys')) {
          checkedKeyEntity = parseCheckedKeys($props.checkedKeys) || {};
        } else if (!_prevProps && $props.defaultCheckedKeys) {
          checkedKeyEntity = parseCheckedKeys($props.defaultCheckedKeys) || {};
        } else if (treeNode) {
          // If treeNode changed, we also need check it
          checkedKeyEntity = parseCheckedKeys($props.checkedKeys) || {
            checkedKeys: prevState._checkedKeys,
            halfCheckedKeys: prevState._halfCheckedKeys
          };
        }

        if (checkedKeyEntity) {
          var _checkedKeyEntity = checkedKeyEntity,
              _checkedKeyEntity$che = _checkedKeyEntity.checkedKeys,
              checkedKeys = _checkedKeyEntity$che === void 0 ? [] : _checkedKeyEntity$che,
              _checkedKeyEntity$hal = _checkedKeyEntity.halfCheckedKeys,
              halfCheckedKeys = _checkedKeyEntity$hal === void 0 ? [] : _checkedKeyEntity$hal;

          if (!$props.checkStrictly) {
            var conductKeys = conductCheck(checkedKeys, true, keyEntities);
            checkedKeys = conductKeys.checkedKeys;
            halfCheckedKeys = conductKeys.halfCheckedKeys;
          }

          newState._checkedKeys = checkedKeys;
          newState._halfCheckedKeys = halfCheckedKeys;
        }
      } // ================= loadedKeys ==================


      if (needSync('loadedKeys')) {
        newState._loadedKeys = $props.loadedKeys || [];
      }

      return newState;
    };

    var getState = function getState() {
      var localState = {
        _posEntities: new Map(),
        _keyEntities: new Map(),
        _expandedKeys: [],
        _selectedKeys: [],
        _checkedKeys: [],
        _halfCheckedKeys: [],
        _loadedKeys: [],
        _loadingKeys: [],
        _treeNode: [],
        _prevProps: null,
        _dragOverNodeKey: '',
        _dropPosition: null,
        _dragNodesKeys: []
      };
      return Object.assign(Object.assign({
        domTreeNodes: {}
      }, localState), getDerivedStateFromProps(localState));
    };

    var _useState = state_useState(getState()),
        $state = _useState.state,
        setState = _useState.setState;

    var createWatch = function createWatch() {
      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      keys.forEach(function (k) {
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
          return $props[k];
        }, function (v) {
          setState(getDerivedStateFromProps($state));
        });
      });
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $state._expandedKeys;
    }, function (v) {
      if (v === undefined) {
        throw new Error('1');
      }
    });
    createWatch(['treeData', 'children', 'expandedKeys', 'autoExpandParent', 'selectedKeys', 'checkedKeys', 'loadedKeys']);
    var delayedDragEnterLogic = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var dragNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var onNodeDragStart = function onNodeDragStart(event, node) {
      var _expandedKeys = $state._expandedKeys;
      var eventKey = node.eventKey;
      var children = getSlotsFromInstance(node)["default"];
      dragNode.value = node;
      setState({
        _dragNodesKeys: getDragNodesKeys(typeof children === 'function' ? children() : children, node),
        _expandedKeys: arrDel(_expandedKeys, eventKey)
      });
      emit('dragstart', {
        event: event,
        node: node
      });
    };

    var onNodeDragEnter = function onNodeDragEnter(event, node) {
      var expandedKeys = $state._expandedKeys;
      var _node$ctx = node.ctx,
          pos = _node$ctx.pos,
          eventKey = _node$ctx.eventKey;

      if (!dragNode.value || !node.refs.selectHandle) {
        return;
      }

      var dropPosition = calcDropPosition(event, node); // Skip if drag node is self

      if (dragNode.value.eventKey === eventKey && dropPosition === 0) {
        setState({
          _dragOverNodeKey: '',
          _dropPosition: null
        });
        return;
      } // Ref: https://github.com/react-component/tree/issues/132
      // Add timeout to let onDragLevel fire before onDragEnter,
      // so that we can clean drag props for onDragLeave node.
      // Macro task for this:
      // https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-script


      setTimeout(function () {
        // Update drag over node
        setState({
          _dragOverNodeKey: eventKey,
          _dropPosition: dropPosition
        }); // Side effect for delay drag

        if (!delayedDragEnterLogic.value) {
          delayedDragEnterLogic.value = {};
        }

        Object.keys(delayedDragEnterLogic.value).forEach(function (key) {
          clearTimeout(delayedDragEnterLogic.value[key]);
        });
        delayedDragEnterLogic.value[pos] = setTimeout(function () {
          var newExpandedKeys = arrAdd(expandedKeys, eventKey);

          if ($props.expandedKeys === undefined) {
            setState({
              _expandedKeys: newExpandedKeys
            });
          }

          emit('dragenter', {
            event: event,
            node: node,
            expandedKeys: newExpandedKeys
          });
        }, 400);
      }, 0);
    };

    var onNodeDragOver = function onNodeDragOver(event, node) {
      var eventKey = node['ctx'].eventKey;
      var _dragOverNodeKey = $state._dragOverNodeKey,
          _dropPosition = $state._dropPosition; // Update drag position

      if (dragNode.value && eventKey === _dragOverNodeKey && node.refs.selectHandle) {
        var dropPosition = calcDropPosition(event, node);

        if (dropPosition === _dropPosition) {
          return;
        }

        setState({
          _dropPosition: dropPosition
        });
      }

      emit('dragover', {
        event: event,
        node: node
      });
    };

    var onNodeDragLeave = function onNodeDragLeave(event, node) {
      setState({
        _dragOverNodeKey: ''
      });
      emit('dragleave', {
        event: event,
        node: node
      });
    };

    var onNodeDragEnd = function onNodeDragEnd(event, node) {
      setState({
        _dragOverNodeKey: ''
      });
      emit('dragend', {
        event: event,
        node: node
      });
      dragNode.value = null;
    };

    var onNodeDrop = function onNodeDrop(event, node) {
      var _$state$_dragNodesKey = $state._dragNodesKeys,
          _dragNodesKeys = _$state$_dragNodesKey === void 0 ? [] : _$state$_dragNodesKey,
          _dropPosition = $state._dropPosition;

      var _node$ctx2 = node['ctx'],
          eventKey = _node$ctx2.eventKey,
          pos = _node$ctx2.pos;
      setState({
        _dragOverNodeKey: ''
      });

      if (_dragNodesKeys.indexOf(eventKey) !== -1) {
        return;
      }

      var posArr = posToArr(pos);
      var dropResult = {
        event: event,
        node: node,
        dragNode: dragNode.value,
        dragNodesKeys: _dragNodesKeys.slice(),
        dropPosition: _dropPosition + Number(posArr[posArr.length - 1]),
        dropToGap: false
      };

      if (_dropPosition !== 0) {
        dropResult.dropToGap = true;
      }

      emit('drop', dropResult);
      dragNode.value = null;
    };

    var onNodeClick = function onNodeClick(e, treeNode) {
      console.log('node clicked');
      emit('click', e, treeNode);
    };

    var onNodeDoubleClick = function onNodeDoubleClick(e, treeNode) {
      emit('dblclick', e, treeNode);
    };

    var onNodeSelect = function onNodeSelect(e, treeNode) {
      var selectedKeys = $state._selectedKeys;
      var keyEntities = $state._keyEntities;
      var multiple = $props.multiple;

      var _getOptionProps = getOptionProps(treeNode),
          selected = _getOptionProps.selected,
          eventKey = _getOptionProps.eventKey;

      var targetSelected = !selected; // Update selected keys

      if (!targetSelected) {
        selectedKeys = arrDel(selectedKeys, eventKey);
      } else if (!multiple) {
        selectedKeys = [eventKey];
      } else {
        selectedKeys = arrAdd(selectedKeys, eventKey);
      } // [Legacy] Not found related usage in doc or upper libs


      var selectedNodes = selectedKeys.map(function (key) {
        var entity = keyEntities.get(key);

        if (!entity) {
          return null;
        }

        return entity.node;
      }).filter(function (node) {
        return node;
      });
      setState({
        _selectedKeys: selectedKeys
      });
      var eventObj = {
        event: 'select',
        selected: targetSelected,
        node: treeNode,
        selectedNodes: selectedNodes,
        nativeEvent: e
      };
      emit('update:selectedKeys', selectedKeys);
      emit('select', selectedKeys, eventObj);
    };

    var onNodeCheck = function onNodeCheck(e, treeNode, checked) {
      var keyEntities = $state._keyEntities,
          oriCheckedKeys = $state._checkedKeys,
          oriHalfCheckedKeys = $state._halfCheckedKeys;
      var checkStrictly = $props.checkStrictly;

      var _getOptionProps2 = getOptionProps(treeNode),
          eventKey = _getOptionProps2.eventKey; // Prepare trigger arguments


      var checkedObj;
      var eventObj = {
        event: 'check',
        node: treeNode,
        checked: checked,
        nativeEvent: e
      };

      if (checkStrictly) {
        var checkedKeys = checked ? arrAdd(oriCheckedKeys, eventKey) : arrDel(oriCheckedKeys, eventKey);
        var halfCheckedKeys = arrDel(oriHalfCheckedKeys, eventKey);
        checkedObj = {
          checked: checkedKeys,
          halfChecked: halfCheckedKeys
        };
        eventObj.checkedNodes = checkedKeys.map(function (key) {
          return keyEntities.get(key);
        }).filter(function (entity) {
          return entity;
        }).map(function (entity) {
          return entity.node;
        });
        setState({
          _checkedKeys: checkedKeys
        });
      } else {
        var _conductCheck = conductCheck([eventKey], checked, keyEntities, {
          checkedKeys: oriCheckedKeys,
          halfCheckedKeys: oriHalfCheckedKeys
        }),
            _checkedKeys = _conductCheck.checkedKeys,
            _halfCheckedKeys = _conductCheck.halfCheckedKeys;

        checkedObj = _checkedKeys; // [Legacy] This is used for `rc-tree-select`

        eventObj.checkedNodes = [];
        eventObj.checkedNodesPositions = [];
        eventObj.halfCheckedKeys = _halfCheckedKeys;

        _checkedKeys.forEach(function (key) {
          var entity = keyEntities.get(key);

          if (!entity) {
            return;
          }

          var node = entity.node,
              pos = entity.pos;
          eventObj.checkedNodes.push(node);
          eventObj.checkedNodesPositions.push({
            node: node,
            pos: pos
          });
        });

        setState({
          _checkedKeys: _checkedKeys,
          _halfCheckedKeys: _halfCheckedKeys
        });
      }

      emit('check', checkedObj, eventObj);
    };

    var onNodeLoad = function onNodeLoad(treeNode) {
      return new Promise(function (resolve) {
        // We need to get the latest state of loading/loaded keys
        setState(function (_ref2) {
          var _ref2$_loadedKeys = _ref2._loadedKeys,
              loadedKeys = _ref2$_loadedKeys === void 0 ? [] : _ref2$_loadedKeys,
              _ref2$_loadingKeys = _ref2._loadingKeys,
              loadingKeys = _ref2$_loadingKeys === void 0 ? [] : _ref2$_loadingKeys;
          var loadData = $props.loadData;

          var _getOptionProps3 = getOptionProps(treeNode),
              eventKey = _getOptionProps3.eventKey;

          if (!loadData || loadedKeys.indexOf(eventKey) !== -1 || loadingKeys.indexOf(eventKey) !== -1) {
            return {};
          } // Process load data


          var promise = loadData(treeNode);
          promise.then(function () {
            var currentLoadedKeys = $state._loadedKeys,
                currentLoadingKeys = $state._loadingKeys;
            var newLoadedKeys = arrAdd(currentLoadedKeys, eventKey);
            var newLoadingKeys = arrDel(currentLoadingKeys, eventKey); // onLoad should trigger before internal setState to avoid `loadData` trigger twice.
            // https://github.com/ant-design/ant-design/issues/12464

            emit('load', newLoadedKeys, {
              event: 'load',
              node: treeNode
            });
            setState({
              _loadedKeys: newLoadedKeys
            });
            setState({
              _loadingKeys: newLoadingKeys
            });
            resolve();
          });
          return {
            _loadingKeys: arrAdd(loadingKeys, eventKey)
          };
        });
      });
    };

    var onNodeExpand = function onNodeExpand(e, treeNode) {
      var expandedKeys = $state._expandedKeys;
      var loadData = $props.loadData;

      var _getOptionProps4 = getOptionProps(treeNode),
          eventKey = _getOptionProps4.eventKey,
          expanded = _getOptionProps4.expanded; // Update selected keys


      var index = expandedKeys.indexOf(eventKey);
      console.warn(expanded && index !== -1 || !expanded && index === -1, 'Expand state not sync with index check');
      var targetExpanded = !expanded;

      if (targetExpanded) {
        expandedKeys = arrAdd(expandedKeys, eventKey);
      } else {
        expandedKeys = arrDel(expandedKeys, eventKey);
      }

      setState({
        _expandedKeys: expandedKeys
      });
      emit('expand', expandedKeys, {
        node: treeNode,
        expanded: targetExpanded,
        nativeEvent: e
      });
      emit('update:expandedKeys', expandedKeys); // Async Load data

      if (targetExpanded && loadData) {
        var loadPromise = onNodeLoad(treeNode);
        return loadPromise ? loadPromise.then(function () {
          // [Legacy] Refresh logic
          setUncontrolledState({
            _expandedKeys: expandedKeys
          });
        }) : null;
      }

      return null;
    };

    var onNodeMouseEnter = function onNodeMouseEnter(event, node) {
      emit('mouseenter', {
        event: event,
        node: node
      });
    };

    var onNodeMouseLeave = function onNodeMouseLeave(event, node) {
      emit('mouseleave', {
        event: event,
        node: node
      });
    };

    var onNodeContextMenu = function onNodeContextMenu(event, node) {
      event.preventDefault();
      emit('rightClick', {
        event: event,
        node: node
      });
    };

    var setUncontrolledState = function setUncontrolledState(state) {
      var needSync = false;
      var newState = {};
      var props = $props;
      Object.keys(state).forEach(function (name) {
        if (name.replace('_', '') in props) {
          return;
        }

        needSync = true;
        newState[name] = state[name];
      });

      if (needSync) {
        setState(newState);
      }
    };

    var registerTreeNode = function registerTreeNode(key, node) {
      if (node) {
        $state.domTreeNodes[key] = node;
      } else {
        delete $state.domTreeNodes[key];
      }
    };

    var isKeyChecked = function isKeyChecked(key) {
      var _$state$_checkedKeys = $state._checkedKeys,
          checkedKeys = _$state$_checkedKeys === void 0 ? [] : _$state$_checkedKeys;
      return checkedKeys.indexOf(key) !== -1;
    };

    var renderTreeNode = function renderTreeNode(child, index) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var keyEntities = $state._keyEntities,
          _$state$_expandedKeys = $state._expandedKeys,
          expandedKeys = _$state$_expandedKeys === void 0 ? [] : _$state$_expandedKeys,
          _$state$_selectedKeys = $state._selectedKeys,
          selectedKeys = _$state$_selectedKeys === void 0 ? [] : _$state$_selectedKeys,
          _$state$_halfCheckedK = $state._halfCheckedKeys,
          halfCheckedKeys = _$state$_halfCheckedK === void 0 ? [] : _$state$_halfCheckedK,
          _$state$_loadedKeys = $state._loadedKeys,
          loadedKeys = _$state$_loadedKeys === void 0 ? [] : _$state$_loadedKeys,
          _$state$_loadingKeys = $state._loadingKeys,
          loadingKeys = _$state$_loadingKeys === void 0 ? [] : _$state$_loadingKeys,
          dragOverNodeKey = $state._dragOverNodeKey,
          dropPosition = $state._dropPosition;
      var pos = getPosition(level, index);
      var key = child.key;

      if (!key && (key === undefined || key === null)) {
        key = pos;
      }

      if (!keyEntities.get(key)) {
        warnOnlyTreeNode();
        return null;
      }

      return cloneElement(child, {
        eventKey: key,
        expanded: expandedKeys.indexOf(key) !== -1,
        selected: selectedKeys.indexOf(key) !== -1,
        loaded: loadedKeys.indexOf(key) !== -1,
        loading: loadingKeys.indexOf(key) !== -1,
        checked: isKeyChecked(key),
        halfChecked: halfCheckedKeys.indexOf(key) !== -1,
        pos: pos,
        // [Legacy] Drag props
        dragOver: dragOverNodeKey === key && dropPosition === 0,
        dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
        dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1,
        key: key
      });
    };

    return {
      getDerivedStateFromProps: getDerivedStateFromProps,
      onNodeDragStart: onNodeDragStart,
      onNodeDragEnter: onNodeDragEnter,
      onNodeDragOver: onNodeDragOver,
      onNodeDragLeave: onNodeDragLeave,
      onNodeDragEnd: onNodeDragEnd,
      onNodeDrop: onNodeDrop,
      onNodeClick: onNodeClick,
      onNodeDoubleClick: onNodeDoubleClick,
      onNodeSelect: onNodeSelect,
      onNodeCheck: onNodeCheck,
      onNodeLoad: onNodeLoad,
      onNodeExpand: onNodeExpand,
      onNodeMouseEnter: onNodeMouseEnter,
      onNodeMouseLeave: onNodeMouseLeave,
      onNodeContextMenu: onNodeContextMenu,
      setUncontrolledState: setUncontrolledState,
      registerTreeNode: registerTreeNode,
      isKeyChecked: isKeyChecked,
      renderTreeNode: renderTreeNode,
      state: $state
    };
  },
  render: function render() {
    var _this = this;

    var treeNode = this.state._treeNode;
    var _this$$props = this.$props,
        prefixCls = _this$$props.prefixCls,
        focusable = _this$$props.focusable,
        showLine = _this$$props.showLine,
        _this$$props$tabIndex = _this$$props.tabIndex,
        tabIndex = _this$$props$tabIndex === void 0 ? 0 : _this$$props$tabIndex;
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("ul", {
      "class": classnames_default()(prefixCls, defineProperty_default()({}, "".concat(prefixCls, "-show-line"), showLine)),
      "role": "tree",
      "unselectable": "on",
      "tabindex": focusable ? tabIndex : null
    }, [mapChildren(unwrapFragment(treeNode), function (node, index) {
      return _this.renderTreeNode(node, index);
    })]);
  }
});
/* harmony default export */ var tree = (Tree);
// CONCATENATED MODULE: ./src/components/vc-tree/index.ts
// based on rc-tree 2.1.3






// CONCATENATED MODULE: ./src/components/tree/tree.tsx


function tree_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tree_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tree_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tree_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }











function TreeProps() {
  return {
    showLine: vue_types.bool,

    /** 是否支持多选 */
    multiple: vue_types.bool,

    /** 是否自动展开父节点 */
    autoExpandParent: vue_types.bool,

    /** checkable状态下节点选择完全受控（父子节点选中状态不再关联）*/
    checkStrictly: vue_types.bool,

    /** 是否支持选中 */
    checkable: vue_types.bool,

    /** 是否禁用树 */
    disabled: vue_types.bool,

    /** 默认展开所有树节点 */
    defaultExpandAll: vue_types.bool,

    /** 默认展开对应树节点 */
    defaultExpandParent: vue_types.bool,

    /** 默认展开指定的树节点 */
    defaultExpandedKeys: vue_types.array,

    /** （受控）展开指定的树节点 */
    expandedKeys: vue_types.array,

    /** （受控）选中复选框的树节点 */
    checkedKeys: vue_types.oneOfType([vue_types.array, vue_types.shape({
      checked: vue_types.array,
      halfChecked: vue_types.array
    }).loose]),

    /** 默认选中复选框的树节点 */
    defaultCheckedKeys: vue_types.array,

    /** （受控）设置选中的树节点 */
    selectedKeys: vue_types.array,

    /** 默认选中的树节点 */
    defaultSelectedKeys: vue_types.array,
    selectable: vue_types.bool,

    /** 展开/收起节点时触发 */
    // onExpand: (expandedKeys: string[], info: AntTreeNodeExpandedEvent) => void | PromiseLike<any>,

    /** 点击复选框触发 */
    // onCheck: (checkedKeys: string[] | { checked: string[]; halfChecked: string[] }, e: AntTreeNodeCheckedEvent) => void,

    /** 点击树节点触发 */
    // onSelect: (selectedKeys: string[], e: AntTreeNodeSelectedEvent) => void,

    /** 单击树节点触发 */
    // onClick: (e: React.MouseEvent<HTMLElement>, node: AntTreeNode) => void,

    /** 双击树节点触发 */
    // onDoubleClick: (e: React.MouseEvent<HTMLElement>, node: AntTreeNode) => void,

    /** filter some AntTreeNodes as you need. it should return true */
    filterAntTreeNode: vue_types.func,

    /** 异步加载数据 */
    loadData: vue_types.func,
    loadedKeys: vue_types.array,
    // onLoaded: (loadedKeys: string[], info: { event: 'load', node: AntTreeNode; }) => void,

    /** 响应右键点击 */
    // onRightClick: (options: AntTreeNodeMouseEvent) => void,

    /** 设置节点可拖拽（IE>8）*/
    draggable: vue_types.bool,
    // /** 开始拖拽时调用 */
    // onDragStart: (options: AntTreeNodeMouseEvent) => void,
    // /** dragenter 触发时调用 */
    // onDragEnter: (options: AntTreeNodeMouseEvent) => void,
    // /** dragover 触发时调用 */
    // onDragOver: (options: AntTreeNodeMouseEvent) => void,
    // /** dragleave 触发时调用 */
    // onDragLeave: (options: AntTreeNodeMouseEvent) => void,
    // /** drop 触发时调用 */
    // onDrop: (options: AntTreeNodeMouseEvent) => void,
    showIcon: vue_types.bool,
    icon: vue_types.func,
    switcherIcon: vue_types.any,
    prefixCls: vue_types.string,
    filterTreeNode: vue_types.func,
    openAnimation: vue_types.any,
    treeNodes: vue_types.array,
    treeData: vue_types.array,

    /**
     * @default{title,key,children}
     * 替换treeNode中 title,key,children字段为treeData中对应的字段
     */
    replaceFields: vue_types.object,
    blockNode: vue_types.bool
  };
}


/* harmony default export */ var tree_tree = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ATree',
  props: initDefaultProps(TreeProps(), {
    checkable: false,
    showIcon: false,
    openAnimation: Object.assign(Object.assign({}, _util_openAnimation), {
      appear: null
    }),
    blockNode: false
  }),
  TreeNode: tree_node,
  setup: function setup($props, _ref) {
    var emit = _ref.emit,
        $slots = _ref.slots;

    var renderSwitcherIcon = function renderSwitcherIcon(prefixCls, switcherIcon, _ref2) {
      var isLeaf = _ref2.isLeaf,
          expanded = _ref2.expanded,
          loading = _ref2.loading;
      var showLine = $props.showLine;

      if (loading) {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
          "type": "loading",
          "class": "".concat(prefixCls, "-switcher-loading-icon")
        }, []);
      }

      if (isLeaf) {
        return showLine ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
          "type": "file",
          "class": "".concat(prefixCls, "-switcher-line-icon")
        }, []) : null;
      }

      var switcherCls = "".concat(prefixCls, "-switcher-icon");

      if (switcherIcon) {
        return cloneElement(switcherIcon, {
          "class": defineProperty_default()({}, switcherCls, true)
        });
      }

      return showLine ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": expanded ? 'minus-square' : 'plus-square',
        "class": "".concat(prefixCls, "-switcher-line-icon"),
        "theme": "outlined"
      }, []) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "caret-down",
        "class": switcherCls,
        "theme": "filled"
      }, []);
    };

    var updateTreeData = function updateTreeData(treeData) {
      var defaultFields = {
        children: 'children',
        title: 'title',
        key: 'key'
      };
      var replaceFields = Object.assign(Object.assign({}, defaultFields), $props.replaceFields);
      return treeData.filter(function (it) {
        return it !== undefined;
      }).map(function (item) {
        var key = item[replaceFields.key];
        var children = item[replaceFields.children];

        var _item$on = item.on,
            on = _item$on === void 0 ? {} : _item$on,
            _item$slots = item.slots,
            slots = _item$slots === void 0 ? {} : _item$slots,
            cls = item["class"],
            style = item.style,
            restProps = __rest(item, ["on", "slots", "class", "style"]);

        var treeNodeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, restProps), {
          icon: $slots[slots.icon] || restProps.icon,
          switcherIcon: $slots[slots.switcherIcon] || restProps.switcherIcon,
          title: $slots[slots.title] || restProps[replaceFields.title]
        }), on), {
          dataRef: item,
          key: key,
          "class": cls,
          style: style
        });

        if (children) {
          return Object.assign(Object.assign({}, treeNodeProps), {
            children: updateTreeData(children)
          });
        }

        return treeNodeProps;
      });
    };

    return {
      renderSwitcherIcon: renderSwitcherIcon,
      updateTreeData: updateTreeData,
      configProvider: config_provider_useConfigProvider()
    };
  },
  render: function render() {
    var _this = this,
        _class2;

    var props = this.$props;
    var $slots = this.$slots;
    var customizePrefixCls = props.prefixCls,
        showIcon = props.showIcon,
        treeNodes = props.treeNodes,
        blockNode = props.blockNode;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('tree', customizePrefixCls);

    var _switcherIcon = getComponentFromContext(this, 'switcherIcon');

    var checkable = props.checkable;
    var treeData = props.treeData || treeNodes;

    if (treeData) {
      treeData = this.updateTreeData(treeData);
    }

    var vcTreeProps = Object.assign(Object.assign(Object.assign({}, props), getListenersFromContext(this)), {
      prefixCls: prefixCls,
      checkable: checkable ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-checkbox-inner")
      }, []) : checkable,
      switcherIcon: function switcherIcon(nodeProps) {
        return _this.renderSwitcherIcon(prefixCls, _switcherIcon, nodeProps);
      },
      ref: 'tree',
      "class": (_class2 = {}, defineProperty_default()(_class2, "".concat(prefixCls, "-icon-hide"), !showIcon), defineProperty_default()(_class2, "".concat(prefixCls, "-block-node"), blockNode), _class2)
    });

    if (treeData) {
      vcTreeProps.treeData = treeData;
    }

    if ($slots["default"]) {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(tree, tree_objectSpread({}, vcTreeProps), $slots);
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(tree, tree_objectSpread({}, vcTreeProps), []);
  }
}));
// EXTERNAL MODULE: ./node_modules/lodash/debounce.js
var debounce = __webpack_require__("b047");
var debounce_default = /*#__PURE__*/__webpack_require__.n(debounce);

// CONCATENATED MODULE: ./src/components/tree/util.ts




var Record = {
  None: 'node',
  Start: 'start',
  End: 'end'
}; // TODO: Move this logic into `rc-tree`

function traverseNodesKey(rootChildren, callback) {
  var nodeList = getRealNodeChildren(rootChildren) || [];

  function processNode(node) {
    var key = node.key;
    var children = getSlots(node)["default"];

    if (callback(key, node) !== false) {
      traverseNodesKey(typeof children === 'function' ? children() : children, callback);
    }
  }

  nodeList.forEach(processNode);
}

function getFullKeyList(children) {
  var _convertTreeToEntitie = convertTreeToEntities(children),
      keyEntities = _convertTreeToEntitie.keyEntities;

  return toConsumableArray_default()(keyEntities.keys());
}
/** 计算选中范围，只考虑expanded情况以优化性能 */

function calcRangeKeys(rootChildren, expandedKeys, startKey, endKey) {
  var keys = [];
  var record = Record.None;

  if (startKey && startKey === endKey) {
    return [startKey];
  }

  if (!startKey || !endKey) {
    return [];
  }

  function matchKey(key) {
    return key === startKey || key === endKey;
  }

  traverseNodesKey(rootChildren, function (key) {
    if (record === Record.End) {
      return false;
    }

    if (matchKey(key)) {
      // Match test
      keys.push(key);

      if (record === Record.None) {
        record = Record.Start;
      } else if (record === Record.Start) {
        record = Record.End;
        return false;
      }
    } else if (record === Record.Start) {
      // Append selection
      keys.push(key);
    }

    if (expandedKeys.indexOf(key) === -1) {
      return false;
    }

    return true;
  });
  return keys;
}
function convertDirectoryKeysToNodes(rootChildren, keys) {
  var restKeys = toConsumableArray_default()(keys);

  var nodes = [];
  traverseNodesKey(rootChildren, function (key, node) {
    var index = restKeys.indexOf(key);

    if (index !== -1) {
      nodes.push(node);
      restKeys.splice(index, 1);
    }

    return !!restKeys.length;
  });
  return nodes;
}
function getFullKeyListByTreeData(treeData) {
  var keys = [];
  (treeData || []).forEach(function (item) {
    keys.push(item.key);

    if (item.children) {
      keys = [].concat(toConsumableArray_default()(keys), toConsumableArray_default()(getFullKeyListByTreeData(item.children)));
    }
  });
  return keys;
}
// CONCATENATED MODULE: ./src/components/tree/directory-tree.tsx



function directory_tree_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function directory_tree_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { directory_tree_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { directory_tree_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }














 // export type ExpandAction = false | 'click' | 'dblclick'; export interface
// DirectoryTreeProps extends TreeProps {   expandAction?: ExpandAction; }
// export interface DirectoryTreeState {   expandedKeys?: string[];
// selectedKeys?: string[]; }

function directory_tree_getIcon(props) {
  var isLeaf = props.isLeaf,
      expanded = props.expanded;

  if (isLeaf) {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
      "type": "file"
    }, []);
  }

  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
    "type": expanded ? 'folder-open' : 'folder'
  }, []);
}

/* harmony default export */ var directory_tree = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ADirectoryTree',
  props: initDefaultProps(Object.assign(Object.assign({}, TreeProps()), {
    expandAction: vue_types.oneOf([false, 'click', 'doubleclick', 'dblclick'])
  }), {
    showIcon: true,
    expandAction: 'click'
  }),
  setup: function setup($props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;

    var _useRefs = save_ref_useRefs(),
        getRef = _useRefs.getRef,
        saveRef = _useRefs.saveRef;

    var expandFolderNode = function expandFolderNode(event, node) {
      var isLeaf = node.isLeaf;

      if (isLeaf || event.shiftKey || event.metaKey || event.ctrlKey) {
        return;
      }

      if (getRef('tree').$refs.tree) {
        // Get internal vc-tree
        var internalTree = getRef('tree').$refs.tree; // Call internal rc-tree expand function
        // https://github.com/ant-design/ant-design/issues/12567

        internalTree.onNodeExpand(event, node);
      }
    };

    var getState = function getState() {
      var props = $props;
      var defaultExpandAll = props.defaultExpandAll,
          defaultExpandParent = props.defaultExpandParent,
          expandedKeys = props.expandedKeys,
          defaultExpandedKeys = props.defaultExpandedKeys;

      var _convertTreeToEntitie = convertTreeToEntities(slots["default"]()),
          keyEntities = _convertTreeToEntitie.keyEntities;

      var state = {}; // Selected keys

      state._selectedKeys = props.selectedKeys || props.defaultSelectedKeys || []; // Expanded keys

      if (defaultExpandAll) {
        if (props.treeData) {
          state._expandedKeys = getFullKeyListByTreeData(props.treeData);
        } else {
          state._expandedKeys = getFullKeyList(slots["default"]());
        }
      } else if (defaultExpandParent) {
        state._expandedKeys = conductExpandParent(expandedKeys || defaultExpandedKeys, keyEntities);
      } else {
        state._expandedKeys = expandedKeys || defaultExpandedKeys;
      }

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["reactive"])(Object.assign({
        onDebounceExpand: debounce_default()(expandFolderNode, 200, {
          leading: true
        }),
        _selectedKeys: [],
        _expandedKeys: []
      }, state));
    };

    var _useState = state_useState(),
        $state = _useState.state,
        setState = _useState.setState;

    setState(getState());
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $props.expandedKeys;
    }, function (val) {
      setState({
        _expandedKeys: val
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $props.selectedKeys;
    }, function (val) {
      setState({
        _selectedKeys: val
      });
    });

    var onExpand = function onExpand(expandedKeys, info) {
      setUncontrolledState({
        _expandedKeys: expandedKeys
      });
      emit('expand', expandedKeys, info);
      return undefined;
    };

    var onClick = function onClick(event, node) {
      var expandAction = $props.expandAction; // Expand the tree

      if (expandAction === 'click') {
        if (!node) {
          console.warn('[ATree] node data missing when clicked!');
        }

        $state.onDebounceExpand(event, node);
      }

      emit('click', event, node);
    };

    var onDoubleClick = function onDoubleClick(event, node) {
      var expandAction = $props.expandAction; // Expand the tree

      if (expandAction === 'dblclick' || expandAction === 'doubleclick') {
        $state.onDebounceExpand(event, node);
      }

      emit('doubleclick', event, node);
      emit('dblclick', event, node);
    };

    var onSelect = function onSelect(keys, event) {
      var multiple = $props.multiple;
      var children = slots["default"] && slots["default"]() || [];
      var _$state$_expandedKeys = $state._expandedKeys,
          expandedKeys = _$state$_expandedKeys === void 0 ? [] : _$state$_expandedKeys;
      var node = event.node,
          nativeEvent = event.nativeEvent;
      var _node$eventKey = node.eventKey,
          eventKey = _node$eventKey === void 0 ? '' : _node$eventKey;
      var newState = {}; // We need wrap this event since some value is not same

      var newEvent = Object.assign(Object.assign({}, event), {
        selected: true // Directory selected always true

      }); // Windows / Mac single pick

      var ctrlPick = nativeEvent.ctrlKey || nativeEvent.metaKey;
      var shiftPick = nativeEvent.shiftKey; // Generate new selected keys

      var newSelectedKeys;

      if (multiple && ctrlPick) {
        // Control click
        newSelectedKeys = keys;
        $state.lastSelectedKey = eventKey;
        $state.cachedSelectedKeys = newSelectedKeys;
        newEvent.selectedNodes = convertDirectoryKeysToNodes(children, newSelectedKeys);
      } else if (multiple && shiftPick) {
        // Shift click
        newSelectedKeys = Array.from(new Set([].concat(toConsumableArray_default()($state.cachedSelectedKeys || []), toConsumableArray_default()(calcRangeKeys(children, expandedKeys, eventKey, $state.lastSelectedKey)))));
        newEvent.selectedNodes = convertDirectoryKeysToNodes(children, newSelectedKeys);
      } else {
        // Single click
        newSelectedKeys = [eventKey];
        $state.lastSelectedKey = eventKey;
        $state.cachedSelectedKeys = newSelectedKeys;
        newEvent.selectedNodes = [event.node];
      }

      newState._selectedKeys = newSelectedKeys;
      emit('update:selectedKeys', newSelectedKeys);
      emit('select', newSelectedKeys, newEvent);
      setUncontrolledState(newState);
    };

    var setUncontrolledState = function setUncontrolledState(state) {
      var newState = es(state, Object.keys($props).map(function (p) {
        return "_".concat(p);
      }));

      if (Object.keys(newState).length) {
        setState(newState);
      }
    };

    return {
      onExpand: onExpand,
      saveRef: saveRef,
      onClick: onClick,
      onDoubleClick: onDoubleClick,
      onSelect: onSelect,
      expandFolderNode: expandFolderNode,
      setUncontrolledState: setUncontrolledState,
      configProvider: config_provider_useConfigProvider(),
      $state: $state
    };
  },
  render: function render() {
    var _a = this.$props,
        customizePrefixCls = _a.prefixCls,
        props = __rest(_a, ["prefixCls"]);

    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('tree', customizePrefixCls);
    var _this$$state = this.$state,
        expandedKeys = _this$$state._expandedKeys,
        selectedKeys = _this$$state._selectedKeys;
    var listeners = getListenersFromContext(this);
    _util_warning(!listeners.doubleclick, '`doubleclick` is deprecated. please use `dblclick` instead.');
    var treeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, props), {
      icon: directory_tree_getIcon,
      prefixCls: prefixCls,
      expandedKeys: expandedKeys,
      selectedKeys: selectedKeys,
      switcherIcon: getComponentFromContext(this, 'switcherIcon'),
      ref: this.saveRef('tree'),
      "class": "".concat(prefixCls, "-directory")
    }), es(listeners, ['onUpdate:selectedKeys'])), {
      onSelect: this.onSelect,
      onClick: this.onClick,
      onDblclick: this.onDoubleClick,
      onExpand: this.onExpand
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(tree_tree, directory_tree_objectSpread({}, treeProps), [this.$slots["default"] && this.$slots["default"]()]);
  }
}));
// CONCATENATED MODULE: ./src/components/tree/index.tsx




tree_tree.TreeNode.name = 'ATreeNode';
tree_tree.DirectoryTree = directory_tree;
/* istanbul ignore next */

tree_tree.install = function (Vue) {
  Vue.use(base);
  Vue.component(tree_tree.name, tree_tree);
  Vue.component(tree_tree.TreeNode.name, tree_tree.TreeNode);
  Vue.component(directory_tree.name, directory_tree);
};

/* harmony default export */ var components_tree = (tree_tree);
// EXTERNAL MODULE: ./node_modules/array-tree-filter/lib/index.js
var array_tree_filter_lib = __webpack_require__("b8ad");
var array_tree_filter_lib_default = /*#__PURE__*/__webpack_require__.n(array_tree_filter_lib);

// CONCATENATED MODULE: ./src/components/_util/keycode.ts


/**
 * @ignore
 * some key-codes definition and utils from closure-library
 * @author yiminghe@gmail.com
 */

/**
 * keycode 8 = BackSpace BackSpace
 keycode 9 = Tab Tab
 keycode 12 = Clear
 keycode 13 = Enter
 keycode 16 = Shift_L
 keycode 17 = Control_L
 keycode 18 = Alt_L
 keycode 19 = Pause
 keycode 20 = Caps_Lock
 keycode 27 = Escape Escape
 keycode 32 = space space
 keycode 33 = Prior
 keycode 34 = Next
 keycode 35 = End
 keycode 36 = Home
 keycode 37 = Left
 keycode 38 = Up
 keycode 39 = Right
 keycode 40 = Down
 keycode 41 = Select
 keycode 42 = Print
 keycode 43 = Execute
 keycode 45 = Insert
 keycode 46 = Delete
 keycode 47 = Help
 keycode 48 = 0 equal braceright
 keycode 49 = 1 exclam onesuperior
 keycode 50 = 2 quotedbl twosuperior
 keycode 51 = 3 section threesuperior
 keycode 52 = 4 dollar
 keycode 53 = 5 percent
 keycode 54 = 6 ampersand
 keycode 55 = 7 slash braceleft
 keycode 56 = 8 parenleft bracketleft
 keycode 57 = 9 parenright bracketright
 keycode 65 = a A
 keycode 66 = b B
 keycode 67 = c C
 keycode 68 = d D
 keycode 69 = e E EuroSign
 keycode 70 = f F
 */
var KeyName;

(function (KeyName) {
  KeyName["Tab"] = "Tab";
  KeyName["Clear"] = "Clear";
  KeyName["Enter"] = "Enter";
  KeyName["Next"] = "Next";
  KeyName["End"] = "End";
  KeyName["Home"] = "Home";
  KeyName["Left"] = "Left";
  KeyName["Up"] = "Up";
  KeyName["Right"] = "Right";
  KeyName["Down"] = "Down";
  KeyName["Select"] = "Select";
  KeyName["Print"] = "Print";
  KeyName["Execute"] = "Execute";
  KeyName["Insert"] = "Insert";
  KeyName["Delete"] = "Delete";
})(KeyName || (KeyName = {}));

var KeyCode = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,

  /**
   * BACKSPACE
   */
  BACKSPACE: 8,

  /**
   * TAB
   */
  TAB: 9,

  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,

  /**
   * ENTER
   */
  ENTER: 13,

  /**
   * SHIFT
   */
  SHIFT: 16,

  /**
   * CTRL
   */
  CTRL: 17,

  /**
   * ALT
   */
  ALT: 18,

  /**
   * PAUSE
   */
  PAUSE: 19,

  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,

  /**
   * ESC
   */
  ESC: 27,

  /**
   * SPACE
   */
  SPACE: 32,

  /**
   * PAGE_UP
   */
  PAGE_UP: 33,

  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,

  /**
   * END
   */
  END: 35,

  /**
   * HOME
   */
  HOME: 36,

  /**
   * LEFT
   */
  LEFT: 37,

  /**
   * UP
   */
  UP: 38,

  /**
   * RIGHT
   */
  RIGHT: 39,

  /**
   * DOWN
   */
  DOWN: 40,

  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,

  /**
   * INSERT
   */
  INSERT: 45,

  /**
   * DELETE
   */
  DELETE: 46,

  /**
   * ZERO
   */
  ZERO: 48,

  /**
   * ONE
   */
  ONE: 49,

  /**
   * TWO
   */
  TWO: 50,

  /**
   * THREE
   */
  THREE: 51,

  /**
   * FOUR
   */
  FOUR: 52,

  /**
   * FIVE
   */
  FIVE: 53,

  /**
   * SIX
   */
  SIX: 54,

  /**
   * SEVEN
   */
  SEVEN: 55,

  /**
   * EIGHT
   */
  EIGHT: 56,

  /**
   * NINE
   */
  NINE: 57,

  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,

  /**
   * A
   */
  A: 65,

  /**
   * B
   */
  B: 66,

  /**
   * C
   */
  C: 67,

  /**
   * D
   */
  D: 68,

  /**
   * E
   */
  E: 69,

  /**
   * F
   */
  F: 70,

  /**
   * G
   */
  G: 71,

  /**
   * H
   */
  H: 72,

  /**
   * I
   */
  I: 73,

  /**
   * J
   */
  J: 74,

  /**
   * K
   */
  K: 75,

  /**
   * L
   */
  L: 76,

  /**
   * M
   */
  M: 77,

  /**
   * N
   */
  N: 78,

  /**
   * O
   */
  O: 79,

  /**
   * P
   */
  P: 80,

  /**
   * Q
   */
  Q: 81,

  /**
   * R
   */
  R: 82,

  /**
   * S
   */
  S: 83,

  /**
   * T
   */
  T: 84,

  /**
   * U
   */
  U: 85,

  /**
   * V
   */
  V: 86,

  /**
   * W
   */
  W: 87,

  /**
   * X
   */
  X: 88,

  /**
   * Y
   */
  Y: 89,

  /**
   * Z
   */
  Z: 90,

  /**
   * META
   */
  META: 91,

  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,

  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,

  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,

  /**
   * NUM_ONE
   */
  NUM_ONE: 97,

  /**
   * NUM_TWO
   */
  NUM_TWO: 98,

  /**
   * NUM_THREE
   */
  NUM_THREE: 99,

  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,

  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,

  /**
   * NUM_SIX
   */
  NUM_SIX: 102,

  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,

  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,

  /**
   * NUM_NINE
   */
  NUM_NINE: 105,

  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,

  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,

  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,

  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,

  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,

  /**
   * F1
   */
  F1: 112,

  /**
   * F2
   */
  F2: 113,

  /**
   * F3
   */
  F3: 114,

  /**
   * F4
   */
  F4: 115,

  /**
   * F5
   */
  F5: 116,

  /**
   * F6
   */
  F6: 117,

  /**
   * F7
   */
  F7: 118,

  /**
   * F8
   */
  F8: 119,

  /**
   * F9
   */
  F9: 120,

  /**
   * F10
   */
  F10: 121,

  /**
   * F11
   */
  F11: 122,

  /**
   * F12
   */
  F12: 123,

  /**
   * NUMLOCK
   */
  NUMLOCK: 144,

  /**
   * SEMICOLON
   */
  SEMICOLON: 186,

  /**
   * DASH
   */
  DASH: 189,

  /**
   * EQUALS
   */
  EQUALS: 187,

  /**
   * COMMA
   */
  COMMA: 188,

  /**
   * PERIOD
   */
  PERIOD: 190,

  /**
   * SLASH
   */
  SLASH: 191,

  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,

  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,

  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,

  /**
   * BACKSLASH
   */
  BACKSLASH: 220,

  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,

  /**
   * WIN_KEY
   */
  WIN_KEY: 224,

  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,

  /**
   * WIN_IME
   */
  WIN_IME: 229
};
/*
 whether text and modified key is entered at the same time.
 */

KeyCode.isTextModifyingKeyEvent = function isTextModifyingKeyEvent(e) {
  var keyCode = e.keyCode;

  if (e.altKey && !e.ctrlKey || e.metaKey || // Function keys don't generate text
  keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
    return false;
  } // The following keys are quite harmless, even in combination with
  // CTRL, ALT or SHIFT.


  switch (keyCode) {
    case KeyCode.ALT:
    case KeyCode.CAPS_LOCK:
    case KeyCode.CONTEXT_MENU:
    case KeyCode.CTRL:
    case KeyCode.DOWN:
    case KeyCode.END:
    case KeyCode.ESC:
    case KeyCode.HOME:
    case KeyCode.INSERT:
    case KeyCode.LEFT:
    case KeyCode.MAC_FF_META:
    case KeyCode.META:
    case KeyCode.NUMLOCK:
    case KeyCode.NUM_CENTER:
    case KeyCode.PAGE_DOWN:
    case KeyCode.PAGE_UP:
    case KeyCode.PAUSE:
    case KeyCode.PRINT_SCREEN:
    case KeyCode.RIGHT:
    case KeyCode.SHIFT:
    case KeyCode.UP:
    case KeyCode.WIN_KEY:
    case KeyCode.WIN_KEY_RIGHT:
      return false;

    default:
      return true;
  }
};
/*
 whether character is entered.
 */


KeyCode.isCharacterKey = function isCharacterKey(keyCode) {
  if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
    return true;
  }

  if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
    return true;
  }

  if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
    return true;
  } // Safari sends zero key code for non-latin characters.


  if (window.navigator.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) {
    return true;
  }

  switch (keyCode) {
    case KeyCode.SPACE:
    case KeyCode.QUESTION_MARK:
    case KeyCode.NUM_PLUS:
    case KeyCode.NUM_MINUS:
    case KeyCode.NUM_PERIOD:
    case KeyCode.NUM_DIVISION:
    case KeyCode.SEMICOLON:
    case KeyCode.DASH:
    case KeyCode.EQUALS:
    case KeyCode.COMMA:
    case KeyCode.PERIOD:
    case KeyCode.SLASH:
    case KeyCode.APOSTROPHE:
    case KeyCode.SINGLE_QUOTE:
    case KeyCode.OPEN_SQUARE_BRACKET:
    case KeyCode.BACKSLASH:
    case KeyCode.CLOSE_SQUARE_BRACKET:
      return true;

    default:
      return false;
  }
};

/* harmony default export */ var keycode = (KeyCode);
// CONCATENATED MODULE: ./src/components/input/group.tsx




var group_buttonGroupProps = {
  prefixCls: vue_types.string,
  size: {
    validator: function validator(value) {
      return ['small', 'large', 'default'].includes(value);
    }
  },
  compact: Boolean
};
/* harmony default export */ var group = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AInputGroup',
  props: group_buttonGroupProps,
  setup: function setup(props) {
    var configProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('configProvider') || ConfigConsumerProps;
    var customizePrefixCls = props.prefixCls,
        size = props.size,
        _props$compact = props.compact,
        compact = _props$compact === void 0 ? false : _props$compact;

    var classes = function classes() {
      var _ref;

      var getPrefixCls = configProvider.getPrefixCls;
      var prefixCls = getPrefixCls('input-group', customizePrefixCls);
      return _ref = {}, defineProperty_default()(_ref, "".concat(prefixCls), true), defineProperty_default()(_ref, "".concat(prefixCls, "-lg"), size === 'large'), defineProperty_default()(_ref, "".concat(prefixCls, "-sm"), size === 'small'), defineProperty_default()(_ref, "".concat(prefixCls, "-compact"), compact), _ref;
    };

    return {
      configProvider: configProvider,
      classes: classes
    };
  },
  render: function render() {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": this.classes()
    }, [this.$slots["default"] && this.$slots["default"]()]);
  }
}));
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__("a34a");
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);

// CONCATENATED MODULE: ./src/components/form/src/utils.ts

var ProvideKeys;

(function (ProvideKeys) {
  ProvideKeys["FormContext"] = "FormContext";
  ProvideKeys["FormItemContext"] = "FormItemContext";
})(ProvideKeys || (ProvideKeys = {}));

var getPropByPath = function getPropByPath(obj, path, strict) {
  var tempObj = obj;
  var copyPath = path;
  copyPath = copyPath.replace(/\[(\w+)]/g, '.$1');
  copyPath = copyPath.replace(/^\./, '');
  var keyArr = copyPath.split('.');
  var i = 0;

  for (var len = keyArr.length; i < len - 1; ++i) {
    if (!tempObj && !strict) {
      break;
    }

    var key = keyArr[i];

    if (key in tempObj) {
      tempObj = tempObj[key];
    } else {
      if (strict) {
        throw new Error('please transfer a valid prop path to form item!');
      }

      break;
    }
  }

  return {
    o: tempObj,
    k: keyArr[i],
    v: tempObj ? tempObj[keyArr[i]] : null
  };
};
var utils_noop = function noop(a, b) {};
// CONCATENATED MODULE: ./src/tools/value.ts



var isNullOrUndefined = function isNullOrUndefined(value) {
  return value === undefined || value === null;
};

var basicTypes = ['number', 'boolean', 'string'];

function isEqual(a, b) {
  if (isNullOrUndefined(a) && isNullOrUndefined(b)) {
    return true;
  } else if (isNullOrUndefined(a) || isNullOrUndefined(b)) {
    return false;
  }

  var compareA = basicTypes.includes(typeof_default()(a)) ? a.toString() : a;
  var compareB = basicTypes.includes(typeof_default()(b)) ? b.toString() : b;
  return compareA === compareB;
}

var value_useLocalValue = function useLocalValue(defaultValue) {
  var propName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'value';
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    transform: function transform(v) {
      return v;
    },
    reverseTransform: function reverseTransform(v) {
      return v;
    }
  };
  var context = {
    doAfterSetValue: null,
    doBeforeSetValue: null
  };
  var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
  var localValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(isNullOrUndefined(instance.props[propName]) ? options.transform(defaultValue) : options.transform(instance.props[propName]));
  Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
    return instance.props[propName];
  }, function (value) {
    var newValue = options.transform(value);

    if (!isEqual(localValue.value, newValue)) {
      localValue.value = newValue;
    }
  });
  return {
    afterValueSetAction: function afterValueSetAction(callback) {
      context.doAfterSetValue = callback;
    },
    setBeforeAction: function setBeforeAction(callback) {
      context.doBeforeSetValue = callback;
    },
    setValue: function setValue(value, eventKeyOrCallback) {
      if (context.doBeforeSetValue) {
        context.doBeforeSetValue(value);
      }

      var event = null;

      if (typeof eventKeyOrCallback === 'string') {
        event = eventKeyOrCallback ? eventKeyOrCallback : "update:".concat(propName);
      } else {
        event = "update:".concat(propName);
      }

      if (instance.props[propName] === undefined) {
        localValue.value = value;
      } else {
        instance.emit(event, options.reverseTransform(value));
      }

      if (typeof eventKeyOrCallback === 'function') {
        eventKeyOrCallback();
      }

      if (context.doAfterSetValue) {
        context.doAfterSetValue(value);
      }
    },
    getValue: function getValue() {
      return localValue.value;
    },
    value: localValue
  };
};
// CONCATENATED MODULE: ./src/components/form/src/form.tsx









var form_useFormContext = function useFormContext() {
  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(ProvideKeys.FormContext, {
    addField: function addField(f) {},
    removeField: function removeField(f) {},
    collect: function collect() {}
  });
};
var form_useForm = function useForm() {
  var formContext = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(ProvideKeys.FormContext);
  var formItemContext = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(ProvideKeys.FormItemContext, {
    registerControl: function registerControl(c) {},
    emit: function emit(e) {}
  });
  return {
    formItemContext: formItemContext,
    registerField: function registerField(field) {
      formContext.addField(field);
    },
    unRegisterField: function unRegisterField(field) {
      formContext.removeField(field);
    },
    registerControl: function registerControl() {
      var control = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
      formItemContext.registerControl(control);
    },
    labelWidth: formContext === null || formContext === void 0 ? void 0 : formContext.labelWidth
  };
};
var FormProps = {
  // 显示取消确认按钮，分别产生cancel和ok事件，cancel和ok没有默认操作，完全由用户定义
  okCancel: {
    type: Boolean,
    "default": false
  },
  // 'small' | 'large' | 'default'
  size: {
    type: String,
    "default": 'default'
  },
  colon: vue_types.bool,
  disabled: {
    type: Boolean,
    "default": false
  },
  readOnly: {
    type: Boolean,
    "default": false
  },
  labelCol: {
    type: [Number, Object]
  },
  okText: {
    type: String,
    "default": '确定'
  },
  cancelText: {
    type: String,
    "default": '取消'
  },
  inline: {
    type: Boolean,
    "default": false
  },
  labelAlign: vue_types.oneOf(['left', 'right']),
  // 标签宽度
  labelWidth: {
    type: [String, Number]
  },
  hideRequiredMark: {
    type: Boolean
  },
  // 'horizontal' | 'inline' | 'vertical'
  layout: {
    type: String,
    "default": 'horizontal'
  },
  model: {
    type: Object
  },
  rules: {
    type: Object
  },
  onSubmit: {
    type: Function,
    "default": function _default() {
      return function () {};
    }
  },
  hasError: {
    type: Boolean,
    "default": false
  },
  wrapperCol: {
    type: [Number, Object],
    "default": function _default() {
      // const layout = this.$options.propsData &&
      //     this.$options.propsData.layout;
      // if (layout === 'horizontal') {
      //   return {
      //     xs: {span: 24},
      //     sm: {span: 12},
      //     md: {span: 10}
      //   };
      // }
      return 0;
    }
  },
  form: {
    type: Object
  }
};
/* harmony default export */ var src_form = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AForm',
  props: FormProps,
  setup: function setup(props, _ref) {
    var _this = this;

    var emit = _ref.emit;
    var prefixCls = 'ant-form';

    var _useLocalValue = value_useLocalValue(false, 'hasError'),
        setHasError = _useLocalValue.setValue;

    var fields = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["reactive"])([]));
    var fieldErrors = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function () {
      return fields.value.length;
    });
    var formContext = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["reactive"])({
      colon: props.colon,
      labelCol: props.labelCol,
      vertical: props.layout === 'vertical',
      labelAlign: props.labelAlign,
      labelWidth: props.labelWidth,
      wrapperCol: props.wrapperCol,
      rules: props.rules,
      addField: function addField(field) {
        if (field) {
          fields.value.push(field);
        }
      },
      removeField: function removeField(field) {
        if (field.prop) {
          fields.value.splice(fields.value.indexOf(field), 1);
        }
      },
      resetFields: function resetFields() {
        if (!props.model) {
          console.warn('[Element Warn][Form]model is required for resetFields to work.');
          return;
        }

        fields.value.forEach(function (field) {
          field.resetField();
        });
      },
      clearValidate: function clearValidate() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var f = props.length ? typeof props === 'string' ? fields.value.filter(function (field) {
          return props === field.prop;
        }) : fields.value.filter(function (field) {
          return props.indexOf(field.prop) > -1;
        }) : fields.value;
        f.forEach(function (field) {
          field.clearValidate();
        });
      },
      validateField: function validateField(props, cb) {
        var copyProps = [].concat(props);
        var f = fields.value.filter(function (field) {
          return copyProps.indexOf(field.prop) !== -1;
        });

        if (!f.length) {
          console.warn('[Element Warn]please pass correct props!');
          return;
        }

        f.forEach(function (field) {
          field.validate('', cb);
        });
      },
      collect: function collect() {
        var errors = fields.value.map(function (it) {
          return it.ctx.help;
        }).filter(function (it) {
          return !!it;
        });
        setHasError(errors.length > 0);
      }
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      formContext.colon = props.colon;
      formContext.labelCol = props.labelCol;
      formContext.vertical = props.layout === 'vertical';
      formContext.labelAlign = props.labelAlign;
      formContext.wrapperCol = props.wrapperCol;
      formContext.labelWidth = props.labelWidth;
      formContext.rules = props.rules;
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(ProvideKeys.FormContext, formContext);

    var validate = function validate(callback) {
      return __awaiter(_this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee() {
        var res, errors, promise, copyCallback, valid, count, invalidFields;
        return regenerator_default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (props.model) {
                  _context.next = 8;
                  break;
                }

                _context.next = 3;
                return Promise.all(fields.value.map(function (field) {
                  return field.ctx.validate();
                }));

              case 3:
                res = _context.sent;
                errors = res.filter(function (it) {
                  return it.errors;
                });
                setHasError(errors.length > 0);
                callback && callback(errors);
                return _context.abrupt("return");

              case 8:
                copyCallback = callback; // if no callback, return promise

                if (typeof copyCallback !== 'function' && Promise) {
                  promise = new Promise(function (resolve, reject) {
                    copyCallback = function copyCallback(valid) {
                      var errorField = fields.value.find(function (it) {
                        return it.currentValidateStatus === 'error';
                      });

                      if (errorField) {
                        errorField.focus();
                      }

                      valid ? resolve(valid) : reject(valid);
                    };
                  });
                }

                valid = true;
                count = 0; // 如果需要验证的fields为空，调用验证时立刻返回callback

                if (fields.value.length === 0 && copyCallback) {
                  copyCallback(true);
                }

                invalidFields = {};
                fields.value.forEach(function (field) {
                  field.validate('', function (message, field) {
                    if (message) {
                      valid = false;
                    }

                    invalidFields = Object.assign({}, invalidFields, field);

                    if (typeof copyCallback === 'function' && ++count === fields.value.length) {
                      copyCallback(valid, invalidFields);
                    }
                  });
                });

                if (!promise) {
                  _context.next = 17;
                  break;
                }

                return _context.abrupt("return", promise);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
    };

    var renderButtons = function renderButtons() {
      if (props.okCancel) {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
          "class": prefixCls + '-footer-btns'
        }, [// @ts-ignore
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_button, {
          "onClick": function onClick(e) {
            emit('cancel', e);
          }
        }, [props.cancelText]), // @ts-ignore
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_button, {
          "onClick": function onClick(e) {
            emit('ok', e);
          },
          "type": 'primary',
          "style": {
            marginLeft: '8px'
          }
        }, [props.okText])]);
      }
    };

    var getLayout = function getLayout() {
      if (props.inline) {
        return 'inline';
      } else {
        return props.layout;
      }
    };

    if (props.form) {
      props.form.validate = validate;
    }

    return {
      prefixCls: prefixCls,
      fieldErrors: fieldErrors,
      renderButtons: renderButtons,
      getLayout: getLayout
    };
  },
  render: function render() {
    var _classNames;

    var prefixCls = this.prefixCls,
        hideRequiredMark = this.hideRequiredMark,
        onSubmit = this.onSubmit,
        $slots = this.$slots;
    var layout = this.getLayout();
    var formClassName = classnames_default()(prefixCls, (_classNames = {}, defineProperty_default()(_classNames, "".concat(prefixCls, "-horizontal"), layout === 'horizontal'), defineProperty_default()(_classNames, "".concat(prefixCls, "-vertical"), layout === 'vertical'), defineProperty_default()(_classNames, "".concat(prefixCls, "-inline"), layout === 'inline'), defineProperty_default()(_classNames, "".concat(prefixCls, "-hide-required-mark"), hideRequiredMark), _classNames)); // @ts-ignore

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("form", {
      "onSubmit": onSubmit,
      "class": formClassName
    }, [$slots["default"](), this.renderButtons()]);
  }
}));
// CONCATENATED MODULE: ./src/tools/base-input.ts


var base_input_useBaseInput = function useBaseInput() {
  var _useForm = form_useForm(),
      labelWidth = _useForm.labelWidth,
      formItemContext = _useForm.formItemContext,
      registerControl = _useForm.registerControl,
      registerField = _useForm.registerField,
      unRegisterField = _useForm.unRegisterField;

  var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
  registerControl();
  return {
    instance: instance,
    labelWidth: labelWidth,
    registerField: registerField,
    unRegisterField: unRegisterField,
    _emit: function _emit(eventName) {
      var fnName = "on".concat(eventName.substr(0, 1).toUpperCase()).concat(eventName.substr(1));

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (formItemContext) {
        formItemContext.emit.apply(formItemContext, [eventName].concat(args));
      }

      if (instance.attrs[fnName]) {
        var _instance$attrs;

        (_instance$attrs = instance.attrs)[fnName].apply(_instance$attrs, args);
      } else {
        instance.emit.apply(instance, [eventName].concat(args));
      }
    }
  };
};
// CONCATENATED MODULE: ./src/components/input/ClearableLabeledInput.tsx







function hasPrefixSuffix(instance) {
  return !!(props_util_getComponentFromProp(instance, 'prefix') || props_util_getComponentFromProp(instance, 'suffix') || instance.props.allowClear);
}
var ClearableInputType = ['text', 'input'];
var ClearableLabeledInput = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  components: {
    AIcon: components_icon
  },
  props: {
    prefixCls: vue_types.string,
    inputType: vue_types.oneOf(ClearableInputType),
    value: vue_types.any,
    defaultValue: vue_types.any,
    allowClear: vue_types.bool,
    element: vue_types.any,
    handleReset: vue_types.func,
    disabled: vue_types.bool,
    size: vue_types.oneOf(['small', 'large', 'default']),
    suffix: vue_types.any,
    prefix: vue_types.any,
    addonBefore: vue_types.any,
    addonAfter: vue_types.any,
    className: vue_types.string,
    readOnly: vue_types.bool
  },
  setup: function setup(props, _ref) {
    var attrs = _ref.attrs;
    var componentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var renderSuffix = function renderSuffix(prefixCls) {
      var suffix = props.suffix,
          allowClear = props.allowClear;

      if (suffix || allowClear) {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
          "class": "".concat(prefixCls, "-suffix")
        }, [renderClearIcon(prefixCls), suffix]);
      }

      return null;
    };

    var renderClearIcon = function renderClearIcon(prefixCls) {
      var allowClear = props.allowClear,
          value = props.value,
          disabled = props.disabled,
          readOnly = props.readOnly,
          inputType = props.inputType,
          handleReset = props.handleReset;

      if (!allowClear || disabled || readOnly || value === undefined || value === null || value === '') {
        return null;
      }

      var className = inputType === ClearableInputType[0] ? "".concat(prefixCls, "-textarea-clear-icon") : "".concat(prefixCls, "-clear-icon");
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "close-circle",
        "theme": "filled",
        "onClick": handleReset,
        "class": className,
        "role": "button"
      }, []);
    };

    var renderLabeledIcon = function renderLabeledIcon(prefixCls, element) {
      var _classNames;

      var suffix = renderSuffix(prefixCls);

      if (!hasPrefixSuffix(componentInstance)) {
        return element;
      }

      var prefix = props.prefix ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-prefix")
      }, [props.prefix]) : null;
      var affixWrapperCls = classnames_default()(props.className, "".concat(prefixCls, "-affix-wrapper"), (_classNames = {}, defineProperty_default()(_classNames, "".concat(prefixCls, "-affix-wrapper-sm"), props.size === 'small'), defineProperty_default()(_classNames, "".concat(prefixCls, "-affix-wrapper-lg"), props.size === 'large'), defineProperty_default()(_classNames, "".concat(prefixCls, "-affix-wrapper-input-with-clear-btn"), props.suffix && props.allowClear && props.value), _classNames));
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": affixWrapperCls,
        "style": attrs.style
      }, [prefix, element, suffix]);
    };

    var renderInputWithLabel = function renderInputWithLabel(prefixCls, labeledElement) {
      var _classNames3;

      var addonBefore = props.addonBefore,
          addonAfter = props.addonAfter,
          size = props.size,
          className = props.className;
      var style = attrs.style; // Not wrap when there is not addons

      if (!addonBefore && !addonAfter) {
        return labeledElement;
      }

      var wrapperClassName = "".concat(prefixCls, "-group");
      var addonClassName = "".concat(wrapperClassName, "-addon");
      var addonBeforeNode = addonBefore ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": addonClassName
      }, [addonBefore]) : null;
      var addonAfterNode = addonAfter ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": addonClassName
      }, [addonAfter]) : null;
      var mergedWrapperClassName = classnames_default()("".concat(prefixCls, "-wrapper"), defineProperty_default()({}, wrapperClassName, addonBefore || addonAfter));
      var mergedGroupClassName = classnames_default()(className, "".concat(prefixCls, "-group-wrapper"), (_classNames3 = {}, defineProperty_default()(_classNames3, "".concat(prefixCls, "-group-wrapper-sm"), size === 'small'), defineProperty_default()(_classNames3, "".concat(prefixCls, "-group-wrapper-lg"), size === 'large'), _classNames3)); // Need another wrapper for changing display:table to display:inline-block
      // and put style prop in wrapper

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": mergedGroupClassName,
        "style": style
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": mergedWrapperClassName
      }, [addonBeforeNode, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(labeledElement, {
        style: null
      }), addonAfterNode])]);
    };

    var renderTextAreaWithClearIcon = function renderTextAreaWithClearIcon(prefixCls, element) {
      var value = props.value,
          allowClear = props.allowClear,
          className = props.className;
      var style = attrs.style;

      if (!allowClear) {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(element, Object.assign({}, value));
      }

      var affixWrapperCls = classnames_default()(className, "".concat(prefixCls, "-affix-wrapper"), "".concat(prefixCls, "-affix-wrapper-textarea-with-clear-btn"));
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": affixWrapperCls,
        "style": style
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(element, Object.assign({
        style: null
      }, value)), renderClearIcon(prefixCls)]);
    };

    var renderClearableLabeledInput = function renderClearableLabeledInput() {
      var prefixCls = props.prefixCls,
          inputType = props.inputType,
          element = props.element;

      if (inputType === ClearableInputType[0]) {
        return renderTextAreaWithClearIcon(prefixCls, element);
      }

      return renderInputWithLabel(prefixCls, renderLabeledIcon(prefixCls, element));
    };

    return {
      renderClearableLabeledInput: renderClearableLabeledInput
    };
  },
  render: function render() {
    return this.renderClearableLabeledInput();
  }
});
/* harmony default export */ var input_ClearableLabeledInput = (ClearableLabeledInput);
// CONCATENATED MODULE: ./src/components/input/inputProps.ts


/* harmony default export */ var input_inputProps = ({
  prefixCls: vue_types.string,
  inputPrefixCls: vue_types.string,
  defaultValue: vue_types.oneOfType([vue_types.string, vue_types.number]),
  value: vue_types.oneOfType([vue_types.string, vue_types.number]),
  placeholder: [String, Number],
  type: {
    "default": 'text',
    type: String
  },
  name: String,
  size: vue_types.oneOf(['small', 'large', 'default']),
  disabled: vue_types.bool,
  readOnly: vue_types.bool,
  addonBefore: vue_types.any,
  addonAfter: vue_types.any,
  // onPressEnter?: React.FormEventHandler<any>;
  // onKeyDown?: React.FormEventHandler<any>;
  // onChange?: React.ChangeEventHandler<HTMLInputElement>;
  // onClick?: React.FormEventHandler<any>;
  // onFocus?: React.FormEventHandler<any>;
  // onBlur?: React.FormEventHandler<any>;
  prefix: vue_types.any,
  suffix: vue_types.any,
  // spellCheck: Boolean,
  autoFocus: Boolean,
  allowClear: Boolean,
  lazy: {
    "default": true,
    type: Boolean
  },
  maxLength: vue_types.number,
  loading: vue_types.bool,
  className: vue_types.string
});
// CONCATENATED MODULE: ./src/components/input/calculateNodeHeight.ts

// Thanks to https://github.com/andreypopp/react-textarea-autosize/

/**
 * calculateNodeHeight(uiTextNode, useCache = false)
 */
var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important\n";
var SIZING_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'font-variant', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];
var computedStyleCache = {};
var hiddenTextarea;
function calculateNodeStyling(node) {
  var useCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var nodeRef = node.getAttribute('id') || node.getAttribute('data-reactid') || node.getAttribute('name');

  if (useCache && computedStyleCache[nodeRef]) {
    return computedStyleCache[nodeRef];
  }

  var style = window.getComputedStyle(node);
  var boxSizing = style.getPropertyValue('box-sizing') || style.getPropertyValue('-moz-box-sizing') || style.getPropertyValue('-webkit-box-sizing');
  var paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));
  var borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));
  var sizingStyle = SIZING_STYLE.map(function (name) {
    return "".concat(name, ":").concat(style.getPropertyValue(name));
  }).join(';');
  var nodeInfo = {
    sizingStyle: sizingStyle,
    paddingSize: paddingSize,
    borderSize: borderSize,
    boxSizing: boxSizing
  };

  if (useCache && nodeRef) {
    computedStyleCache[nodeRef] = nodeInfo;
  }

  return nodeInfo;
}
function calculateNodeHeight(uiTextNode) {
  var useCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var minRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var maxRows = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    document.body.appendChild(hiddenTextarea);
  } // Fix wrap="off" issue
  // https://github.com/ant-design/ant-design/issues/6577


  if (uiTextNode.getAttribute('wrap')) {
    hiddenTextarea.setAttribute('wrap', uiTextNode.getAttribute('wrap'));
  } else {
    hiddenTextarea.removeAttribute('wrap');
  } // Copy all CSS properties that have an impact on the height of the content in
  // the textbox


  var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache),
      paddingSize = _calculateNodeStyling.paddingSize,
      borderSize = _calculateNodeStyling.borderSize,
      boxSizing = _calculateNodeStyling.boxSizing,
      sizingStyle = _calculateNodeStyling.sizingStyle; // Need to have the overflow attribute to hide the scrollbar otherwise
  // text-lines will not calculated properly as the shadow will technically be
  // narrower for content


  hiddenTextarea.setAttribute('style', "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || '';
  var minHeight = Number.MIN_SAFE_INTEGER;
  var maxHeight = Number.MAX_SAFE_INTEGER;
  var height = hiddenTextarea.scrollHeight;
  var overflowY;

  if (boxSizing === 'border-box') {
    // border-box: add border, since height = content + padding + border
    height += borderSize;
  } else if (boxSizing === 'content-box') {
    // remove padding, since height = content
    height -= paddingSize;
  }

  if (minRows !== null || maxRows !== null) {
    // measure height of a textarea with a single row
    hiddenTextarea.value = ' ';
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

    if (minRows !== null) {
      minHeight = singleRowHeight * minRows;

      if (boxSizing === 'border-box') {
        minHeight = minHeight + paddingSize + borderSize;
      }

      height = Math.max(minHeight, height);
    }

    if (maxRows !== null) {
      maxHeight = singleRowHeight * maxRows;

      if (boxSizing === 'border-box') {
        maxHeight = maxHeight + paddingSize + borderSize;
      }

      overflowY = height > maxHeight ? '' : 'hidden';
      height = Math.min(maxHeight, height);
    }
  }

  return {
    height: "".concat(height, "px"),
    minHeight: "".concat(minHeight, "px"),
    maxHeight: "".concat(maxHeight, "px"),
    overflowY: overflowY
  };
}
// CONCATENATED MODULE: ./src/components/input/ResizableTextArea.tsx


function ResizableTextArea_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function ResizableTextArea_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ResizableTextArea_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ResizableTextArea_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }










var RESIZE_STATUS_NONE = 0;
var RESIZE_STATUS_RESIZING = 1;
var RESIZE_STATUS_RESIZED = 2;
var TextAreaProps = Object.assign(Object.assign({}, input_inputProps), {
  autosize: vue_types.oneOfType([Object, Boolean]),
  autoSize: vue_types.oneOfType([Object, Boolean])
});
var ResizableTextArea = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ResizableTextArea',
  props: TextAreaProps,
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        attrs = _ref.attrs;
    var textareaStyles = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])({});
    var resizeStatus = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(RESIZE_STATUS_NONE);
    var nextFrameActionId = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var resizeFrameId = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var textAreaRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      resizeTextarea();
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      wrapperRaf.cancel(nextFrameActionId.value);
      wrapperRaf.cancel(resizeFrameId.value);
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.value;
    }, function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        resizeTextarea();
      });
    });

    var handleResize = function handleResize(size) {
      var autoSize = props.autoSize;

      if (resizeStatus.value !== RESIZE_STATUS_NONE) {
        return;
      }

      emit('resize', size);

      if (autoSize) {
        resizeOnNextFrame();
      }
    };

    var resizeOnNextFrame = function resizeOnNextFrame() {
      wrapperRaf.cancel(nextFrameActionId.value);
      nextFrameActionId.value = wrapperRaf(resizeTextarea);
    };

    var resizeTextarea = function resizeTextarea() {
      var autoSize = props.autoSize || props.autosize;

      if (!autoSize || !textAreaRef.value) {
        return;
      }

      var minRows = autoSize.minRows,
          maxRows = autoSize.maxRows;
      textareaStyles.value = calculateNodeHeight(textAreaRef.value, false, minRows, maxRows);
      resizeStatus.value = RESIZE_STATUS_RESIZING;
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        wrapperRaf.cancel(resizeFrameId.value);
        resizeFrameId.value = wrapperRaf(function () {
          resizeStatus.value = RESIZE_STATUS_RESIZED;
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
            resizeFrameId.value = wrapperRaf(function () {
              resizeStatus.value = RESIZE_STATUS_NONE;
              fixFirefoxAutoScroll();
            });
          });
        });
      });
    }; // https://github.com/ant-design/ant-design/issues/21870


    var fixFirefoxAutoScroll = function fixFirefoxAutoScroll() {
      try {
        if (document.activeElement === textAreaRef.value) {
          var currentStart = textAreaRef.value.selectionStart;
          var currentEnd = textAreaRef.value.selectionEnd;
          textAreaRef.value.setSelectionRange(currentStart, currentEnd);
        }
      } catch (e) {// Fix error in Chrome:
        // Failed to read the 'selectionStart' property from 'HTMLInputElement'
        // http://stackoverflow.com/q/21177489/3040605
      }
    };

    var renderTextArea = function renderTextArea() {
      var prefixCls = props.prefixCls,
          autoSize = props.autoSize,
          autosize = props.autosize,
          disabled = props.disabled;
      _util_warning(autosize === undefined, 'Input.TextArea', 'autosize is deprecated, please use autoSize instead.');
      var otherProps = es(props, ['prefixCls', 'autoSize', 'autosize', 'defaultValue', 'allowClear', 'type', 'lazy', 'value']);
      var cls = classnames_default()(prefixCls, defineProperty_default()({}, "".concat(prefixCls, "-disabled"), disabled));
      var domProps = {}; // Fix https://github.com/ant-design/ant-design/issues/6776
      // Make sure it could be reset when using form.getFieldDecorator

      if ('value' in props) {
        domProps.value = props.value || '';
      }

      var style = Object.assign(Object.assign({}, textareaStyles.value), resizeStatus.value === RESIZE_STATUS_RESIZING ? {
        overflowX: 'hidden',
        overflowY: 'hidden'
      } : null);
      var textareaProps = Object.assign(Object.assign(Object.assign({}, domProps), attrs), {
        placeholder: props.placeholder,
        disabled: props.disabled,
        readonly: props.readOnly,
        style: style,
        "class": cls,
        ref: function ref(el) {
          textAreaRef.value = el;
        }
      });
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_resize_observer, {
        "onResize": handleResize,
        "disabled": !(autoSize || autosize)
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("textarea", ResizableTextArea_objectSpread({}, textareaProps), [])]);
    };

    return {
      textareaStyles: textareaStyles,
      resizeTextarea: resizeTextarea,
      resizeStatus: resizeStatus,
      renderTextArea: renderTextArea
    };
  },
  render: function render() {
    return this.renderTextArea();
  }
});
/* harmony default export */ var input_ResizableTextArea = (ResizableTextArea);
// CONCATENATED MODULE: ./src/components/input/textarea.tsx


function textarea_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function textarea_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { textarea_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { textarea_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }










var textarea_TextAreaProps = Object.assign(Object.assign({}, input_inputProps), {
  autosize: vue_types.oneOfType([Object, Boolean]),
  autoSize: vue_types.oneOfType([Object, Boolean])
});
/* harmony default export */ var input_textarea = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ATextarea',
  inheritAttrs: false,
  props: Object.assign({}, textarea_TextAreaProps),
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        attrs = _ref.attrs;
    var configProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('configProvider') || ConfigConsumerProps;
    var stateValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(typeof props.value === 'undefined' ? props.defaultValue : props.value);
    var resizableTextAreaRef = null;
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        if (props.autoFocus) {
          focus();
        }
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.value;
    }, function (val) {
      stateValue.value = val;
    });

    var setValue = function setValue(value, callback) {
      if (props.value === undefined) {
        stateValue.value = value;
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
          callback && callback();
        });
      }
    };

    var _useBaseInput = base_input_useBaseInput(),
        _emit = _useBaseInput._emit;

    var handleKeyDown = function handleKeyDown(e) {
      if (e.key === KeyName.Enter) {
        _emit('pressEnter', e);
      }

      _emit('keydown', e);
    };

    var onChange = function onChange(e) {
      _emit('update:value', stateValue.value);

      _emit('change', e, stateValue.value);
    };

    var focus = function focus() {
      var _a;

      (_a = resizableTextAreaRef === null || resizableTextAreaRef === void 0 ? void 0 : resizableTextAreaRef.$refs.textArea) === null || _a === void 0 ? void 0 : _a.focus();
    };

    var blur = function blur() {
      var _a;

      (_a = resizableTextAreaRef === null || resizableTextAreaRef === void 0 ? void 0 : resizableTextAreaRef.$refs.textArea) === null || _a === void 0 ? void 0 : _a.blur();
    };

    var handleChange = function handleChange(e) {
      var _e$target = e.target,
          value = _e$target.value,
          composing = _e$target.composing;

      if (composing || stateValue.value === value) {
        return;
      }

      setValue(e.target.value, function () {
        resizableTextAreaRef === null || resizableTextAreaRef === void 0 ? void 0 : resizableTextAreaRef.resizeTextarea();
      });
      resolveOnChange(resizableTextAreaRef === null || resizableTextAreaRef === void 0 ? void 0 : resizableTextAreaRef.$refs.textArea, e, onChange);
    };

    var handleReset = function handleReset(e) {
      setValue('', function () {
        resizableTextAreaRef === null || resizableTextAreaRef === void 0 ? void 0 : resizableTextAreaRef.renderTextArea();
        focus();
      });
      resolveOnChange(resizableTextAreaRef === null || resizableTextAreaRef === void 0 ? void 0 : resizableTextAreaRef.$refs.textArea, e, onChange);
    };

    var renderTextArea = function renderTextArea(prefixCls) {
      var resizeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, props), {
        prefixCls: prefixCls,
        onInput: handleChange,
        onKeydown: handleKeyDown
      }), attrs), {
        value: stateValue.value
      });
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(input_ResizableTextArea, textarea_objectSpread({}, resizeProps, {
        "ref": function ref(el) {
          return resizableTextAreaRef = el;
        }
      }), []);
    };

    return {
      configProvider: configProvider,
      handleReset: handleReset,
      renderTextArea: renderTextArea,
      stateValue: stateValue,
      focus: focus,
      blur: blur
    };
  },
  render: function render() {
    var stateValue = this.stateValue,
        customizePrefixCls = this.prefixCls;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('input', customizePrefixCls);
    var props = Object.assign(Object.assign(Object.assign({}, this.$props), this.$attrs), {
      prefixCls: prefixCls,
      inputType: 'text',
      value: fixControlledValue(stateValue),
      element: this.renderTextArea(prefixCls),
      handleReset: this.handleReset
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(input_ClearableLabeledInput, textarea_objectSpread({}, props), []);
  }
}));
// CONCATENATED MODULE: ./src/components/input/input.tsx


function input_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function input_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { input_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { input_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }











function input_noop() {}

function fixControlledValue(value) {
  if (value === undefined) {
    return '';
  }

  if (typeof value === 'undefined' || value === null) {
    return '';
  }

  if (typeof value === 'string') {
    return value;
  }

  return value.value;
}
function resolveOnChange(target, event, onChange) {
  if (onChange) {
    if (event.type === 'click') {
      Object.defineProperty(event, 'target', {
        writable: true
      });
      Object.defineProperty(event, 'currentTarget', {
        writable: true
      });

      if (event.target) {
        var originalInputValue = target.value; // change target ref value cause e.target.value should be '' when clear input

        target.value = '';
        onChange(event); // reset target ref value

        target.value = originalInputValue;
        return;
      }
    }

    onChange(event);
  }
}
function getInputClassName(prefixCls, size, disabled) {
  var _classNames;

  return classnames_default()(prefixCls, (_classNames = {}, defineProperty_default()(_classNames, "".concat(prefixCls, "-sm"), size === 'small'), defineProperty_default()(_classNames, "".concat(prefixCls, "-lg"), size === 'large'), defineProperty_default()(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
}
/* harmony default export */ var input_input = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AInput',
  inheritAttrs: false,
  props: Object.assign({}, input_inputProps),
  setup: function setup(props, _ref) {
    var attrs = _ref.attrs;
    var configProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('configProvider') || ConfigConsumerProps;

    var _useLocalValue = value_useLocalValue(props.defaultValue),
        stateValue = _useLocalValue.value,
        setValue = _useLocalValue.setValue;

    var inputRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var _useBaseInput = base_input_useBaseInput(),
        _emit = _useBaseInput._emit;

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        if (props.autoFocus) {
          focus();
        }

        clearPasswordValueAttribute();
      });
    });
    var removePasswordTimeout = null;
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      if (removePasswordTimeout) {
        clearTimeout(removePasswordTimeout);
      }
    });

    var focus = function focus() {
      var _a;

      (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.focus();
    };

    var blur = function blur() {
      var _a;

      (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.blur();
    };

    var select = function select() {
      var _a;

      (_a = inputRef.value) === null || _a === void 0 ? void 0 : _a.select();
    };

    var onChange = function onChange(e) {
      _emit('change', e, e.target.value);
    };

    var handleReset = function handleReset(e) {
      setValue('', function () {
        focus();
      });
      resolveOnChange(inputRef.value, e, onChange);
    };

    var renderInput = function renderInput(prefixCls) {
      var otherProps = {};
      Object.keys(props).filter(function (it) {
        return ['disabled', 'placeholder'].includes(it);
      }).forEach(function (key) {
        otherProps[key] = props[key];
      });
      var localInputProps = Object.assign(Object.assign(Object.assign({
        value: fixControlledValue(stateValue)
      }, otherProps), attrs), {
        type: props.type,
        onKeydown: handleKeyDown,
        onInput: handleChange,
        onBlur: handleBlur,
        onChange: input_noop,
        "class": getInputClassName(prefixCls, props.size, props.disabled),
        ref: function ref() {
          inputRef.value = arguments.length <= 0 ? undefined : arguments[0];
        },
        key: 'ant-input'
      });
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", input_objectSpread({}, localInputProps), []);
    };

    var handleBlur = function handleBlur(e) {
      _emit('blur', e);
    };

    var handleChange = function handleChange(e) {
      var _e$target = e.target,
          value = _e$target.value,
          composing = _e$target.composing;

      if (composing) {
        return;
      }

      setValue(value, clearPasswordValueAttribute);
      resolveOnChange(inputRef.value, e, onChange);
    };

    var clearPasswordValueAttribute = function clearPasswordValueAttribute() {
      // https://github.com/ant-design/ant-design/issues/20541
      removePasswordTimeout = setTimeout(function () {
        if (inputRef.value && inputRef.value.getAttribute && inputRef.value.getAttribute('type') === 'password' && inputRef.value.hasAttribute('value')) {
          inputRef.value.removeAttribute('value');
        }
      });
    };

    var handleKeyDown = function handleKeyDown(e) {
      if (e.key === 'Enter') {
        _emit('pressEnter', e);
      }

      _emit('keydown', e);
    };

    return {
      value: stateValue,
      handleChange: handleChange,
      handleKeyDown: handleKeyDown,
      focus: focus,
      blur: blur,
      select: select,
      configProvider: configProvider,
      handleReset: handleReset,
      renderInput: renderInput
    };
  },
  render: function render(ctx) {
    var componentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    if (ctx.type === 'textarea') {
      var textareaProps = Object.assign(Object.assign(Object.assign({}, ctx.$props), ctx.$attrs), {
        onInput: this.handleChange,
        onKeydown: this.handleKeyDown,
        onChange: input_noop
      });
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(input_textarea, input_objectSpread({}, textareaProps, {
        "ref": "input"
      }), []);
    }

    var customizePrefixCls = this.$props.prefixCls;
    var stateValue = this.value;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('input', customizePrefixCls);
    var addonAfter = props_util_getComponentFromProp(componentInstance, 'addonAfter');
    var addonBefore = props_util_getComponentFromProp(componentInstance, 'addonBefore');
    var suffix = props_util_getComponentFromProp(componentInstance, 'suffix');
    var prefix = props_util_getComponentFromProp(componentInstance, 'prefix');
    var copyProps = this.$props;
    var props = Object.assign(Object.assign({}, componentInstance.attrs), {
      placeholder: copyProps.placeholder,
      defaultValue: copyProps.defaultValue,
      allowClear: copyProps.allowClear,
      disabled: copyProps.disabled,
      type: copyProps.type,
      size: copyProps.size,
      className: copyProps.className,
      readOnly: copyProps.readOnly,
      prefixCls: prefixCls,
      value: fixControlledValue(stateValue),
      inputType: 'input',
      element: this.renderInput(prefixCls),
      handleReset: this.handleReset,
      addonAfter: addonAfter,
      addonBefore: addonBefore,
      suffix: suffix,
      prefix: prefix
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(input_ClearableLabeledInput, input_objectSpread({}, props), []);
  }
}));
// CONCATENATED MODULE: ./src/components/input/data-entry-focus.ts

/* harmony default export */ var data_entry_focus = (function () {
  var elRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
  return {
    focus: function focus() {
      var _a;

      (_a = elRef.value) === null || _a === void 0 ? void 0 : _a.focus();
    },
    blur: function blur() {
      var _a;

      (_a = elRef.value) === null || _a === void 0 ? void 0 : _a.blur();
    },
    setEl: function setEl(el) {
      elRef.value = el;
    },
    getEl: function getEl() {
      return elRef === null || elRef === void 0 ? void 0 : elRef.value;
    }
  };
});
// CONCATENATED MODULE: ./src/components/input/password.tsx


function password_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function password_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { password_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { password_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }










var ActionMap = {
  onClick: 'click',
  onHover: 'mouseover'
};
/* harmony default export */ var input_password = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AInputPassword',
  inheritAttrs: false,
  setup: function setup(props) {
    var visible = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);

    var _DataEntryFocus = data_entry_focus(),
        blur = _DataEntryFocus.blur,
        setEl = _DataEntryFocus.setEl,
        focus = _DataEntryFocus.focus;

    var onVisibleChange = function onVisibleChange() {
      if (props.disabled) {
        return;
      }

      visible.value = !visible.value;
    };

    var getIcon = function getIcon() {
      var _iconProps;

      var prefixCls = props.prefixCls,
          action = props.action;
      var iconTrigger = ActionMap[action] || 'onClick';
      var iconProps = (_iconProps = {
        type: visible.value ? 'eye' : 'eye-invisible'
      }, defineProperty_default()(_iconProps, iconTrigger, onVisibleChange), defineProperty_default()(_iconProps, "onMousedown", function onMousedown(e) {
        // Prevent focused state lost
        // https://github.com/ant-design/ant-design/issues/15173
        e.preventDefault();
      }), defineProperty_default()(_iconProps, "class", "".concat(prefixCls, "-icon")), defineProperty_default()(_iconProps, "key", 'passwordIcon'), _iconProps);
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, password_objectSpread({}, iconProps), []);
    };

    return {
      visible: visible,
      setEl: setEl,
      blur: blur,
      focus: focus,
      getIcon: getIcon
    };
  },
  props: Object.assign(Object.assign({}, input_inputProps), {
    prefixCls: vue_types.string.def('ant-input-password'),
    inputPrefixCls: vue_types.string.def('ant-input'),
    action: vue_types.string.def('click'),
    visibilityToggle: vue_types.bool.def(true)
  }),
  render: function render(ctx) {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var _a = getOptionProps(instance),
        prefixCls = _a.prefixCls,
        inputPrefixCls = _a.inputPrefixCls,
        size = _a.size,
        suffix = _a.suffix,
        visibilityToggle = _a.visibilityToggle,
        restProps = __rest(_a, ["prefixCls", "inputPrefixCls", "size", "suffix", "visibilityToggle"]);

    var suffixIcon = visibilityToggle && this.getIcon();
    var componentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var inputClassName = classnames_default()(prefixCls, defineProperty_default()({}, "".concat(prefixCls, "-").concat(size), !!size));
    var inputProps = Object.assign(Object.assign(Object.assign({}, restProps), this.$attrs), {
      prefixCls: inputPrefixCls,
      size: size,
      suffix: suffixIcon,
      prefix: props_util_getComponentFromProp(componentInstance, 'prefix'),
      addonAfter: props_util_getComponentFromProp(componentInstance, 'addonAfter'),
      addonBefore: props_util_getComponentFromProp(componentInstance, 'addonBefore'),
      type: this.visible ? 'text' : 'password',
      "class": inputClassName,
      ref: ctx.setEl
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(input_input, password_objectSpread({}, inputProps), []);
  }
}));
// EXTERNAL MODULE: ./node_modules/is-mobile/index.js
var is_mobile = __webpack_require__("8df8");

// CONCATENATED MODULE: ./src/components/input/search.tsx


function search_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function search_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { search_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { search_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }














/* harmony default export */ var search = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AInputSearch',
  inheritAttrs: false,
  props: Object.assign(Object.assign({}, input_inputProps), {
    enterButton: vue_types.any
  }),
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var _useBaseInput = base_input_useBaseInput(),
        _emit = _useBaseInput._emit;

    var componentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var configProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('configProvider') || ConfigConsumerProps;

    var onChange = function onChange(e) {
      if (e && e.target && e.type === 'click') {
        _emit('search', e.target.value, e);
      }

      _emit('change', e, e.target.value);
    };

    var onSearch = function onSearch(e) {
      if (props.loading || props.disabled) {
        return;
      }

      _emit('search', componentInstance.refs.input.stateValue, e);

      if (!Object(is_mobile["isMobile"])({
        tablet: true
      })) {
        componentInstance.refs.input.focus();
      }
    };

    var focus = function focus() {
      componentInstance.refs.input.focus();
    };

    var blur = function blur() {
      componentInstance.refs.input.blur();
    };

    var renderLoading = function renderLoading(prefixCls) {
      var size = props.size;
      var enterButton = props_util_getComponentFromProp(componentInstance, 'enterButton'); // 兼容 <a-input-search enterButton />， 因enterButton类型为 any，此类写法 enterButton 为空字符串

      enterButton = enterButton || enterButton === '';

      if (enterButton) {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_button, {
          "class": "".concat(prefixCls, "-button"),
          "type": "primary",
          "size": size,
          "key": "enterButton"
        }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
          "type": "loading"
        }, [])]);
      }

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "class": "".concat(prefixCls, "-icon"),
        "type": "loading",
        "key": "loadingIcon"
      }, []);
    };

    var renderSuffix = function renderSuffix(prefixCls) {
      var loading = props.loading;
      var suffix = props_util_getComponentFromProp(componentInstance, 'suffix');
      var enterButton = props_util_getComponentFromProp(componentInstance, 'enterButton'); // 兼容 <a-input-search enterButton />， 因enterButton类型为 any，此类写法 enterButton 为空字符串

      enterButton = enterButton || enterButton === '';

      if (loading && !enterButton) {
        return [suffix, renderLoading(prefixCls)];
      }

      if (enterButton) {
        return suffix;
      }

      var icon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "class": "".concat(prefixCls, "-icon"),
        "type": "search",
        "key": "searchIcon",
        "onClick": onSearch
      }, []);

      if (suffix) {
        // let cloneSuffix = suffix;
        // if (isValidElement(cloneSuffix) && !cloneSuffix.key) {
        //   cloneSuffix = cloneElement(cloneSuffix, {
        //     key: 'originSuffix',
        //   });
        // }
        return [suffix, icon];
      }

      return icon;
    };

    var renderAddonAfter = function renderAddonAfter(prefixCls) {
      var size = props.size,
          disabled = props.disabled,
          loading = props.loading;
      var btnClassName = "".concat(prefixCls, "-button");
      var enterButton = props_util_getComponentFromProp(componentInstance, 'enterButton');
      enterButton = enterButton || enterButton === '';
      var addonAfter = props_util_getComponentFromProp(componentInstance, 'addonAfter');

      if (loading && enterButton) {
        return [renderLoading(prefixCls), addonAfter];
      }

      if (!enterButton) {
        return addonAfter;
      }

      var enterButtonAsElement = Array.isArray(enterButton) ? enterButton[0] : enterButton;
      var button;
      var isAntdButton = enterButtonAsElement.componentOptions && enterButtonAsElement.componentOptions.Ctor.extendOptions.__ANT_BUTTON;

      if (enterButtonAsElement.tag === 'button' || isAntdButton) {
        button = cloneElement(enterButtonAsElement, Object.assign(Object.assign({
          key: 'enterButton',
          "class": isAntdButton ? btnClassName : ''
        }, isAntdButton ? {
          size: size
        } : {}), {
          onClick: onSearch
        }));
      } else {
        button = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_button, {
          "class": btnClassName,
          "type": "primary",
          "size": size,
          "disabled": disabled,
          "key": "enterButton",
          "onClick": onSearch
        }, [enterButton === true || enterButton === '' ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
          "type": "search"
        }, []) : enterButton]);
      }

      if (addonAfter) {
        return [button, addonAfter];
      }

      return button;
    };

    return {
      configProvider: configProvider,
      focus: focus,
      blur: blur,
      onSearch: onSearch,
      onChange: onChange,
      renderSuffix: renderSuffix,
      renderAddonAfter: renderAddonAfter
    };
  },
  render: function render() {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var _a = getOptionProps(instance),
        customizePrefixCls = _a.prefixCls,
        customizeInputPrefixCls = _a.inputPrefixCls,
        size = _a.size,
        loading = _a.loading,
        others = __rest(_a, ["prefixCls", "inputPrefixCls", "size", "loading"]);

    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('input-search', customizePrefixCls);
    var inputPrefixCls = getPrefixCls('input', customizeInputPrefixCls);
    var componentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var enterButton = props_util_getComponentFromProp(componentInstance, 'enterButton');
    var addonBefore = props_util_getComponentFromProp(componentInstance, 'addonBefore');
    enterButton = enterButton || enterButton === '';
    var inputClassName;

    if (enterButton) {
      var _classNames;

      inputClassName = classnames_default()(prefixCls, (_classNames = {}, defineProperty_default()(_classNames, "".concat(prefixCls, "-enter-button"), !!enterButton), defineProperty_default()(_classNames, "".concat(prefixCls, "-").concat(size), !!size), _classNames));
    } else {
      inputClassName = prefixCls;
    }

    var inputProps = Object.assign(Object.assign(Object.assign(Object.assign({}, others), {
      prefixCls: inputPrefixCls,
      size: size,
      suffix: this.renderSuffix(prefixCls),
      prefix: props_util_getComponentFromProp(componentInstance, 'prefix'),
      addonAfter: this.renderAddonAfter(prefixCls),
      addonBefore: addonBefore,
      className: inputClassName
    }), this.$attrs), {
      ref: 'input',
      onPressEnter: this.onSearch,
      onChange: this.onChange
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(input_input, search_objectSpread({}, inputProps), []);
  }
}));
// CONCATENATED MODULE: ./src/components/input/index.ts







input_input.Group = group;
input_input.Search = search;
input_input.TextArea = input_textarea;
input_input.Password = input_password;
/* istanbul ignore next */

input_input.install = function (app) {
  app.use(base);
  app.component(input_input.name, input_input);
  app.component(input_input.Group.name, input_input.Group);
  app.component(input_input.Search.name, input_input.Search);
  app.component(input_input.TextArea.name, input_input.TextArea);
  app.component(input_input.Password.name, input_input.Password);
};

/* harmony default export */ var components_input = (input_input);
// EXTERNAL MODULE: ./node_modules/shallow-equal/arrays/index.js
var arrays = __webpack_require__("c2b3");
var arrays_default = /*#__PURE__*/__webpack_require__.n(arrays);

// CONCATENATED MODULE: ./src/components/vc-util/Dom/contains.js

function contains(root, n) {
  var node = n;

  while (node) {
    if (node === root) {
      return true;
    }

    node = node.parentNode;
  }

  return false;
}
// CONCATENATED MODULE: ./src/components/select/utils.tsx



function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return Object.assign(Object.assign({}, baseAlign), align);
}
function toTitle(title) {
  if (typeof title === 'string') {
    return title.trim();
  }

  return '';
}
function getValuePropValue(child) {
  var _a;

  if (!child) {
    return null;
  }

  return (_a = child.props) === null || _a === void 0 ? void 0 : _a.value;
}
function getPropValue(child) {
  var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'value';

  if (prop === 'value') {
    return getValuePropValue(child);
  }

  if (prop === 'children') {
    var newChild = child.children;

    if (Array.isArray(newChild) && newChild.length === 1 && typeof newChild[0] === 'string') {
      return newChild[0];
    } else if (typeof_default()(newChild) === 'object' && newChild['default']) {
      return newChild['default']();
    }

    return newChild;
  }

  var data = getPropsData(child);

  if (prop in data) {
    return data[prop];
  } else {
    return getAttrs(child)[prop];
  }
}
function isMultiple(props) {
  return props.mode === 'multiple';
}
function isCombobox(props) {
  return props.mode === 'combobox';
}
function isMultipleOrTags(props) {
  return props.mode === 'multiple' || props.mode === 'tags';
}
function isMultipleOrTagsOrCombobox(props) {
  return isMultipleOrTags(props) || isCombobox(props);
}
function isSingleMode(props) {
  return !isMultipleOrTagsOrCombobox(props);
}
function toArray(value) {
  var ret = value;

  if (value === undefined) {
    ret = [];
  } else if (!Array.isArray(value)) {
    ret = [value];
  }

  return ret;
}
function getMapKey(value) {
  return "".concat(typeof_default()(value), "-").concat(value);
}
function preventDefaultEvent(e) {
  e.preventDefault();
}
function findIndexInValueBySingleValue(value, singleValue) {
  var index = -1;

  if (value) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === singleValue) {
        index = i;
        break;
      }
    }
  }

  return index;
}
function getLabelFromPropsValue(value, key) {
  var label;
  var copyValue = toArray(value);

  if (copyValue) {
    for (var i = 0; i < copyValue.length; i++) {
      if (copyValue[i].key === key) {
        label = copyValue[i].label;
        break;
      }
    }
  }

  return label;
}
function getSelectKeys(menuItems, value) {
  if (value === null || value === undefined) {
    return [];
  }

  var selectedKeys = [];
  menuItems.forEach(function (item) {
    if (getSlotOptions(item).isMenuItemGroup) {
      selectedKeys = selectedKeys.concat(getSelectKeys(item.componentOptions.children, value));
    } else {
      var itemValue = getValuePropValue(item);
      var itemKey = item.key;

      if (findIndexInValueBySingleValue(value, itemValue) !== -1 && itemKey !== undefined) {
        selectedKeys.push(itemKey);
      }
    }
  });
  return selectedKeys;
}
var UNSELECTABLE_STYLE = {
  userSelect: 'none'
};
var UNSELECTABLE_ATTRIBUTE = {
  unselectable: 'on'
};
function findFirstMenuItem(children) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    var props = getPropsData(child);

    if (getSlotOptions(child).isMenuItemGroup) {
      var found = findFirstMenuItem(child.componentOptions.children);

      if (found) {
        return found;
      }
    } else if (!props.disabled) {
      return child;
    }
  }

  return null;
}
function includesSeparators(str, separators) {
  for (var i = 0; i < separators.length; ++i) {
    if (str.lastIndexOf(separators[i]) > 0) {
      return true;
    }
  }

  return false;
}
function splitBySeparators(str, separators) {
  var reg = new RegExp("[".concat(separators.join(), "]"));
  return str.split(reg).filter(function (token) {
    return token;
  });
}
function validateOptionValue(value, props) {
  if (isSingleMode(props) || isMultiple(props)) {
    return;
  }

  if (typeof value !== 'string' && typeof value !== 'number') {
    throw new Error("Invalid `value` of type `".concat(typeof_default()(value), "` supplied to Option, ") + "expected `string` when `tags/combobox` is `true`.");
  }
}
function utils_saveRef(instance, name) {
  return function (node) {
    instance[name] = node;
  };
}
function generateUUID() {
  if (false) {}

  var d = new Date().getTime();
  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c === 'x' ? r : r & 0x7 | 0x8).toString(16);
  });
  return uuid;
}
function utils_isHidden(node) {
  return !node || node.offsetParent === null;
}
// CONCATENATED MODULE: ./src/components/vc-tooltip/placements.ts

var placements_autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset = [0, 0];
var placements = {
  left: {
    points: ['cr', 'cl'],
    overflow: placements_autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset
  },
  right: {
    points: ['cl', 'cr'],
    overflow: placements_autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  top: {
    points: ['bc', 'tc'],
    overflow: placements_autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  bottom: {
    points: ['tc', 'bc'],
    overflow: placements_autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  topLeft: {
    points: ['bl', 'tl'],
    overflow: placements_autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  leftTop: {
    points: ['tr', 'tl'],
    overflow: placements_autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: placements_autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  rightTop: {
    points: ['tl', 'tr'],
    overflow: placements_autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: placements_autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  rightBottom: {
    points: ['bl', 'br'],
    overflow: placements_autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: placements_autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  leftBottom: {
    points: ['br', 'bl'],
    overflow: placements_autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset
  }
};
/* harmony default export */ var vc_tooltip_placements = (placements);
// CONCATENATED MODULE: ./node_modules/dom-align/dist-web/index.js
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function dist_web_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      dist_web_ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      dist_web_ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var vendorPrefix;
var jsCssMap = {
  Webkit: '-webkit-',
  Moz: '-moz-',
  // IE did it wrong again ...
  ms: '-ms-',
  O: '-o-'
};

function getVendorPrefix() {
  if (vendorPrefix !== undefined) {
    return vendorPrefix;
  }

  vendorPrefix = '';
  var style = document.createElement('p').style;
  var testProp = 'Transform';

  for (var key in jsCssMap) {
    if (key + testProp in style) {
      vendorPrefix = key;
    }
  }

  return vendorPrefix;
}

function dist_web_getTransitionName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : 'transitionProperty';
}

function getTransformName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : 'transform';
}
function setTransitionProperty(node, value) {
  var name = dist_web_getTransitionName();

  if (name) {
    node.style[name] = value;

    if (name !== 'transitionProperty') {
      node.style.transitionProperty = value;
    }
  }
}

function setTransform(node, value) {
  var name = getTransformName();

  if (name) {
    node.style[name] = value;

    if (name !== 'transform') {
      node.style.transform = value;
    }
  }
}

function getTransitionProperty(node) {
  return node.style.transitionProperty || node.style[dist_web_getTransitionName()];
}
function getTransformXY(node) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());

  if (transform && transform !== 'none') {
    var matrix = transform.replace(/[^0-9\-.,]/g, '').split(',');
    return {
      x: parseFloat(matrix[12] || matrix[4], 0),
      y: parseFloat(matrix[13] || matrix[5], 0)
    };
  }

  return {
    x: 0,
    y: 0
  };
}
var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;
function setTransformXY(node, xy) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());

  if (transform && transform !== 'none') {
    var arr;
    var match2d = transform.match(matrix2d);

    if (match2d) {
      match2d = match2d[1];
      arr = match2d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[4] = xy.x;
      arr[5] = xy.y;
      setTransform(node, "matrix(".concat(arr.join(','), ")"));
    } else {
      var match3d = transform.match(matrix3d)[1];
      arr = match3d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[12] = xy.x;
      arr[13] = xy.y;
      setTransform(node, "matrix3d(".concat(arr.join(','), ")"));
    }
  } else {
    setTransform(node, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
  }
}

var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var getComputedStyleX; // https://stackoverflow.com/a/3485654/3040605

function forceRelayout(elem) {
  var originalStyle = elem.style.display;
  elem.style.display = 'none';
  elem.offsetHeight; // eslint-disable-line

  elem.style.display = originalStyle;
}

function css(el, name, v) {
  var value = v;

  if (_typeof(name) === 'object') {
    for (var i in name) {
      if (name.hasOwnProperty(i)) {
        css(el, i, name[i]);
      }
    }

    return undefined;
  }

  if (typeof value !== 'undefined') {
    if (typeof value === 'number') {
      value = "".concat(value, "px");
    }

    el.style[name] = value;
    return undefined;
  }

  return getComputedStyleX(el, name);
}

function getClientPosition(elem) {
  var box;
  var x;
  var y;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement; // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式

  box = elem.getBoundingClientRect(); // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

  x = box.left;
  y = box.top; // In IE, most of the time, 2 extra pixels are added to the top and left
  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
  // IE6 standards mode, this border can be overridden by setting the
  // document element's border to zero -- thus, we cannot rely on the
  // offset always being 2 pixels.
  // In quirks mode, the offset can be determined by querying the body's
  // clientLeft/clientTop, but in standards mode, it is found by querying
  // the document element's clientLeft/clientTop.  Since we already called
  // getClientBoundingRect we have already forced a reflow, so it is not
  // too expensive just to query them all.
  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
  // 窗口边框标准是设 documentElement ,quirks 时设置 body
  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
  // 标准 ie 下 docElem.clientTop 就是 border-top
  // ie7 html 即窗口边框改变不了。永远为 2
  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x,
    top: y
  };
}

function getScroll(w, top) {
  var ret = w["page".concat(top ? 'Y' : 'X', "Offset")];
  var method = "scroll".concat(top ? 'Top' : 'Left');

  if (typeof ret !== 'number') {
    var d = w.document; // ie6,7,8 standard mode

    ret = d.documentElement[method];

    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }

  return ret;
}

function getScrollLeft(w) {
  return getScroll(w);
}

function getScrollTop(w) {
  return getScroll(w, true);
}

function getOffset(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w);
  pos.top += getScrollTop(w);
  return pos;
}
/**
 * A crude way of determining if an object is a window
 * @member util
 */


function isWindow(obj) {
  // must use == for ie8

  /* eslint eqeqeq:0 */
  return obj !== null && obj !== undefined && obj == obj.window;
}

function getDocument(node) {
  if (isWindow(node)) {
    return node.document;
  }

  if (node.nodeType === 9) {
    return node;
  }

  return node.ownerDocument;
}

function _getComputedStyle(elem, name, cs) {
  var computedStyle = cs;
  var val = '';
  var d = getDocument(elem);
  computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null); // https://github.com/kissyteam/kissy/issues/61

  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }

  return val;
}

var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), 'i');

var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = 'currentStyle';
var RUNTIME_STYLE = 'runtimeStyle';
var LEFT = 'left';
var PX = 'px';

function _getComputedStyleIE(elem, name) {
  // currentStyle maybe null
  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name]; // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
  // 在 ie 下不对，需要直接用 offset 方式
  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了
  // From the awesome hack by Dean Edwards
  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
  // If we're not dealing with a regular pixel number
  // but a number that has a weird ending, we need to convert it to pixels
  // exclude left right for relativity

  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    // Remember the original values
    var style = elem.style;
    var left = style[LEFT];
    var rsLeft = elem[RUNTIME_STYLE][LEFT]; // prevent flashing of content

    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT]; // Put in the new values to get a computed value out

    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
    ret = style.pixelLeft + PX; // Revert the changed values

    style[LEFT] = left;
    elem[RUNTIME_STYLE][LEFT] = rsLeft;
  }

  return ret === '' ? 'auto' : ret;
}

if (typeof window !== 'undefined') {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}

function getOffsetDirection(dir, option) {
  if (dir === 'left') {
    return option.useCssRight ? 'right' : dir;
  }

  return option.useCssBottom ? 'bottom' : dir;
}

function oppositeOffsetDirection(dir) {
  if (dir === 'left') {
    return 'right';
  } else if (dir === 'right') {
    return 'left';
  } else if (dir === 'top') {
    return 'bottom';
  } else if (dir === 'bottom') {
    return 'top';
  }
} // 设置 elem 相对 elem.ownerDocument 的坐标


function setLeftTop(elem, offset, option) {
  // set position first, in-case top/left are set even on static elem
  if (css(elem, 'position') === 'static') {
    elem.style.position = 'relative';
  }

  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection('left', option);
  var verticalProperty = getOffsetDirection('top', option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);

  if (horizontalProperty !== 'left') {
    presetH = 999;
  }

  if (verticalProperty !== 'top') {
    presetV = 999;
  }

  var originalTransition = '';
  var originalOffset = getOffset(elem);

  if ('left' in offset || 'top' in offset) {
    originalTransition = getTransitionProperty(elem) || '';
    setTransitionProperty(elem, 'none');
  }

  if ('left' in offset) {
    elem.style[oppositeHorizontalProperty] = '';
    elem.style[horizontalProperty] = "".concat(presetH, "px");
  }

  if ('top' in offset) {
    elem.style[oppositeVerticalProperty] = '';
    elem.style[verticalProperty] = "".concat(presetV, "px");
  } // force relayout


  forceRelayout(elem);
  var old = getOffset(elem);
  var originalStyle = {};

  for (var key in offset) {
    if (offset.hasOwnProperty(key)) {
      var dir = getOffsetDirection(key, option);
      var preset = key === 'left' ? presetH : presetV;
      var off = originalOffset[key] - old[key];

      if (dir === key) {
        originalStyle[dir] = preset + off;
      } else {
        originalStyle[dir] = preset - off;
      }
    }
  }

  css(elem, originalStyle); // force relayout

  forceRelayout(elem);

  if ('left' in offset || 'top' in offset) {
    setTransitionProperty(elem, originalTransition);
  }

  var ret = {};

  for (var _key in offset) {
    if (offset.hasOwnProperty(_key)) {
      var _dir = getOffsetDirection(_key, option);

      var _off = offset[_key] - originalOffset[_key];

      if (_key === _dir) {
        ret[_dir] = originalStyle[_dir] + _off;
      } else {
        ret[_dir] = originalStyle[_dir] - _off;
      }
    }
  }

  css(elem, ret);
}

function setTransform$1(elem, offset) {
  var originalOffset = getOffset(elem);
  var originalXY = getTransformXY(elem);
  var resultXY = {
    x: originalXY.x,
    y: originalXY.y
  };

  if ('left' in offset) {
    resultXY.x = originalXY.x + offset.left - originalOffset.left;
  }

  if ('top' in offset) {
    resultXY.y = originalXY.y + offset.top - originalOffset.top;
  }

  setTransformXY(elem, resultXY);
}

function dist_web_setOffset(elem, offset, option) {
  if (option.ignoreShake) {
    var oriOffset = getOffset(elem);
    var oLeft = oriOffset.left.toFixed(0);
    var oTop = oriOffset.top.toFixed(0);
    var tLeft = offset.left.toFixed(0);
    var tTop = offset.top.toFixed(0);

    if (oLeft === tLeft && oTop === tTop) {
      return;
    }
  }

  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset, option);
  } else if (option.useCssTransform && getTransformName() in document.body.style) {
    setTransform$1(elem, offset);
  } else {
    setLeftTop(elem, offset, option);
  }
}

function each(arr, fn) {
  for (var i = 0; i < arr.length; i++) {
    fn(arr[i]);
  }
}

function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
}

var BOX_MODELS = ['margin', 'border', 'padding'];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;

function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name; // Remember the old values, and insert the new ones

  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }

  callback.call(elem); // Revert the old values

  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}

function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop;
  var j;
  var i;

  for (j = 0; j < props.length; j++) {
    prop = props[j];

    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = void 0;

        if (prop === 'border') {
          cssProp = "".concat(prop).concat(which[i], "Width");
        } else {
          cssProp = prop + which[i];
        }

        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }

  return value;
}

var domUtils = {
  getParent: function getParent(element) {
    var parent = element;

    do {
      if (parent.nodeType === 11 && parent.host) {
        parent = parent.host;
      } else {
        parent = parent.parentNode;
      }
    } while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);

    return parent;
  }
};
each(['Width', 'Height'], function (name) {
  domUtils["doc".concat(name)] = function (refWin) {
    var d = refWin.document;
    return Math.max( // firefox chrome documentElement.scrollHeight< body.scrollHeight
    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
    d.documentElement["scroll".concat(name)], // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
    d.body["scroll".concat(name)], domUtils["viewport".concat(name)](d));
  };

  domUtils["viewport".concat(name)] = function (win) {
    // pc browser includes scrollbar in window.innerWidth
    var prop = "client".concat(name);
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop]; // 标准模式取 documentElement
    // backcompat 取 body

    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  };
});
/*
 得到元素的大小信息
 @param elem
 @param name
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */

function getWH(elem, name, ex) {
  var extra = ex;

  if (isWindow(elem)) {
    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }

  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  var borderBoxValue = name === 'width' ? elem.getBoundingClientRect().width : elem.getBoundingClientRect().height;
  var computedStyle = getComputedStyleX(elem);
  var isBorderBox = isBorderBoxFn(elem);
  var cssBoxValue = 0;

  if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
    borderBoxValue = undefined; // Fall back to computed then un computed css if necessary

    cssBoxValue = getComputedStyleX(elem, name);

    if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    } // Normalize '', auto, and prepare for extra


    cssBoxValue = parseFloat(cssBoxValue) || 0;
  }

  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }

  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  var val = borderBoxValue || cssBoxValue;

  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which);
    }

    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }

    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which) : getPBMWidth(elem, ['margin'], which));
  }

  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}

var cssShow = {
  position: 'absolute',
  visibility: 'hidden',
  display: 'block'
}; // fix #119 : https://github.com/kissyteam/kissy/issues/119

function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args[_key2] = arguments[_key2];
  }

  var val;
  var elem = args[0]; // in case elem is window
  // elem.offsetWidth === undefined

  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    swap(elem, cssShow, function () {
      val = getWH.apply(undefined, args);
    });
  }

  return val;
}

each(['width', 'height'], function (name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);

  domUtils["outer".concat(first)] = function (el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };

  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

  domUtils[name] = function (elem, v) {
    var val = v;

    if (val !== undefined) {
      if (elem) {
        var computedStyle = getComputedStyleX(elem);
        var isBorderBox = isBorderBoxFn(elem);

        if (isBorderBox) {
          val += getPBMWidth(elem, ['padding', 'border'], which);
        }

        return css(elem, name, val);
      }

      return undefined;
    }

    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});

function mix(to, from) {
  for (var i in from) {
    if (from.hasOwnProperty(i)) {
      to[i] = from[i];
    }
  }

  return to;
}

var dist_web_utils = {
  getWindow: function getWindow(node) {
    if (node && node.document && node.setTimeout) {
      return node;
    }

    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  getDocument: getDocument,
  offset: function offset(el, value, option) {
    if (typeof value !== 'undefined') {
      dist_web_setOffset(el, value, option || {});
    } else {
      return getOffset(el);
    }
  },
  isWindow: isWindow,
  each: each,
  css: css,
  clone: function clone(obj) {
    var i;
    var ret = {};

    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }

    var overflow = obj.overflow;

    if (overflow) {
      for (i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }

    return ret;
  },
  mix: mix,
  getWindowScrollLeft: function getWindowScrollLeft(w) {
    return getScrollLeft(w);
  },
  getWindowScrollTop: function getWindowScrollTop(w) {
    return getScrollTop(w);
  },
  merge: function merge() {
    var ret = {};

    for (var i = 0; i < arguments.length; i++) {
      dist_web_utils.mix(ret, i < 0 || arguments.length <= i ? undefined : arguments[i]);
    }

    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
mix(dist_web_utils, domUtils);

/**
 * 得到会导致元素显示不全的祖先元素
 */

var getParent = dist_web_utils.getParent;

function getOffsetParent(element) {
  if (dist_web_utils.isWindow(element) || element.nodeType === 9) {
    return null;
  } // ie 这个也不是完全可行

  /*
   <div style="width: 50px;height: 100px;overflow: hidden">
   <div style="width: 50px;height: 100px;position: relative;" id="d6">
   元素 6 高 100px 宽 50px<br/>
   </div>
   </div>
   */
  // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
  //  In other browsers it only includes elements with position absolute, relative or
  // fixed, not elements with overflow set to auto or scroll.
  //        if (UA.ie && ieMode < 8) {
  //            return element.offsetParent;
  //        }
  // 统一的 offsetParent 方法


  var doc = dist_web_utils.getDocument(element);
  var body = doc.body;
  var parent;
  var positionStyle = dist_web_utils.css(element, 'position');
  var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';

  if (!skipStatic) {
    return element.nodeName.toLowerCase() === 'html' ? null : getParent(element);
  }

  for (parent = getParent(element); parent && parent !== body && parent.nodeType !== 9; parent = getParent(parent)) {
    positionStyle = dist_web_utils.css(parent, 'position');

    if (positionStyle !== 'static') {
      return parent;
    }
  }

  return null;
}

var getParent$1 = dist_web_utils.getParent;
function isAncestorFixed(element) {
  if (dist_web_utils.isWindow(element) || element.nodeType === 9) {
    return false;
  }

  var doc = dist_web_utils.getDocument(element);
  var body = doc.body;
  var parent = null;

  for (parent = getParent$1(element); parent && parent !== body; parent = getParent$1(parent)) {
    var positionStyle = dist_web_utils.css(parent, 'position');

    if (positionStyle === 'fixed') {
      return true;
    }
  }

  return false;
}

/**
 * 获得元素的显示部分的区域
 */

function getVisibleRectForElement(element, alwaysByViewport) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = getOffsetParent(element);
  var doc = dist_web_utils.getDocument(element);
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement; // Determine the size of the visible rect by climbing the dom accounting for
  // all scrollable containers.

  while (el) {
    // clientWidth is zero for inline block elements in ie.
    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    el !== body && el !== documentElement && dist_web_utils.css(el, 'overflow') !== 'visible') {
      var pos = dist_web_utils.offset(el); // add border

      pos.left += el.clientLeft;
      pos.top += el.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(visibleRect.right, // consider area without scrollBar
      pos.left + el.clientWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el === body || el === documentElement) {
      break;
    }

    el = getOffsetParent(el);
  } // Set element position to fixed
  // make sure absolute element itself don't affect it's visible area
  // https://github.com/ant-design/ant-design/issues/7601


  var originalPosition = null;

  if (!dist_web_utils.isWindow(element) && element.nodeType !== 9) {
    originalPosition = element.style.position;
    var position = dist_web_utils.css(element, 'position');

    if (position === 'absolute') {
      element.style.position = 'fixed';
    }
  }

  var scrollX = dist_web_utils.getWindowScrollLeft(win);
  var scrollY = dist_web_utils.getWindowScrollTop(win);
  var viewportWidth = dist_web_utils.viewportWidth(win);
  var viewportHeight = dist_web_utils.viewportHeight(win);
  var documentWidth = documentElement.scrollWidth;
  var documentHeight = documentElement.scrollHeight; // scrollXXX on html is sync with body which means overflow: hidden on body gets wrong scrollXXX.
  // We should cut this ourself.

  var bodyStyle = window.getComputedStyle(body);

  if (bodyStyle.overflowX === 'hidden') {
    documentWidth = win.innerWidth;
  }

  if (bodyStyle.overflowY === 'hidden') {
    documentHeight = win.innerHeight;
  } // Reset element position after calculate the visible area


  if (element.style) {
    element.style.position = originalPosition;
  }

  if (alwaysByViewport || isAncestorFixed(element)) {
    // Clip by viewport's size.
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
  } else {
    // Clip by document's size.
    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
  }

  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}

function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = dist_web_utils.clone(elFuturePos);
  var size = {
    width: elRegion.width,
    height: elRegion.height
  };

  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  } // Left edge inside and right edge outside viewport, try to resize it.


  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
    size.width -= pos.left + size.width - visibleRect.right;
  } // Right edge outside viewport, try to move it.


  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
    // 保证左边界和可视区域左边界对齐
    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
  } // Top edge outside viewport, try to move it.


  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  } // Top edge inside and bottom edge outside viewport, try to resize it.


  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
    size.height -= pos.top + size.height - visibleRect.bottom;
  } // Bottom edge outside viewport, try to move it.


  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
    // 保证上边界和可视区域上边界对齐
    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
  }

  return dist_web_utils.mix(pos, size);
}

function getRegion(node) {
  var offset;
  var w;
  var h;

  if (!dist_web_utils.isWindow(node) && node.nodeType !== 9) {
    offset = dist_web_utils.offset(node);
    w = dist_web_utils.outerWidth(node);
    h = dist_web_utils.outerHeight(node);
  } else {
    var win = dist_web_utils.getWindow(node);
    offset = {
      left: dist_web_utils.getWindowScrollLeft(win),
      top: dist_web_utils.getWindowScrollTop(win)
    };
    w = dist_web_utils.viewportWidth(win);
    h = dist_web_utils.viewportHeight(win);
  }

  offset.width = w;
  offset.height = h;
  return offset;
}

/**
 * 获取 node 上的 align 对齐点 相对于页面的坐标
 */
function getAlignOffset(region, align) {
  var V = align.charAt(0);
  var H = align.charAt(1);
  var w = region.width;
  var h = region.height;
  var x = region.left;
  var y = region.top;

  if (V === 'c') {
    y += h / 2;
  } else if (V === 'b') {
    y += h;
  }

  if (H === 'c') {
    x += w / 2;
  } else if (H === 'r') {
    x += w;
  }

  return {
    left: x,
    top: y
  };
}

function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
  var p1 = getAlignOffset(refNodeRegion, points[1]);
  var p2 = getAlignOffset(elRegion, points[0]);
  var diff = [p2.left - p1.left, p2.top - p1.top];
  return {
    left: Math.round(elRegion.left - diff[0] + offset[0] - targetOffset[0]),
    top: Math.round(elRegion.top - diff[1] + offset[1] - targetOffset[1])
  };
}

/**
 * align dom node flexibly
 * @author yiminghe@gmail.com
 */

function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}

function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}

function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}

function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}

function flip(points, reg, map) {
  var ret = [];
  dist_web_utils.each(points, function (p) {
    ret.push(p.replace(reg, function (m) {
      return map[m];
    }));
  });
  return ret;
}

function flipOffset(offset, index) {
  offset[index] = -offset[index];
  return offset;
}

function convertOffset(str, offsetLen) {
  var n;

  if (/%$/.test(str)) {
    n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n = parseInt(str, 10);
  }

  return n || 0;
}

function normalizeOffset(offset, el) {
  offset[0] = convertOffset(offset[0], el.width);
  offset[1] = convertOffset(offset[1], el.height);
}
/**
 * @param el
 * @param tgtRegion 参照节点所占的区域: { left, top, width, height }
 * @param align
 */


function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
  var points = align.points;
  var offset = align.offset || [0, 0];
  var targetOffset = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var source = align.source || el;
  offset = [].concat(offset);
  targetOffset = [].concat(targetOffset);
  overflow = overflow || {};
  var newOverflowCfg = {};
  var fail = 0;
  var alwaysByViewport = !!(overflow && overflow.alwaysByViewport); // 当前节点可以被放置的显示区域

  var visibleRect = getVisibleRectForElement(source, alwaysByViewport); // 当前节点所占的区域, left/top/width/height

  var elRegion = getRegion(source); // 将 offset 转换成数值，支持百分比

  normalizeOffset(offset, elRegion);
  normalizeOffset(targetOffset, tgtRegion); // 当前节点将要被放置的位置

  var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset); // 当前节点将要所处的区域

  var newElRegion = dist_web_utils.merge(elRegion, elFuturePos); // 如果可视区域不能完全放置当前节点时允许调整

  if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
    if (overflow.adjustX) {
      // 如果横向不能放下
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        // 对齐位置反下
        var newPoints = flip(points, /[lr]/gi, {
          l: 'r',
          r: 'l'
        }); // 偏移量也反下

        var newOffset = flipOffset(offset, 0);
        var newTargetOffset = flipOffset(targetOffset, 0);
        var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);

        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset = newOffset;
          targetOffset = newTargetOffset;
        }
      }
    }

    if (overflow.adjustY) {
      // 如果纵向不能放下
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        // 对齐位置反下
        var _newPoints = flip(points, /[tb]/gi, {
          t: 'b',
          b: 't'
        }); // 偏移量也反下


        var _newOffset = flipOffset(offset, 1);

        var _newTargetOffset = flipOffset(targetOffset, 1);

        var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);

        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = _newPoints;
          offset = _newOffset;
          targetOffset = _newTargetOffset;
        }
      }
    } // 如果失败，重新计算当前节点将要被放置的位置


    if (fail) {
      elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset);
      dist_web_utils.mix(newElRegion, elFuturePos);
    }

    var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
    var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect); // 检查反下后的位置是否可以放下了，如果仍然放不下：
    // 1. 复原修改过的定位参数

    if (isStillFailX || isStillFailY) {
      points = align.points;
      offset = align.offset || [0, 0];
      targetOffset = align.targetOffset || [0, 0];
    } // 2. 只有指定了可以调整当前方向才调整


    newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
    newOverflowCfg.adjustY = overflow.adjustY && isStillFailY; // 确实要调整，甚至可能会调整高度宽度

    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  } // need judge to in case set fixed with in css on height auto element


  if (newElRegion.width !== elRegion.width) {
    dist_web_utils.css(source, 'width', dist_web_utils.width(source) + newElRegion.width - elRegion.width);
  }

  if (newElRegion.height !== elRegion.height) {
    dist_web_utils.css(source, 'height', dist_web_utils.height(source) + newElRegion.height - elRegion.height);
  } // https://github.com/kissyteam/kissy/issues/190
  // 相对于屏幕位置没变，而 left/top 变了
  // 例如 <div 'relative'><el absolute></div>


  dist_web_utils.offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom,
    useCssTransform: align.useCssTransform,
    ignoreShake: align.ignoreShake
  });
  return {
    points: points,
    offset: offset,
    targetOffset: targetOffset,
    overflow: newOverflowCfg
  };
}
/**
 *  2012-04-26 yiminghe@gmail.com
 *   - 优化智能对齐算法
 *   - 慎用 resizeXX
 *
 *  2011-07-13 yiminghe@gmail.com note:
 *   - 增加智能对齐，以及大小调整选项
 **/

function isOutOfVisibleRect(target, alwaysByViewport) {
  var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
  var targetRegion = getRegion(target);
  return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
}

function alignElement(el, refNode, align) {
  var target = align.target || refNode;
  var refNodeRegion = getRegion(target);
  var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
  return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
}

alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;

/**
 * `tgtPoint`: { pageX, pageY } or { clientX, clientY }.
 * If client position provided, will internal convert to page position.
 */

function dist_web_alignPoint(el, tgtPoint, align) {
  var pageX;
  var pageY;
  var doc = dist_web_utils.getDocument(el);
  var win = doc.defaultView || doc.parentWindow;
  var scrollX = dist_web_utils.getWindowScrollLeft(win);
  var scrollY = dist_web_utils.getWindowScrollTop(win);
  var viewportWidth = dist_web_utils.viewportWidth(win);
  var viewportHeight = dist_web_utils.viewportHeight(win);

  if ('pageX' in tgtPoint) {
    pageX = tgtPoint.pageX;
  } else {
    pageX = scrollX + tgtPoint.clientX;
  }

  if ('pageY' in tgtPoint) {
    pageY = tgtPoint.pageY;
  } else {
    pageY = scrollY + tgtPoint.clientY;
  }

  var tgtRegion = {
    left: pageX,
    top: pageY,
    width: 0,
    height: 0
  };
  var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight; // Provide default target point

  var points = [align.points[0], 'cc'];
  return doAlign(el, tgtRegion, _objectSpread2({}, align, {
    points: points
  }), pointInView);
}

/* harmony default export */ var dist_web = (alignElement);

//# sourceMappingURL=index.js.map

// EXTERNAL MODULE: ./node_modules/lodash/cloneDeep.js
var cloneDeep = __webpack_require__("0644");
var cloneDeep_default = /*#__PURE__*/__webpack_require__.n(cloneDeep);

// CONCATENATED MODULE: ./src/components/vc-align/util.ts



function buffer(fn, ms) {
  var timer;

  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }

  function bufferFn() {
    clear();
    timer = setTimeout(fn, ms);
  }

  bufferFn.clear = clear;
  return bufferFn;
}
function isSamePoint(prev, next) {
  if (prev === next) {
    return true;
  }

  if (!prev || !next) {
    return false;
  }

  if ('pageX' in next && 'pageY' in next) {
    return prev.pageX === next.pageX && prev.pageY === next.pageY;
  }

  if ('clientX' in next && 'clientY' in next) {
    return prev.clientX === next.clientX && prev.clientY === next.clientY;
  }

  return false;
}
function util_isWindow(obj) {
  return obj && typeof_default()(obj) === 'object' && obj.window === obj;
}
function isSimilarValue(val1, val2) {
  var int1 = Math.floor(val1);
  var int2 = Math.floor(val2);
  return Math.abs(int1 - int2) <= 1;
}
function restoreFocus(activeElement, container) {
  // Focus back if is in the container
  if (activeElement !== document.activeElement && contains(container, activeElement)) {
    activeElement.focus();
  }
}
// CONCATENATED MODULE: ./src/components/vc-align/align.tsx








function getElement(func) {
  if (typeof func !== 'function' || !func) {
    return null;
  }

  return func();
}

function getPoint(point) {
  if (typeof_default()(point) !== 'object' || !point) {
    return null;
  }

  return point;
}

/* harmony default export */ var vc_align_align = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: {
    childrenProps: vue_types.object,
    align: vue_types.object.isRequired,
    target: vue_types.oneOfType([vue_types.func, vue_types.object]).def(function () {
      return window;
    }),
    monitorBufferTime: vue_types.number.def(50),
    monitorWindowResize: vue_types.bool.def(false),
    disabled: vue_types.bool.def(false)
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var sourceRect = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var aligned = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var bufferMonitor = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var resizeHandler = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var prevProps = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var startMonitorWindowResize = function startMonitorWindowResize() {
      if (!resizeHandler.value) {
        bufferMonitor.value = buffer(forceAlign, props.monitorBufferTime);
        resizeHandler.value = addEventListenerWrap(window, 'resize', bufferMonitor.value);
      }
    };

    var stopMonitorWindowResize = function stopMonitorWindowResize() {
      if (resizeHandler.value) {
        bufferMonitor.value.clear();
        resizeHandler.value.remove();
        resizeHandler.value = null;
      }
    };

    var forceAlign = function forceAlign() {
      var disabled = props.disabled,
          target = props.target,
          align = props.align;

      if (!disabled && target) {
        var source = instance.vnode.el;
        var result;
        var element = getElement(target);
        var point = getPoint(target); // IE lose focus after element realign
        // We should record activeElement and restore later

        var activeElement = document.activeElement;

        if (element) {
          result = alignElement(source, element, align);
        } else if (point) {
          result = dist_web_alignPoint(source, point, align);
        }

        restoreFocus(activeElement, source);
        aligned.value = true;
        emit('align', source, result);
      }
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        prevProps.value = Object.assign({}, props); // if parent ref not attached .... use document.getElementById

        !aligned.value && forceAlign();

        if (!props.disabled && props.monitorWindowResize) {
          startMonitorWindowResize();
        }
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        var reAlign = false;

        if (!props.disabled) {
          var source = instance.vnode.el;

          if ((source === null || source === void 0 ? void 0 : source.nodeName) !== '#comment') {
            var currentSourceRect = source ? source.getBoundingClientRect() : null;

            if (prevProps.value.disabled) {
              reAlign = true;
            } else {
              var lastElement = prevProps.value.target;
              var currentElement = props.target;
              var lastPoint = getPoint(prevProps.value.target);
              var currentPoint = getPoint(props.target);

              if (util_isWindow(lastElement) && util_isWindow(currentElement)) {
                // Skip if is window
                reAlign = false;
              } else if (lastElement !== currentElement || // Element change
              lastElement && !currentElement && currentPoint || // Change from element to point
              lastPoint && currentPoint && currentElement || // Change from point to element
              currentPoint && !isSamePoint(lastPoint, currentPoint)) {
                reAlign = true;
              } // If source element size changed


              var preRect = sourceRect.value || {};

              if (!reAlign && source && (!isSimilarValue(preRect.width, currentSourceRect.width) || !isSimilarValue(preRect.height, currentSourceRect.height))) {
                reAlign = true;
              }
            }

            sourceRect.value = currentSourceRect;
          }
        }

        if (reAlign) {
          forceAlign();
        }

        if (props.monitorWindowResize && !props.disabled) {
          startMonitorWindowResize();
        } else {
          stopMonitorWindowResize();
        }

        prevProps.value = Object.assign(Object.assign({}, props), {
          align: cloneDeep_default()(props.align)
        });
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      stopMonitorWindowResize();
    });
    return {
      aligned: aligned,
      forceAlign: forceAlign
    };
  },
  render: function render() {
    return this.$slots["default"] && this.$slots["default"]()[0];
  }
}));
// CONCATENATED MODULE: ./src/components/vc-align/index.ts

// based on vc-align 2.4.5




/* harmony default export */ var vc_align = (vc_align_align);
var vc_align_useAlign = function useAlign(ref, target, placement, shouldAlign) {
  Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
    if (shouldAlign === undefined || shouldAlign()) {
      var align = typeof_default()(placement) === 'object' ? placement : placements[placement];

      if (ref.value && target.value) {
        alignElement(ref.value, target.value, align);
      }
    }
  });
};
// CONCATENATED MODULE: ./src/components/vc-trigger/popup-inner.tsx


function popup_inner_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function popup_inner_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { popup_inner_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { popup_inner_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/* harmony default export */ var popup_inner = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: {
    hiddenClassName: vue_types.string.def(''),
    prefixCls: vue_types.string,
    visible: vue_types.bool
  },
  render: function render() {
    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var _this$$props = this.$props,
        prefixCls = _this$$props.prefixCls,
        visible = _this$$props.visible,
        hiddenClassName = _this$$props.hiddenClassName;
    var divProps = Object.assign({}, getListenersFromInstance(currentInstance));
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", popup_inner_objectSpread({}, divProps, {
      "class": !visible ? hiddenClassName : ''
    }), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-content")
    }, [this.$slots["default"]()])]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-trigger/popup.tsx



function popup_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function popup_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { popup_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { popup_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }









/* harmony default export */ var popup = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'VCTriggerPopup',
  props: {
    visible: vue_types.bool,
    getClassNameFromAlign: vue_types.func,
    getRootDomNode: vue_types.func,
    align: vue_types.any,
    destroyPopupOnHide: vue_types.bool,
    prefixCls: vue_types.string,
    getContainer: vue_types.func,
    transitionName: vue_types.string,
    animation: vue_types.any,
    maskAnimation: vue_types.string,
    maskTransitionName: vue_types.string,
    mask: vue_types.bool,
    zIndex: vue_types.number,
    popupClassName: vue_types.any,
    popupStyle: vue_types.object.def(function () {
      return {};
    }),
    stretch: vue_types.string,
    point: vue_types.shape({
      pageX: vue_types.number,
      pageY: vue_types.number
    })
  },
  setup: function setup(props, _ref) {
    var slots = _ref.slots,
        attrs = _ref.attrs;
    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var domEl = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var rootNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var currentAlignClassName = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var stretchChecked = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var targetHeight = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var targetWidth = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var popupInstanceRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var alignInstanceRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        rootNode.value = getPopupDomNode();
        setStretchSize();
      });
    });

    var onAlign = function onAlign(popupDomNode, align) {
      var alignClassName = props.getClassNameFromAlign(align); // FIX: https://github.com/react-component/trigger/issues/56
      // FIX: https://github.com/react-component/tooltip/issues/79

      if (currentAlignClassName.value !== alignClassName) {
        currentAlignClassName.value = alignClassName;
        popupDomNode.className = getClassName(alignClassName);
      }

      var listeners = getListenersFromInstance(currentInstance);
      listeners.align && listeners.align(popupDomNode, align);
    }; // Record size if stretch needed


    var setStretchSize = function setStretchSize() {
      var stretch = props.stretch,
          getRootDomNode = props.getRootDomNode,
          visible = props.visible;

      if (!stretch || !visible) {
        if (stretchChecked) {
          stretchChecked.value = false;
        }

        return;
      }

      var $ele = getRootDomNode();

      if (!$ele) {
        return;
      }

      var height = $ele.offsetHeight;
      var width = $ele.offsetWidth;

      if (targetHeight !== height || targetWidth !== width || !stretchChecked) {
        stretchChecked.value = true;
        targetHeight.value = height;
        targetWidth.value = width;
      }
    };

    var getPopupDomNode = function getPopupDomNode() {
      return popupInstanceRef.value ? popupInstanceRef.value : null;
    };

    var getTargetElement = function getTargetElement() {
      return props.getRootDomNode();
    }; // `target` on `rc-align` can accept as a function to get the bind element or a point.
    // ref: https://www.npmjs.com/package/rc-align


    var getAlignTarget = function getAlignTarget() {
      var point = props.point;

      if (point) {
        return point;
      }

      return getTargetElement;
    };

    var getMaskTransitionName = function getMaskTransitionName() {
      var transitionName = props.maskTransitionName;
      var animation = props.maskAnimation;

      if (!transitionName && animation) {
        transitionName = "".concat(props.prefixCls, "-").concat(animation);
      }

      return transitionName;
    };

    var getTransitionName = function getTransitionName() {
      var transitionName = props.transitionName;
      var animation = props.animation;

      if (!transitionName) {
        if (typeof animation === 'string') {
          transitionName = "".concat(animation);
        } else if (animation && animation.props && animation.props.name) {
          transitionName = animation.props.name;
        }
      }

      return transitionName;
    };

    var getClassName = function getClassName(currentAlignClassName) {
      return classnames_default()("".concat(props.prefixCls, " ").concat(props.popupClassName, " ").concat(currentAlignClassName), props.popupClassName);
    };

    var getPopupElement = function getPopupElement() {
      var align = props.align,
          visible = props.visible,
          prefixCls = props.prefixCls,
          animation = props.animation,
          popupStyle = props.popupStyle,
          getClassNameFromAlign = props.getClassNameFromAlign,
          destroyPopupOnHide = props.destroyPopupOnHide,
          stretch = props.stretch;
      var className = getClassName(currentAlignClassName.value || getClassNameFromAlign(align)); // const hiddenClassName = `${prefixCls}-hidden`

      if (!visible) {
        currentAlignClassName.value = null;
      }

      var sizeStyle = {};

      if (stretch) {
        // Stretch with target
        if (stretch.indexOf('height') !== -1) {
          sizeStyle.height = typeof targetHeight === 'number' ? "".concat(targetHeight, "px") : targetHeight;
        } else if (stretch.indexOf('minHeight') !== -1) {
          sizeStyle.minHeight = typeof targetHeight === 'number' ? "".concat(targetHeight, "px") : targetHeight;
        }

        if (stretch.indexOf('width') !== -1) {
          sizeStyle.width = typeof targetWidth === 'number' ? "".concat(targetWidth, "px") : targetWidth;
        } else if (stretch.indexOf('minWidth') !== -1) {
          sizeStyle.minWidth = typeof targetWidth === 'number' ? "".concat(targetWidth, "px") : targetWidth;
        } // Delay force align to makes ui smooth


        if (!stretchChecked) {
          // sizeStyle.visibility = 'hidden'
          setTimeout(function () {
            if (alignInstanceRef.value) {
              alignInstanceRef.value.forceAlign();
            }
          }, 0);
        }
      }

      var popupInnerProps = Object.assign(Object.assign({
        "class": className
      }, getListenersFromInstance(currentInstance)), {
        ref: function ref(el) {
          popupInstanceRef.value = el;
        },
        style: Object.assign(Object.assign(Object.assign({}, sizeStyle), popupStyle), getZIndexStyle())
      });
      var transitionProps = {
        appear: true,
        css: false
      };
      var transitionName = getTransitionName();
      var useTransition = !!transitionName;
      var transitionEvent = {
        onBeforeEnter: function onBeforeEnter() {// el.style.display = el.__vOriginalDisplay
          // this.$refs.alignInstance.forceAlign();
        },
        onEnter: function onEnter(el, done) {
          // render 后 vue 会移除通过animate动态添加的 class导致动画闪动，延迟两帧添加动画class，可以进一步定位或者重写 transition 组件
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
            if (alignInstanceRef.value) {
              Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
                domEl.value = el;
                css_animation(el, "".concat(transitionName, "-enter"), done);
              });
            }
          });
        },
        onBeforeLeave: function onBeforeLeave() {
          domEl.value = null;
        },
        onLeave: function onLeave(el, done) {
          css_animation(el, "".concat(transitionName, "-leave"), done);
        }
      };

      if (typeof_default()(animation) === 'object') {
        useTransition = true;

        var _animation$on = animation.on,
            on = _animation$on === void 0 ? {} : _animation$on,
            _animation$props = animation.props,
            _props = _animation$props === void 0 ? {} : _animation$props;

        Object.assign(transitionProps, _props);
        Object.assign(transitionProps, Object.assign(Object.assign({}, transitionEvent), on));
      } else {
        Object.assign(transitionProps, transitionEvent);
      }

      if (!useTransition) {
        transitionProps = {};
      }

      if (destroyPopupOnHide) {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], popup_objectSpread({}, transitionProps), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_align, {
          "target": getAlignTarget(),
          "key": "popup",
          "ref": function ref(el) {
            alignInstanceRef.value = el;
          },
          "monitorWindowResize": true,
          "align": align,
          "onAlign": onAlign
        }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(popup_inner, popup_objectSpread({}, popupInnerProps), slots), [[external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], visible]])])]);
      }

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], popup_objectSpread({}, transitionProps), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_align, {
        "target": getAlignTarget(),
        "key": "popup",
        "ref": "alignInstance",
        "monitorWindowResize": true,
        "disabled": !visible,
        "align": align,
        "onAlign": onAlign
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", popup_objectSpread({}, popupInnerProps), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "onMousedown": preventDefaultEvent,
        "class": "".concat(prefixCls, "-content")
      }, [slots["default"]()])]), [[external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], visible]])])]);
    };

    var getZIndexStyle = function getZIndexStyle() {
      var style = {};

      if (props.zIndex !== undefined) {
        style.zIndex = props.zIndex;
      }

      return style;
    };

    var getMaskElement = function getMaskElement() {
      var maskElement = null;

      if (props.mask) {
        var maskTransition = getMaskTransitionName();
        maskElement = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
          "style": getZIndexStyle(),
          "key": "mask",
          "class": "".concat(props.prefixCls, "-mask")
        }, []), [[external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], props.visible]]);

        if (maskTransition) {
          maskElement = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], {
            "appear": true,
            "name": maskTransition
          }, [maskElement]);
        }
      }

      return maskElement;
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUpdate"])(function () {
      if (domEl.value && domEl.value.rcEndListener) {
        domEl.value.rcEndListener();
        domEl.value = null;
      }
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        setStretchSize();
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      if (currentInstance.vnode.el.parentNode) {
        currentInstance.vnode.el.parentNode.removeChild(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])().vnode.el);
      } else if (currentInstance.vnode.el.remove) {
        currentInstance.vnode.el.remove();
      }
    });
    return {
      // Used for stretch
      stretchChecked: stretchChecked,
      targetWidth: targetWidth,
      targetHeight: targetHeight,
      getMaskElement: getMaskElement,
      getPopupElement: getPopupElement,
      rootNode: rootNode
    };
  },
  render: function render() {
    var getMaskElement = this.getMaskElement,
        getPopupElement = this.getPopupElement;
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {}, [getMaskElement(), getPopupElement()]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-trigger/utils.ts


function isPointsEq(a1, a2, isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }

  return a1[0] === a2[0] && a1[1] === a2[1];
}

function utils_getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return Object.assign(Object.assign({}, baseAlign), align);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  var points = align.points;

  for (var placement in builtinPlacements) {
    if (builtinPlacements.hasOwnProperty(placement)) {
      if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
        return "".concat(prefixCls, "-placement-").concat(placement);
      }
    }
  }

  return '';
}
function vc_trigger_utils_noop() {}
// CONCATENATED MODULE: ./src/components/vc-trigger/trigger.tsx


function trigger_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function trigger_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { trigger_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { trigger_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }













function returnEmptyString() {
  return '';
}

function returnDocument() {
  return window.document;
}

var ALL_HANDLERS = ['click', 'mousedown', 'touchstart', 'mouseenter', 'mouseleave', 'focus', 'blur', 'contextmenu'];
/* harmony default export */ var vc_trigger_trigger = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'Trigger',
  props: {
    action: vue_types.oneOfType([vue_types.string, vue_types.arrayOf(vue_types.string)]).def([]),
    showAction: vue_types.any.def([]),
    hideAction: vue_types.any.def([]),
    getPopupClassNameFromAlign: vue_types.any.def(returnEmptyString),
    afterPopupVisibleChange: vue_types.func.def(vc_trigger_utils_noop),
    popup: vue_types.any,
    popupStyle: vue_types.object.def(function () {
      return {};
    }),
    prefixCls: vue_types.string.def('rc-trigger-popup'),
    popupClassName: vue_types.string.def(''),
    popupPlacement: vue_types.string,
    builtinPlacements: vue_types.object,
    popupTransitionName: vue_types.oneOfType([vue_types.string, vue_types.object]),
    popupAnimation: vue_types.any,
    mouseEnterDelay: vue_types.number.def(0),
    mouseLeaveDelay: vue_types.number.def(0.1),
    zIndex: vue_types.number,
    focusDelay: vue_types.number.def(0),
    blurDelay: vue_types.number.def(0.15),
    getPopupContainer: vue_types.func,
    getDocument: vue_types.func.def(function () {
      return returnDocument;
    }),
    forceRender: vue_types.bool,
    destroyPopupOnHide: vue_types.bool.def(false),
    mask: vue_types.bool.def(false),
    maskClosable: vue_types.bool.def(true),
    // onPopupAlign: PropTypes.func.def(noop),
    popupAlign: vue_types.object.def(function () {
      return {};
    }),
    popupVisible: vue_types.bool,
    defaultPopupVisible: vue_types.bool.def(false),
    maskTransitionName: vue_types.oneOfType([vue_types.string, vue_types.object]),
    maskAnimation: vue_types.string,
    stretch: vue_types.string,
    alignPoint: vue_types.bool // Maybe we can support user pass position in the future

  },
  setup: function setup(props, _ref) {
    var _this = this;

    var emit = _ref.emit;
    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var vcTriggerContext = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('vcTriggerContext') || {};
    var savePopupRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('savePopupRef') || vc_trigger_utils_noop;
    var point = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var eventHandlers = {};

    var _useLocalValue = value_useLocalValue(props.defaultPopupVisible, 'popupVisible'),
        popupVisible = _useLocalValue.value;

    ALL_HANDLERS.forEach(function (h) {
      eventHandlers["fire".concat(h)] = function (e) {
        fireEvents(h, e);
      };
    });
    var prevPopupVisible = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(popupVisible);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return popupVisible.value;
    }, function (val) {
      if (val !== undefined) {
        prevPopupVisible.value = popupVisible.value;
      }
    });
    var renderComponent = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        var _a;

        (_a = renderComponent.value) === null || _a === void 0 ? void 0 : _a.call(renderComponent, null);
        updatedCal();
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      var triggerAfterPopupVisibleChange = function triggerAfterPopupVisibleChange() {
        if (popupVisible.value !== prevPopupVisible.value) {
          props.afterPopupVisibleChange(popupVisible.value);
        }
      };

      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        var _a;

        (_a = renderComponent.value) === null || _a === void 0 ? void 0 : _a.call(renderComponent, null, triggerAfterPopupVisibleChange);
        updatedCal();
      });
    });
    var contextmenuOutsideHandler1 = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var contextmenuOutsideHandler2 = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var mouseDownTimeout = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var clickOutsideHandler = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var touchOutsideHandler = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var updatedCal = function updatedCal() {
      // We must listen to `mousedown` or `touchstart`, edge case:
      // https://github.com/ant-design/ant-design/issues/5804
      // https://github.com/react-component/calendar/issues/250
      // https://github.com/react-component/trigger/issues/50
      if (popupVisible.value) {
        var currentDocument;

        if (!clickOutsideHandler.value && (isClickToHide() || isContextmenuToShow())) {
          currentDocument = props.getDocument();
          clickOutsideHandler.value = addEventListenerWrap(currentDocument, 'mousedown', onDocumentClick);
        } // always hide on mobile


        if (!touchOutsideHandler.value) {
          currentDocument = currentDocument || props.getDocument();
          touchOutsideHandler.value = addEventListenerWrap(currentDocument, 'touchstart', onDocumentClick);
        } // close popup when trigger type contains 'onContextmenu' and document is scrolling.


        if (!contextmenuOutsideHandler1.value && isContextmenuToShow()) {
          currentDocument = currentDocument || props.getDocument();
          contextmenuOutsideHandler1.value = addEventListenerWrap(currentDocument, 'scroll', onContextmenuClose);
        } // close popup when trigger type contains 'onContextmenu' and window is blur.


        if (!contextmenuOutsideHandler2.value && isContextmenuToShow()) {
          contextmenuOutsideHandler2.value = addEventListenerWrap(window, 'blur', onContextmenuClose);
        }
      } else {
        clearOutsideHandler();
      }
    };

    var childOriginEvents = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])({});

    var onMouseenter = function onMouseenter(e) {
      var mouseEnterDelay = props.mouseEnterDelay;
      fireEvents('mouseenter', e);
      delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e);
    };

    var fireEvents = function fireEvents(type, e) {
      if (childOriginEvents.value[type]) {
        childOriginEvents.value[type](e);
      }

      emit(type, e);
    };

    var onMouseMove = function onMouseMove(e) {
      fireEvents('mousemove', e);
      setPoint(e);
    };

    var onMouseleave = function onMouseleave(e) {
      fireEvents('mouseleave', e);
      delaySetPopupVisible(false, props.mouseLeaveDelay);
    };

    var focusTime = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);

    var onFocus = function onFocus(e) {
      fireEvents('focus', e); // incase focusin and focusout

      clearDelayTimer();

      if (isFocusToShow()) {
        focusTime.value = Date.now();
        delaySetPopupVisible(true, props.focusDelay);
      }
    };

    var onPopupMouseenter = function onPopupMouseenter() {
      clearDelayTimer();
    };

    var _component = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var onPopupMouseleave = function onPopupMouseleave(e) {
      if (e && e.relatedTarget && !e.relatedTarget.setTimeout && _component.value && _component.value.getPopupDomNode && contains(_component.value.getPopupDomNode(), e.relatedTarget)) {
        return;
      }

      delaySetPopupVisible(false, props.mouseLeaveDelay);
    };

    var onMousedown = function onMousedown(e) {
      fireEvents('mousedown', e);
      preClickTime.value = Date.now();
    };

    var onTouchstart = function onTouchstart(e) {
      fireEvents('touchstart', e);
      preTouchTime.value = Date.now();
    };

    var onBlur = function onBlur(e) {
      if (!contains(e.target, e.relatedTarget || document.activeElement)) {
        fireEvents('blur', e);
        clearDelayTimer();

        if (isBlurToHide()) {
          delaySetPopupVisible(false, props.blurDelay);
        }
      }
    };

    var onContextmenu = function onContextmenu(e) {
      e.preventDefault();
      fireEvents('contextmenu', e);
      setPopupVisible(true, e);
    };

    var onContextmenuClose = function onContextmenuClose(event) {
      if (isContextmenuToShow()) {
        close(event);
      }
    };

    var preClickTime = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
    var preTouchTime = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);

    var onClick = function onClick(event) {
      fireEvents('click', event); // focus will trigger click

      if (focusTime.value) {
        var preTime;

        if (preClickTime.value && preTouchTime.value) {
          preTime = Math.min(preClickTime.value, preTouchTime.value);
        } else if (preClickTime.value) {
          preTime = preClickTime.value;
        } else if (preTouchTime.value) {
          preTime = preTouchTime.value;
        }

        if (Math.abs(preTime - focusTime.value) < 20) {
          return;
        }

        focusTime.value = 0;
      }

      preClickTime.value = 0;
      preTouchTime.value = 0; // Only prevent default when all the action is click.
      // https://github.com/ant-design/ant-design/issues/17043
      // https://github.com/ant-design/ant-design/issues/17291

      if (isClickToShow() && (isClickToHide() || isBlurToHide()) && event && event.preventDefault) {
        event.preventDefault();
      }

      if (event && event.domEvent) {
        event.domEvent.preventDefault();
      }

      var nextVisible = !popupVisible.value;

      if (isClickToHide() && !nextVisible || nextVisible && isClickToShow()) {
        setPopupVisible(!popupVisible.value, event);
      }
    };

    var hasPopupMouseDown = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);

    var onPopupMouseDown = function onPopupMouseDown() {
      hasPopupMouseDown.value = true;
      clearTimeout(mouseDownTimeout.value);
      mouseDownTimeout.value = setTimeout(function () {
        hasPopupMouseDown.value = false;
      }, 0);

      if (vcTriggerContext.onPopupMouseDown) {
        vcTriggerContext.onPopupMouseDown.apply(vcTriggerContext, arguments);
      }
    };

    var onDocumentClick = function onDocumentClick(event) {
      if (props.mask && !props.maskClosable) {
        return;
      }

      var target = event.target;
      var root = trigger.value.el;

      if (!contains(root, target) && !hasPopupMouseDown.value) {
        close(event);
      }
    };

    var getRootDomNode = function getRootDomNode() {
      return trigger.value.el;
    };

    var handleGetPopupClassFromAlign = function handleGetPopupClassFromAlign(align) {
      var className = [];
      var popupPlacement = props.popupPlacement,
          builtinPlacements = props.builtinPlacements,
          prefixCls = props.prefixCls,
          alignPoint = props.alignPoint,
          getPopupClassNameFromAlign = props.getPopupClassNameFromAlign;

      if (popupPlacement && builtinPlacements) {
        className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint));
      }

      if (getPopupClassNameFromAlign) {
        className.push(getPopupClassNameFromAlign(align));
      }

      return className.join(' ');
    };

    var getPopupAlign = function getPopupAlign() {
      var popupPlacement = props.popupPlacement,
          popupAlign = props.popupAlign,
          builtinPlacements = props.builtinPlacements;

      if (popupPlacement && builtinPlacements) {
        return utils_getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
      }

      return popupAlign;
    };

    var savePopup = function savePopup(node) {
      _component.value = node;
      savePopupRef(node);
    };

    var getComponent = function getComponent() {
      var mouseProps = {};

      if (isMouseEnterToShow()) {
        mouseProps.onMouseenter = onPopupMouseenter;
      }

      if (isMouseLeaveToHide()) {
        mouseProps.onMouseleave = onPopupMouseleave;
      }

      mouseProps.onMousedown = onPopupMouseDown;
      mouseProps.onTouchstart = onPopupMouseDown;
      var prefixCls = props.prefixCls,
          destroyPopupOnHide = props.destroyPopupOnHide,
          popupClassName = props.popupClassName,
          action = props.action,
          popupAnimation = props.popupAnimation,
          popupTransitionName = props.popupTransitionName,
          popupStyle = props.popupStyle,
          mask = props.mask,
          maskAnimation = props.maskAnimation,
          maskTransitionName = props.maskTransitionName,
          zIndex = props.zIndex,
          stretch = props.stretch,
          alignPoint = props.alignPoint;
      var align = getPopupAlign();
      var popupProps = Object.assign(Object.assign({
        prefixCls: prefixCls,
        destroyPopupOnHide: destroyPopupOnHide,
        visible: popupVisible.value,
        point: alignPoint && point,
        action: action,
        align: align,
        animation: popupAnimation,
        getClassNameFromAlign: handleGetPopupClassFromAlign,
        stretch: stretch,
        getRootDomNode: getRootDomNode,
        mask: mask,
        zIndex: zIndex,
        transitionName: popupTransitionName,
        maskAnimation: maskAnimation,
        maskTransitionName: maskTransitionName,
        popupClassName: popupClassName,
        popupStyle: popupStyle,
        onAlign: getListenersFromInstance(currentInstance).popupAlign || vc_trigger_utils_noop
      }, mouseProps), {
        ref: savePopup
      });
      var popupContent = props_util_getComponentFromProp(currentInstance, 'popup');
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(popup, trigger_objectSpread({}, popupProps), [popupContent]);
    };

    var setPopupVisible = function setPopupVisible(visible, event) {
      var alignPoint = props.alignPoint;
      clearDelayTimer();

      if (prevPopupVisible.value !== visible) {
        if (props.popupVisible === undefined) {
          popupVisible.value = visible;
          prevPopupVisible.value = visible;
        }

        emit('popupVisibleChange', visible, event);
      } // Always record the point position since mouseEnterDelay will delay the show


      if (alignPoint && event) {
        setPoint(event);
      }
    };

    var setPoint = function setPoint(point) {
      var alignPoint = props.alignPoint;

      if (!alignPoint || !point) {
        return;
      }

      point.value = {
        pageX: point.pageX,
        pageY: point.pageY
      };
    };

    var delayTimer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var delaySetPopupVisible = function delaySetPopupVisible(visible, delayS, event) {
      var delay = delayS * 1000;
      clearDelayTimer();

      if (delay) {
        var _point = event ? {
          pageX: event.pageX,
          pageY: event.pageY
        } : null;

        delayTimer.value = requestAnimationTimeout(function () {
          setPopupVisible(visible, _point);
          clearDelayTimer();
        }, delay);
      } else {
        setPopupVisible(visible, event);
      }
    };

    var clearDelayTimer = function clearDelayTimer() {
      if (delayTimer.value) {
        request_animation_timeout_cancelAnimationTimeout(delayTimer.value);
        delayTimer.value = null;
      }
    };

    var clearOutsideHandler = function clearOutsideHandler() {
      if (clickOutsideHandler.value) {
        clickOutsideHandler.value.remove();
        clickOutsideHandler.value = null;
      }

      if (contextmenuOutsideHandler1.value) {
        contextmenuOutsideHandler1.value.remove();
        contextmenuOutsideHandler1.value = null;
      }

      if (contextmenuOutsideHandler2.value) {
        contextmenuOutsideHandler2.value.remove();
        contextmenuOutsideHandler2.value = null;
      }

      if (touchOutsideHandler.value) {
        touchOutsideHandler.value.remove();
        touchOutsideHandler.value = null;
      }
    };

    var createTwoChains = function createTwoChains(event) {
      var fn = function fn() {};

      var events = getListenersFromInstance(currentInstance);

      if (childOriginEvents.value[event] && events[event]) {
        return _this["fire".concat(event)];
      }

      fn = childOriginEvents.value[event] || events[event] || fn;
      return fn;
    };

    var isClickToShow = function isClickToShow() {
      var action = props.action,
          showAction = props.showAction;
      return action.indexOf('click') !== -1 || showAction.indexOf('click') !== -1;
    };

    var isContextmenuToShow = function isContextmenuToShow() {
      var action = props.action,
          showAction = props.showAction;
      return action.indexOf('contextmenu') !== -1 || showAction.indexOf('contextmenu') !== -1;
    };

    var isClickToHide = function isClickToHide() {
      var action = props.action,
          hideAction = props.hideAction;
      return action.indexOf('click') !== -1 || hideAction.indexOf('click') !== -1;
    };

    var isMouseEnterToShow = function isMouseEnterToShow() {
      var action = props.action,
          showAction = props.showAction;
      return action.indexOf('hover') !== -1 || showAction.indexOf('mouseenter') !== -1;
    };

    var isMouseLeaveToHide = function isMouseLeaveToHide() {
      var action = props.action,
          hideAction = props.hideAction;
      return action.indexOf('hover') !== -1 || hideAction.indexOf('mouseleave') !== -1;
    };

    var isFocusToShow = function isFocusToShow() {
      var action = props.action,
          showAction = props.showAction;
      return action.indexOf('focus') !== -1 || showAction.indexOf('focus') !== -1;
    };

    var isBlurToHide = function isBlurToHide() {
      var action = props.action,
          hideAction = props.hideAction;
      return action.indexOf('focus') !== -1 || hideAction.indexOf('blur') !== -1;
    };

    var forcePopupAlign = function forcePopupAlign() {
      if (popupVisible.value && _component.value && _component.value.$refs.alignInstance) {
        _component.value.$refs.alignInstance.forceAlign();
      }
    };

    var close = function close(event) {
      event.stopPropagation();
      setPopupVisible(false, event);
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      clearDelayTimer();
      clearOutsideHandler();
      clearTimeout(mouseDownTimeout.value);
    });
    var trigger = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var setTrigger = function setTrigger(el) {
      trigger.value = el;
    };

    var setRenderComponent = function setRenderComponent(renderComponent) {
      renderComponent.value = renderComponent;
    };

    var getTrigger = function getTrigger() {
      return trigger.value;
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])('vcTriggerContext', currentInstance);
    return {
      prevPopupVisible: prevPopupVisible,
      popupVisible: popupVisible,
      point: point,
      forcePopupAlign: forcePopupAlign,
      isClickToHide: isClickToHide,
      isContextmenuToShow: isContextmenuToShow,
      isClickToShow: isClickToShow,
      isMouseLeaveToHide: isMouseLeaveToHide,
      onClick: onClick,
      onMousedown: onMousedown,
      onTouchstart: onTouchstart,
      createTwoChains: createTwoChains,
      isMouseEnterToShow: isMouseEnterToShow,
      onMouseenter: onMouseenter,
      onMouseMove: onMouseMove,
      onMouseleave: onMouseleave,
      getComponent: getComponent,
      isFocusToShow: isFocusToShow,
      isBlurToHide: isBlurToHide,
      onFocus: onFocus,
      onBlur: onBlur,
      onContextmenu: onContextmenu,
      setRenderComponent: setRenderComponent,
      onPopupMouseDown: onPopupMouseDown,
      childOriginEvents: childOriginEvents,
      getRootDomNode: getRootDomNode,
      setTrigger: setTrigger,
      getTrigger: getTrigger,
      setChildOriginEvents: function setChildOriginEvents(val) {
        childOriginEvents.value = val;
      }
    };
  },
  render: function render(ctx) {
    var _this2 = this;

    var children = filterEmpty(this.$slots["default"]);
    var alignPoint = this.$props.alignPoint;

    if (children.length > 1) {
      _util_warning(false, 'trigger', 'Trigger $slots.default.length > 1, just support only one default');
    }

    var child = children[0];
    this.setChildOriginEvents(getListenersFromVNode(child));
    var newChildProps = {
      key: 'trigger'
    };

    if (this.isContextmenuToShow()) {
      newChildProps.onContextmenu = this.onContextmenu;
    } else {
      newChildProps.onContextmenu = this.createTwoChains('onContextmenu');
    }

    if (this.isClickToHide() || this.isClickToShow()) {
      newChildProps.onClick = this.onClick;
      newChildProps.onMousedown = this.onMousedown;
      newChildProps.onTouchstart = this.onTouchstart;
    } else {
      newChildProps.onClick = this.createTwoChains('onClick');
      newChildProps.onMousedown = this.createTwoChains('onMousedown');
      newChildProps.onTouchstart = this.createTwoChains('onTouchstart');
    }

    if (this.isMouseEnterToShow()) {
      newChildProps.onMouseenter = this.onMouseenter;

      if (alignPoint) {
        newChildProps.onMousemove = this.onMouseMove;
      }
    } else {
      newChildProps.onMouseenter = this.createTwoChains('onMouseenter');
    }

    if (this.isMouseLeaveToHide()) {
      newChildProps.onMouseleave = this.onMouseleave;
    } else {
      newChildProps.onMouseleave = this.createTwoChains('onMouseleave');
    }

    if (this.isFocusToShow() || this.isBlurToHide()) {
      newChildProps.onFocus = this.onFocus;
      newChildProps.onBlur = this.onBlur;
    } else {
      newChildProps.onFocus = this.createTwoChains('onFocus');

      newChildProps.onBlur = function (e) {
        if (e && (!e.relatedTarget || !contains(e.target, e.relatedTarget))) {
          _this2.createTwoChains('onBlur')(e);
        }
      };
    }

    var style = {
      position: 'absolute',
      top: '0',
      left: '0',
      width: '100%'
    };
    this.setTrigger(cloneElement(child, newChildProps));
    return [this.getTrigger(), // @ts-ignore
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Teleport"], {
      "to": "body"
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "style": style
    }, [this.getComponent()])])];
  }
}));
// CONCATENATED MODULE: ./src/components/vc-trigger/index.ts

// based on rc-trigger 2.6.5

/* harmony default export */ var vc_trigger = (vc_trigger_trigger);
// CONCATENATED MODULE: ./src/components/vc-cascader/menus.tsx


function menus_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function menus_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { menus_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { menus_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






/* harmony default export */ var vc_cascader_menus = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'CascaderMenus',
  props: {
    value: vue_types.array.def([]),
    activeValue: vue_types.array.def([]),
    options: vue_types.array,
    prefixCls: vue_types.string.def('rc-cascader-menus'),
    expandTrigger: vue_types.string.def('click'),
    // onSelect: PropTypes.func,
    visible: vue_types.bool.def(false),
    dropdownMenuColumnStyle: vue_types.object,
    defaultFieldNames: vue_types.object,
    fieldNames: vue_types.object,
    expandIcon: vue_types.any,
    loadingIcon: vue_types.any
  },
  setup: function setup($props, _ref) {
    var _this = this;

    var emit = _ref.emit,
        slots = _ref.slots;
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $props.visible;
    }, function (val) {
      if (val) {
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
          scrollActiveItemToView();
        });
      }
    });

    var getFieldName = function getFieldName(name) {
      var fieldNames = $props.fieldNames,
          defaultFieldNames = $props.defaultFieldNames; // 防止只设置单个属性的名字

      return fieldNames[name] || defaultFieldNames[name];
    };

    var getOption = function getOption(option, menuIndex) {
      var prefixCls = $props.prefixCls,
          expandTrigger = $props.expandTrigger;
      var loadingIcon = getComponentFromContext({
        $props: $props,
        $slots: slots
      }, 'loadingIcon');
      var expandIcon = getComponentFromContext({
        $props: $props,
        $slots: slots
      }, 'expandIcon');

      var onSelect = function onSelect(e) {
        emit('select', option, menuIndex, e);
      };

      var onItemDoubleClick = function onItemDoubleClick(e) {
        emit('itemDoubleClick', option, menuIndex, e);
      };

      var key = option[getFieldName('value')];
      var expandProps = {
        role: 'menuitem',
        onClick: onSelect,
        onDblclick: onItemDoubleClick,
        onMousedown: function onMousedown(e) {
          return e.preventDefault();
        },
        key: Array.isArray(key) ? key.join('__ant__') : key
      };
      var menuItemCls = "".concat(prefixCls, "-menu-item");
      var expandIconNode = null;
      var hasChildren = option[getFieldName('children')] && option[getFieldName('children')].length > 0;

      if (hasChildren || option.isLeaf === false) {
        menuItemCls += " ".concat(prefixCls, "-menu-item-expand");

        if (!option.loading) {
          expandIconNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
            "class": "".concat(prefixCls, "-menu-item-expand-icon")
          }, [expandIcon]);
        }
      }

      if (expandTrigger === 'hover' && (hasChildren || option.isLeaf === false)) {
        Object.assign(expandProps, {
          onMouseenter: delayOnSelect.bind(_this, onSelect),
          onMouseleave: delayOnSelect.bind(_this),
          onClick: onSelect
        });
      }

      if (isActiveOption(option, menuIndex)) {
        menuItemCls += " ".concat(prefixCls, "-menu-item-active");
        expandProps.ref = saveRef(getMenuItemRef(menuIndex));
      }

      if (option.disabled) {
        menuItemCls += " ".concat(prefixCls, "-menu-item-disabled");
      }

      var loadingIconNode = null;

      if (option.loading) {
        menuItemCls += " ".concat(prefixCls, "-menu-item-loading");
        loadingIconNode = loadingIcon || null;
      }

      var title = '';

      if (option.title) {
        title = option.title;
      } else if (typeof option[getFieldName('label')] === 'string') {
        title = option[getFieldName('label')];
      }

      expandProps.title = title;
      expandProps["class"] = menuItemCls;
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", menus_objectSpread({}, expandProps), [option[getFieldName('label')], expandIconNode, loadingIconNode]);
    };

    var getActiveOptions = function getActiveOptions(values) {
      var activeValue = values || $props.activeValue;
      var options = $props.options;
      return array_tree_filter_lib_default()(options, function (o, level) {
        return o[getFieldName('value')] === activeValue[level];
      }, {
        childrenKeyName: getFieldName('children')
      });
    };

    var getShowOptions = function getShowOptions() {
      var options = $props.options;
      var result = getActiveOptions().map(function (activeOption) {
        return activeOption[getFieldName('children')];
      }).filter(function (activeOption) {
        return !!activeOption;
      });
      result.unshift(options);
      return result;
    };

    var delayTimer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var delayOnSelect = function delayOnSelect(onSelect) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (delayTimer.value) {
        clearTimeout(delayTimer.value);
        delayTimer.value = null;
      }

      if (typeof onSelect === 'function') {
        delayTimer.value = setTimeout(function () {
          onSelect(args);
          delayTimer.value = null;
        }, 150);
      }
    };

    var _useRefs = save_ref_useRefs(),
        getRef = _useRefs.getRef,
        saveRef = _useRefs.saveRef;

    var scrollActiveItemToView = function scrollActiveItemToView() {
      // scroll into view
      var optionsLength = getShowOptions().length;

      for (var i = 0; i < optionsLength; i++) {
        var itemComponent = getRef("menuItems_".concat(i));

        if (itemComponent) {
          var target = itemComponent;
          target.parentNode.scrollTop = target.offsetTop;
        }
      }
    };

    var isActiveOption = function isActiveOption(option, menuIndex) {
      var _$props$activeValue = $props.activeValue,
          activeValue = _$props$activeValue === void 0 ? [] : _$props$activeValue;
      return activeValue[menuIndex] === option[getFieldName('value')];
    };

    var getMenuItemRef = function getMenuItemRef(index) {
      return "menuItems_".concat(index);
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        scrollActiveItemToView();
      });
    });
    return {
      getFieldName: getFieldName,
      getOption: getOption,
      getActiveOptions: getActiveOptions,
      getShowOptions: getShowOptions,
      delayOnSelect: delayOnSelect,
      scrollActiveItemToView: scrollActiveItemToView,
      isActiveOption: isActiveOption,
      getMenuItemRef: getMenuItemRef,
      saveRef: saveRef
    };
  },
  render: function render() {
    var _this2 = this;

    var prefixCls = this.prefixCls,
        dropdownMenuColumnStyle = this.dropdownMenuColumnStyle;
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {}, [this.getShowOptions().map(function (options, menuIndex) {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("ul", {
        "class": "".concat(prefixCls, "-menu"),
        "key": menuIndex,
        "style": dropdownMenuColumnStyle
      }, [options.map(function (option) {
        return _this2.getOption(option, menuIndex);
      })]);
    })]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-cascader/cascader.tsx



function cascader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function cascader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { cascader_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { cascader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }













var BUILT_IN_PLACEMENTS = {
  bottomLeft: {
    points: ['tl', 'bl'],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ['bl', 'tl'],
    offset: [0, -4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomRight: {
    points: ['tr', 'br'],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topRight: {
    points: ['br', 'tr'],
    offset: [0, -4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  }
};
/* harmony default export */ var cascader = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  model: {
    prop: 'value',
    event: 'change'
  },
  props: {
    value: vue_types.array,
    defaultValue: vue_types.array,
    options: vue_types.array,
    // onChange: PropTypes.func,
    // onPopupVisibleChange: PropTypes.func,
    popupVisible: vue_types.bool,
    disabled: vue_types.bool.def(false),
    transitionName: vue_types.string.def(''),
    popupClassName: vue_types.string.def(''),
    popupStyle: vue_types.object.def(function () {
      return {};
    }),
    popupPlacement: vue_types.string.def('bottomLeft'),
    prefixCls: vue_types.string.def('rc-cascader'),
    dropdownMenuColumnStyle: vue_types.object,
    builtinPlacements: vue_types.object.def(BUILT_IN_PLACEMENTS),
    loadData: vue_types.func,
    changeOnSelect: vue_types.bool,
    // onKeyDown: PropTypes.func,
    expandTrigger: vue_types.string.def('click'),
    fieldNames: vue_types.object.def(function () {
      return {
        label: 'label',
        value: 'value',
        children: 'children'
      };
    }),
    expandIcon: vue_types.any,
    loadingIcon: vue_types.any,
    getPopupContainer: vue_types.func
  },
  setup: function setup($props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;

    var getInitState = function getInitState() {
      var initialValue = [];
      var value = $props.value,
          defaultValue = $props.defaultValue,
          popupVisible = $props.popupVisible;

      if ($props.value !== undefined) {
        initialValue = value || [];
      } else if ($props.defaultValue !== undefined) {
        initialValue = defaultValue || [];
      } // warning(!('filedNames' in props),
      //   '`filedNames` of Cascader is a typo usage and deprecated, please use `fieldNames` instead.');


      return {
        sPopupVisible: popupVisible,
        sActiveValue: initialValue,
        sValue: initialValue
      };
    };

    var _useState = state_useState(getInitState()),
        $state = _useState.state,
        setState = _useState.setState;

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $props.value;
    }, function (val, oldValue) {
      if (!arrays_default()(val, oldValue)) {
        var newValues = {
          sValue: val || []
        }; // allow activeValue diff from value
        // https://github.com/ant-design/ant-design/issues/2767

        if ($props.loadData === undefined) {
          newValues.sActiveValue = val || [];
        }

        setState(newValues);
      }
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $props.popupVisible;
    }, function (val) {
      setState({
        sPopupVisible: val
      });
    });

    var _useRefs = save_ref_useRefs(),
        getRef = _useRefs.getRef,
        saveRef = _useRefs.saveRef;

    var getPopupDOMNode = function getPopupDOMNode() {
      return getRef('trigger').getPopupDomNode();
    };

    var defaultFieldNames = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var getFieldName = function getFieldName(name) {
      var fieldNames = $props.fieldNames;
      return fieldNames[name] || defaultFieldNames.value[name];
    };

    var getFieldNames = function getFieldNames() {
      return $props.fieldNames;
    };

    var getCurrentLevelOptions = function getCurrentLevelOptions() {
      var _$props$options = $props.options,
          options = _$props$options === void 0 ? [] : _$props$options;
      var _$state$sActiveValue = $state.sActiveValue,
          sActiveValue = _$state$sActiveValue === void 0 ? [] : _$state$sActiveValue;
      var result = array_tree_filter_lib_default()(options, function (o, level) {
        return o[getFieldName('value')] === sActiveValue[level];
      }, {
        childrenKeyName: getFieldName('children')
      });

      if (result[result.length - 2]) {
        return result[result.length - 2][getFieldName('children')];
      }

      return toConsumableArray_default()(options).filter(function (o) {
        return !o.disabled;
      });
    };

    var getActiveOptions = function getActiveOptions(activeValue) {
      return array_tree_filter_lib_default()($props.options || [], function (o, level) {
        return o[getFieldName('value')] === activeValue[level];
      }, {
        childrenKeyName: getFieldName('children')
      });
    };

    var setPopupVisible = function setPopupVisible(popupVisible) {
      if ($props.popupVisible === undefined) {
        setState({
          sPopupVisible: popupVisible
        });
      } // sync activeValue with value when panel open


      if (popupVisible && !$state.sPopupVisible) {
        setState({
          sActiveValue: $state.sValue
        });
      }

      emit('popupVisibleChange', popupVisible);
    };

    var handleChange = function handleChange(options, setProps, e) {
      if (e.type !== 'keydown' || e.keyCode === keycode.ENTER) {
        emit('change', options.map(function (o) {
          return o[getFieldName('value')];
        }), options);
        setPopupVisible(setProps.visible);
      }
    };

    var handlePopupVisibleChange = function handlePopupVisibleChange(popupVisible) {
      setPopupVisible(popupVisible);
    };

    var handleMenuSelect = function handleMenuSelect(targetOption, menuIndex, e) {
      // Keep focused state for keyboard support
      var triggerNode = getRef('trigger').getRootDomNode();

      if (triggerNode && triggerNode.focus) {
        triggerNode.focus();
      }

      var changeOnSelect = $props.changeOnSelect,
          loadData = $props.loadData,
          expandTrigger = $props.expandTrigger;

      if (!targetOption || targetOption.disabled) {
        return;
      }

      var sActiveValue = $state.sActiveValue;
      sActiveValue = sActiveValue.slice(0, menuIndex + 1);
      sActiveValue[menuIndex] = targetOption[getFieldName('value')];
      var activeOptions = getActiveOptions(sActiveValue);

      if (targetOption.isLeaf === false && !targetOption[getFieldName('children')] && loadData) {
        if (changeOnSelect) {
          handleChange(activeOptions, {
            visible: true
          }, e);
        }

        setState({
          sActiveValue: sActiveValue
        });
        loadData(activeOptions);
        return;
      }

      var newState = {};

      if (!targetOption[getFieldName('children')] || !targetOption[getFieldName('children')].length) {
        handleChange(activeOptions, {
          visible: false
        }, e); // set value to activeValue when select leaf option

        newState.sValue = sActiveValue; // add e.type judgement to prevent `onChange` being triggered by mouseEnter
      } else if (changeOnSelect && (e.type === 'click' || e.type === 'keydown')) {
        if (expandTrigger === 'hover') {
          handleChange(activeOptions, {
            visible: false
          }, e);
        } else {
          handleChange(activeOptions, {
            visible: true
          }, e);
        } // set value to activeValue on every select


        newState.sValue = sActiveValue;
      }

      newState.sActiveValue = sActiveValue; //  not change the value by keyboard

      if ($props.value !== undefined || e.type === 'keydown' && e.keyCode !== keycode.ENTER) {
        delete newState.sValue;
      }

      setState(newState);
    };

    var handleItemDoubleClick = function handleItemDoubleClick() {
      var changeOnSelect = $props.changeOnSelect;

      if (changeOnSelect) {
        setPopupVisible(false);
      }
    };

    var handleKeyDown = function handleKeyDown(e) {
      var children = slots["default"] && slots["default"]()[0]; // https://github.com/ant-design/ant-design/issues/6717
      // Don't bind keyboard support when children specify the onKeyDown

      if (children) {
        var keydown = getListenersFromVNode(children).keydown;

        if (keydown) {
          keydown(e);
          return;
        }
      }

      var activeValue = toConsumableArray_default()($state.sActiveValue);

      var currentLevel = activeValue.length - 1 < 0 ? 0 : activeValue.length - 1;
      var currentOptions = getCurrentLevelOptions();
      var currentIndex = currentOptions.map(function (o) {
        return o[getFieldName('value')];
      }).indexOf(activeValue[currentLevel]);

      if (e.keyCode !== keycode.DOWN && e.keyCode !== keycode.UP && e.keyCode !== keycode.LEFT && e.keyCode !== keycode.RIGHT && e.keyCode !== keycode.ENTER && e.keyCode !== keycode.SPACE && e.keyCode !== keycode.BACKSPACE && e.keyCode !== keycode.ESC && e.keyCode !== keycode.TAB) {
        return;
      } // Press any keys above to reopen menu


      if (!$state.sPopupVisible && e.keyCode !== keycode.BACKSPACE && e.keyCode !== keycode.LEFT && e.keyCode !== keycode.RIGHT && e.keyCode !== keycode.ESC && e.keyCode !== keycode.TAB) {
        setPopupVisible(true);
        return;
      }

      if (e.key === KeyName.Down || e.key === KeyName.Up) {
        e.preventDefault();
        var nextIndex = currentIndex;

        if (nextIndex === -1) {
          nextIndex = 0;
        } else {
          if (e.key === KeyName.Down) {
            nextIndex += 1;
            nextIndex = nextIndex >= currentOptions.length ? 0 : nextIndex;
          } else {
            nextIndex -= 1;
            nextIndex = nextIndex < 0 ? currentOptions.length - 1 : nextIndex;
          }
        }

        activeValue[currentLevel] = currentOptions[nextIndex][getFieldName('value')];
      } else if (e.key === KeyName.Left || e.keyCode === keycode.BACKSPACE) {
        e.preventDefault();
        activeValue.splice(activeValue.length - 1, 1);
      } else if (e.key === KeyName.Right) {
        e.preventDefault();

        if (currentOptions[currentIndex] && currentOptions[currentIndex][getFieldName('children')]) {
          activeValue.push(currentOptions[currentIndex][getFieldName('children')][0][getFieldName('value')]);
        }
      } else if (e.keyCode === keycode.ESC || e.keyCode === keycode.TAB) {
        setPopupVisible(false);
        return;
      }

      if (!activeValue || activeValue.length === 0) {
        setPopupVisible(false);
      }

      var activeOptions = getActiveOptions(activeValue);
      var targetOption = activeOptions[activeOptions.length - 1];
      handleMenuSelect(targetOption, activeOptions.length - 1, e);
      emit('keydown', e);
    };

    return {
      getPopupDOMNode: getPopupDOMNode,
      getFieldName: getFieldName,
      defaultFieldNames: defaultFieldNames,
      getFieldNames: getFieldNames,
      getCurrentLevelOptions: getCurrentLevelOptions,
      getActiveOptions: getActiveOptions,
      setState: setState,
      setPopupVisible: setPopupVisible,
      saveRef: saveRef,
      handleChange: handleChange,
      handlePopupVisibleChange: handlePopupVisibleChange,
      handleMenuSelect: handleMenuSelect,
      handleItemDoubleClick: handleItemDoubleClick,
      handleKeyDown: handleKeyDown,
      $state: $state
    };
  },
  render: function render() {
    var $props = this.$props,
        handleMenuSelect = this.handleMenuSelect,
        handlePopupVisibleChange = this.handlePopupVisibleChange,
        handleKeyDown = this.handleKeyDown;
    var _this$$state = this.$state,
        sActiveValue = _this$$state.sActiveValue,
        sPopupVisible = _this$$state.sPopupVisible;
    var listeners = getListenersFromContext(this);

    var prefixCls = $props.prefixCls,
        transitionName = $props.transitionName,
        popupClassName = $props.popupClassName,
        _$props$options2 = $props.options,
        options = _$props$options2 === void 0 ? [] : _$props$options2,
        disabled = $props.disabled,
        builtinPlacements = $props.builtinPlacements,
        popupPlacement = $props.popupPlacement,
        restProps = __rest($props, ["prefixCls", "transitionName", "popupClassName", "options", "disabled", "builtinPlacements", "popupPlacement"]); // Did not show popup when there is no options


    var menus = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {}, []);
    var emptyMenuClassName = '';

    if (options && options.length > 0) {
      var loadingIcon = getComponentFromContext(this, 'loadingIcon');
      var expandIcon = getComponentFromContext(this, 'expandIcon') || '>';
      var menusProps = Object.assign(Object.assign(Object.assign(Object.assign({}, $props), {
        fieldNames: this.getFieldNames(),
        defaultFieldNames: this.defaultFieldNames,
        activeValue: sActiveValue,
        visible: sPopupVisible,
        loadingIcon: loadingIcon,
        expandIcon: expandIcon
      }), listeners), {
        onSelect: handleMenuSelect,
        onItemDoubleClick: this.handleItemDoubleClick
      });
      menus = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_cascader_menus, cascader_objectSpread({}, menusProps), []);
    } else {
      emptyMenuClassName = " ".concat(prefixCls, "-menus-empty");
    }

    var triggerProps = Object.assign(Object.assign(Object.assign(Object.assign({}, restProps), {
      disabled: disabled,
      popupPlacement: popupPlacement,
      builtinPlacements: builtinPlacements,
      popupTransitionName: transitionName,
      action: disabled ? [] : ['click'],
      popupVisible: disabled ? false : sPopupVisible,
      prefixCls: "".concat(prefixCls, "-menus"),
      popupClassName: popupClassName + emptyMenuClassName
    }), listeners), {
      onPopupVisibleChange: handlePopupVisibleChange,
      ref: this.saveRef('trigger')
    });
    var children = this.$slots["default"] && this.$slots["default"]()[0];
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_trigger, cascader_objectSpread({}, triggerProps), {
      "popup": [menus],
      "default": [children && cloneElement(children, {
        onKeydown: handleKeyDown,
        tabIndex: disabled ? undefined : 0
      })]
    });
  }
}));
// CONCATENATED MODULE: ./src/components/vc-cascader/index.tsx

// based on rc-cascader 0.17.4

/* harmony default export */ var vc_cascader = (cascader);
// CONCATENATED MODULE: ./src/components/cascader/index.tsx


function components_cascader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function components_cascader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { components_cascader_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { components_cascader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }


















var CascaderOptionType = vue_types.shape({
  value: vue_types.oneOfType([vue_types.string, vue_types.number]),
  label: vue_types.any,
  disabled: vue_types.bool,
  children: vue_types.array,
  key: vue_types.oneOfType([vue_types.string, vue_types.number])
}).loose;
var FieldNamesType = vue_types.shape({
  value: vue_types.string.isRequired,
  label: vue_types.string.isRequired,
  children: vue_types.string
}).loose;
var CascaderExpandTrigger = vue_types.oneOf(['click', 'hover']);
var ShowSearchType = vue_types.shape({
  filter: vue_types.func,
  render: vue_types.func,
  sort: vue_types.func,
  matchInputWidth: vue_types.bool,
  limit: vue_types.oneOfType([Boolean, Number])
}).loose;

function cascader_noop() {}

var CascaderProps = {
  /** 可选项数据源 */
  options: vue_types.arrayOf(CascaderOptionType).def([]),

  /** 默认的选中项 */
  defaultValue: vue_types.array,

  /** 指定选中项 */
  value: vue_types.array,

  /** 选择完成后的回调 */
  // onChange?: (value: string[], selectedOptions?: CascaderOptionType[]) => void;

  /** 选择后展示的渲染函数 */
  displayRender: vue_types.func,
  transitionName: vue_types.string.def('slide-up'),
  popupStyle: vue_types.object.def(function () {
    return {};
  }),

  /** 自定义浮层类名 */
  popupClassName: vue_types.string,

  /** 浮层预设位置：`bottomLeft` `bottomRight` `topLeft` `topRight` */
  popupPlacement: vue_types.oneOf(['bottomLeft', 'bottomRight', 'topLeft', 'topRight']).def('bottomLeft'),

  /** 输入框占位文本*/
  placeholder: vue_types.string.def('Please select'),

  /** 输入框大小，可选 `large` `default` `small` */
  size: vue_types.oneOf(['large', 'default', 'small']),

  /** 禁用*/
  disabled: vue_types.bool.def(false),

  /** 是否支持清除*/
  allowClear: vue_types.bool.def(true),
  showSearch: vue_types.oneOfType([Boolean, ShowSearchType]),
  notFoundContent: vue_types.any,
  loadData: vue_types.func,

  /** 次级菜单的展开方式，可选 'click' 和 'hover' */
  expandTrigger: CascaderExpandTrigger,

  /** 当此项为 true 时，点选每级菜单选项值都会发生变化 */
  changeOnSelect: vue_types.bool,

  /** 浮层可见变化时回调 */
  // onPopupVisibleChange?: (popupVisible: boolean) => void;
  prefixCls: vue_types.string,
  inputPrefixCls: vue_types.string,
  getPopupContainer: vue_types.func,
  popupVisible: vue_types.bool,
  fieldNames: FieldNamesType,
  autoFocus: vue_types.bool,
  suffixIcon: vue_types.any
}; // We limit the filtered item count by default

var defaultLimit = 50;

function defaultFilterOption(inputValue, path, names) {
  return path.some(function (option) {
    return option[names.label].indexOf(inputValue) > -1;
  });
}

function defaultSortFilteredOption(a, b, inputValue, names) {
  function callback(elem) {
    return elem[names.label].indexOf(inputValue) > -1;
  }

  return a.findIndex(callback) - b.findIndex(callback);
}

function getFilledFieldNames(_ref) {
  var _ref$fieldNames = _ref.fieldNames,
      fieldNames = _ref$fieldNames === void 0 ? {} : _ref$fieldNames;
  return {
    children: fieldNames.children || 'children',
    label: fieldNames.label || 'label',
    value: fieldNames.value || 'value'
  };
}

function flattenTree() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var props = arguments.length > 1 ? arguments[1] : undefined;
  var ancestor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var names = getFilledFieldNames(props);
  var flattenOptions = [];
  var childrenName = names.children;
  options.forEach(function (option) {
    var path = ancestor.concat(option);

    if (props.changeOnSelect || !option[childrenName] || !option[childrenName].length) {
      flattenOptions.push(path);
    }

    if (option[childrenName]) {
      flattenOptions = flattenOptions.concat(flattenTree(option[childrenName], props, path));
    }
  });
  return flattenOptions;
}

var defaultDisplayRender = function defaultDisplayRender(_ref2) {
  var labels = _ref2.labels;
  return labels.join(' / ');
};

var Cascader = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  inheritAttrs: false,
  name: 'ACascader',
  props: CascaderProps,
  setup: function setup($props, _ref3) {
    var emit = _ref3.emit,
        slots = _ref3.slots;
    var cachedOptions = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])([]);

    var _useState = state_useState(function () {
      var value = $props.value,
          defaultValue = $props.defaultValue,
          popupVisible = $props.popupVisible,
          showSearch = $props.showSearch,
          options = $props.options;
      return {
        sValue: value || defaultValue || [],
        inputValue: '',
        inputFocused: false,
        sPopupVisible: popupVisible,
        flattenOptions: showSearch ? flattenTree(options, $props) : undefined
      };
    }),
        $state = _useState.state,
        setState = _useState.setState;

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $props.value;
    }, function (val) {
      setState({
        sValue: val || []
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $props.popupVisible;
    }, function (val) {
      setState({
        sPopupVisible: val
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $props.options;
    }, function (val) {
      if ($props.showSearch) {
        setState({
          flattenOptions: flattenTree(val, $props)
        });
      }
    });

    var highlightKeyword = function highlightKeyword(str, keyword, prefixCls) {
      return str.split(keyword).map(function (node, index) {
        return index === 0 ? node : [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
          "class": "".concat(prefixCls, "-menu-item-keyword")
        }, [keyword]), node];
      });
    };

    var defaultRenderFilteredOption = function defaultRenderFilteredOption(_ref4) {
      var inputValue = _ref4.inputValue,
          path = _ref4.path,
          prefixCls = _ref4.prefixCls,
          names = _ref4.names;
      return path.map(function (option, index) {
        var label = option[names.label];
        var node = label.indexOf(inputValue) > -1 ? highlightKeyword(label, inputValue, prefixCls) : label;
        return index === 0 ? node : [' / ', node];
      });
    };

    var handleChange = function handleChange(value, selectedOptions) {
      setState({
        inputValue: ''
      });

      if (selectedOptions[0].__IS_FILTERED_OPTION) {
        var unwrappedValue = value[0];
        var unwrappedSelectedOptions = selectedOptions[0].path;
        setValue(unwrappedValue, unwrappedSelectedOptions);
        return;
      }

      setValue(value, selectedOptions);
    };

    var handlePopupVisibleChange = function handlePopupVisibleChange(popupVisible) {
      if (popupVisible === undefined) {
        setState(function (state) {
          return {
            sPopupVisible: popupVisible,
            inputFocused: popupVisible,
            inputValue: popupVisible ? state.inputValue : ''
          };
        });
      }

      emit('popupVisibleChange', popupVisible);
    };

    var handleInputFocus = function handleInputFocus(e) {
      emit('focus', e);
    };

    var handleInputBlur = function handleInputBlur(e) {
      setState({
        inputFocused: false
      });
      emit('blur', e);
    };

    var handleInputClick = function handleInputClick(e) {
      var inputFocused = $state.inputFocused,
          sPopupVisible = $state.sPopupVisible; // Prevent `Trigger` behaviour.

      if (inputFocused || sPopupVisible) {
        e.stopPropagation();

        if (e.nativeEvent && e.nativeEvent.stopImmediatePropagation) {
          e.nativeEvent.stopImmediatePropagation();
        }
      }
    };

    var handleKeyDown = function handleKeyDown(e) {
      if (e.keyCode === keycode.BACKSPACE || e.keyCode === keycode.SPACE) {
        e.stopPropagation();
      }
    };

    var handleInputChange = function handleInputChange(e) {
      var inputValue = e.target.value;
      setState({
        inputValue: inputValue
      });
      emit('search', inputValue);
    };

    var setValue = function setValue(value, selectedOptions) {
      if (value !== undefined) {
        setState({
          sValue: value
        });
      }

      emit('change', value, selectedOptions);
    };

    var getLabel = function getLabel() {
      var options = $props.options;
      var names = getFilledFieldNames($props);
      var displayRender = getComponentFromContext({
        $props: $props,
        $slots: slots
      }, 'displayRender') || defaultDisplayRender;
      var value = $state.sValue;
      var unwrappedValue = Array.isArray(value[0]) ? value[0] : value;
      var selectedOptions = array_tree_filter_lib_default()(options, function (o, level) {
        return o[names.value] === unwrappedValue[level];
      }, {
        childrenKeyName: names.children
      });
      var labels = selectedOptions.map(function (o) {
        return o[names.label];
      });
      return displayRender({
        labels: labels,
        selectedOptions: selectedOptions
      });
    };

    var clearSelection = function clearSelection(e) {
      e.preventDefault();
      e.stopPropagation();

      if ($state.inputValue) {
        setState({
          inputValue: ''
        });
      } else {
        setValue([]);
        handlePopupVisibleChange(false);
      }
    };

    var generateFilteredOptions = function generateFilteredOptions(prefixCls, renderEmpty) {
      var _ref6;

      var showSearch = $props.showSearch,
          notFoundContent = $props.notFoundContent;
      var names = getFilledFieldNames($props);
      var _showSearch$filter = showSearch.filter,
          filter = _showSearch$filter === void 0 ? defaultFilterOption : _showSearch$filter,
          _showSearch$sort = showSearch.sort,
          sort = _showSearch$sort === void 0 ? defaultSortFilteredOption : _showSearch$sort,
          _showSearch$limit = showSearch.limit,
          limit = _showSearch$limit === void 0 ? defaultLimit : _showSearch$limit;
      var render = showSearch.render || slots.showSearchRender || defaultRenderFilteredOption;
      var _$state$flattenOption = $state.flattenOptions,
          flattenOptions = _$state$flattenOption === void 0 ? [] : _$state$flattenOption,
          inputValue = $state.inputValue; // Limit the filter if needed

      var filtered;

      if (limit > 0) {
        filtered = [];
        var matchCount = 0; // Perf optimization to filter items only below the limit

        flattenOptions.some(function (path) {
          var match = filter(inputValue, path, names);

          if (match) {
            filtered.push(path);
            matchCount += 1;
          }

          return matchCount >= limit;
        });
      } else {
        _util_warning(typeof limit !== 'number', 'Cascader', '\'limit\' of showSearch in Cascader should be positive number or false.');
        filtered = flattenOptions.filter(function (path) {
          return filter(inputValue, path, names);
        });
      }

      filtered.sort(function (a, b) {
        return sort(a, b, inputValue, names);
      });

      if (filtered.length > 0) {
        return filtered.map(function (path) {
          var _ref5;

          return _ref5 = {
            __IS_FILTERED_OPTION: true,
            path: path
          }, defineProperty_default()(_ref5, names.label, render({
            inputValue: inputValue,
            path: path,
            prefixCls: prefixCls,
            names: names
          })), defineProperty_default()(_ref5, names.value, path.map(function (o) {
            return o[names.value];
          })), defineProperty_default()(_ref5, "disabled", path.some(function (o) {
            return !!o.disabled;
          })), _ref5;
        });
      }

      return [(_ref6 = {}, defineProperty_default()(_ref6, names.label, notFoundContent || renderEmpty('Cascader')), defineProperty_default()(_ref6, names.value, 'ANT_CASCADER_NOT_FOUND'), defineProperty_default()(_ref6, "disabled", true), _ref6)];
    };

    var _useRefs = save_ref_useRefs(),
        getRef = _useRefs.getRef,
        saveRef = _useRefs.saveRef;

    var focus = function focus() {
      if ($props.showSearch) {
        getRef('input').focus();
      } else {
        getRef('picker').focus();
      }
    };

    var blur = function blur() {
      if ($props.showSearch) {
        getRef('input').blur();
      } else {
        getRef('picker').blur();
      }
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        if ($props.autoFocus && !$props.showSearch && !$props.disabled) {
          getRef('picker').focus();
        }
      });
    });
    var localeData = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('localeData', {});
    return {
      localeData: localeData,
      highlightKeyword: highlightKeyword,
      defaultRenderFilteredOption: defaultRenderFilteredOption,
      handleChange: handleChange,
      setState: setState,
      handlePopupVisibleChange: handlePopupVisibleChange,
      handleInputFocus: handleInputFocus,
      handleInputBlur: handleInputBlur,
      handleInputClick: handleInputClick,
      handleKeyDown: handleKeyDown,
      handleInputChange: handleInputChange,
      setValue: setValue,
      getLabel: getLabel,
      clearSelection: clearSelection,
      generateFilteredOptions: generateFilteredOptions,
      focus: focus,
      blur: blur,
      $state: $state,
      saveRef: saveRef,
      getRef: getRef,
      setCachedOptions: function setCachedOptions(value) {
        cachedOptions.value = value;
      },
      configProvider: config_provider_useConfigProvider()
    };
  },
  render: function render() {
    var _classNames, _classNames2, _classNames3;

    var _this$$state = this.$state,
        sPopupVisible = _this$$state.sPopupVisible,
        inputValue = _this$$state.inputValue;
    var $slots = this.$slots,
        configProvider = this.configProvider,
        localeData = this.localeData;
    var _this$$state2 = this.$state,
        value = _this$$state2.sValue,
        inputFocused = _this$$state2.inputFocused;
    var props = this.$props;
    var suffixIcon = getComponentFromContext(this, 'suffixIcon');
    suffixIcon = Array.isArray(suffixIcon) ? suffixIcon[0] : suffixIcon;
    var getContextPopupContainer = configProvider.getPopupContainer;

    var customizePrefixCls = props.prefixCls,
        customizeInputPrefixCls = props.inputPrefixCls,
        _props$placeholder = props.placeholder,
        placeholder = _props$placeholder === void 0 ? localeData.placeholder : _props$placeholder,
        size = props.size,
        disabled = props.disabled,
        allowClear = props.allowClear,
        _props$showSearch = props.showSearch,
        showSearch = _props$showSearch === void 0 ? false : _props$showSearch,
        notFoundContent = props.notFoundContent,
        otherProps = __rest(props, ["prefixCls", "inputPrefixCls", "placeholder", "size", "disabled", "allowClear", "showSearch", "notFoundContent"]);

    var getPrefixCls = config_provider_useConfigProvider().getPrefixCls;
    var renderEmpty = config_provider_useConfigProvider().renderEmpty;
    var prefixCls = getPrefixCls('cascader', customizePrefixCls);
    var inputPrefixCls = getPrefixCls('input', customizeInputPrefixCls);
    var sizeCls = classnames_default()((_classNames = {}, defineProperty_default()(_classNames, "".concat(inputPrefixCls, "-lg"), size === 'large'), defineProperty_default()(_classNames, "".concat(inputPrefixCls, "-sm"), size === 'small'), _classNames));
    var clearIcon = allowClear && !disabled && value.length > 0 || inputValue ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
      "type": "close-circle",
      "theme": "filled",
      "class": "".concat(prefixCls, "-picker-clear"),
      "onClick": this.clearSelection,
      "key": "clear-icon"
    }, []) : null;
    var arrowCls = classnames_default()((_classNames2 = {}, defineProperty_default()(_classNames2, "".concat(prefixCls, "-picker-arrow"), true), defineProperty_default()(_classNames2, "".concat(prefixCls, "-picker-arrow-expand"), sPopupVisible), _classNames2));
    var pickerCls = classnames_default()(getClassFromContext(this), "".concat(prefixCls, "-picker"), (_classNames3 = {}, defineProperty_default()(_classNames3, "".concat(prefixCls, "-picker-with-value"), inputValue), defineProperty_default()(_classNames3, "".concat(prefixCls, "-picker-disabled"), disabled), defineProperty_default()(_classNames3, "".concat(prefixCls, "-picker-").concat(size), !!size), defineProperty_default()(_classNames3, "".concat(prefixCls, "-picker-show-search"), !!showSearch), defineProperty_default()(_classNames3, "".concat(prefixCls, "-picker-focused"), inputFocused), _classNames3)); // Fix bug of https://github.com/facebook/react/pull/5004
    // and https://fb.me/react-unknown-prop

    var tempInputProps = es(otherProps, ['options', 'popupPlacement', 'transitionName', 'displayRender', 'changeOnSelect', 'expandTrigger', 'popupVisible', 'getPopupContainer', 'loadData', 'popupClassName', 'defaultValue', 'fieldNames']);
    var options = props.options;
    var names = getFilledFieldNames(this.$props);

    if (options && options.length > 0) {
      if (inputValue) {
        options = this.generateFilteredOptions(prefixCls, renderEmpty);
      }
    } else {
      var _ref7;

      options = [(_ref7 = {}, defineProperty_default()(_ref7, names.label, notFoundContent || renderEmpty('Cascader')), defineProperty_default()(_ref7, names.value, 'ANT_CASCADER_NOT_FOUND'), defineProperty_default()(_ref7, "disabled", true), _ref7)];
    } // Dropdown menu should keep previous status until it is fully closed.


    if (sPopupVisible) {
      this.setCachedOptions(options);
    } else {// todo
      // options = this.cachedOptions;
    }

    var dropdownMenuColumnStyle = {};
    var isNotFound = (options || []).length === 1 && options[0].value === 'ANT_CASCADER_NOT_FOUND';

    if (isNotFound) {
      dropdownMenuColumnStyle.height = 'auto'; // Height of one row.
    } // The default value of `matchInputWidth` is `true`


    var resultListMatchInputWidth = showSearch.matchInputWidth !== false;

    if (resultListMatchInputWidth && (inputValue || isNotFound) && this.$refs.input) {
      dropdownMenuColumnStyle.width = this.getRef('input').vnode.el.offsetWidth + 'px';
    } // showSearch时，focus、blur在input上触发，反之在ref='picker'上触发


    var inputProps = Object.assign(Object.assign(Object.assign({}, tempInputProps), {
      prefixCls: inputPrefixCls,
      placeholder: value && value.length > 0 ? undefined : placeholder,
      value: inputValue,
      disabled: disabled,
      readOnly: !showSearch,
      autoComplete: 'off',
      "class": "".concat(prefixCls, "-input ").concat(sizeCls),
      ref: this.saveRef('input'),
      onFocus: showSearch ? this.handleInputFocus : cascader_noop,
      onClick: showSearch ? this.handleInputClick : cascader_noop,
      onBlur: showSearch ? this.handleInputBlur : cascader_noop,
      onKeydown: this.handleKeyDown,
      onChange: showSearch ? this.handleInputChange : cascader_noop
    }), this.$attrs);
    var children = filterEmpty($slots["default"]);
    var inputIcon = suffixIcon && (isValidElement(suffixIcon) ? cloneElement(suffixIcon, {
      "class": defineProperty_default()({}, "".concat(prefixCls, "-picker-arrow"), true)
    }) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-picker-arrow")
    }, [suffixIcon])) || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
      "type": "down",
      "class": arrowCls
    }, []);
    var input = children.length ? children : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": pickerCls,
      "style": getStyleFromContext(this),
      "ref": this.saveRef('picker')
    }, [showSearch ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-picker-label")
    }, [this.getLabel()]) : null, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_input, components_cascader_objectSpread({}, inputProps), []), !showSearch ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-picker-label")
    }, [this.getLabel()]) : null, clearIcon, inputIcon]);
    var expandIcon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
      "type": "right"
    }, []);
    var loadingIcon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-menu-item-loading-icon")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
      "type": "redo",
      "spin": true
    }, [])]);
    var getPopupContainer = props.getPopupContainer || getContextPopupContainer;
    var cascaderProps = Object.assign(Object.assign(Object.assign(Object.assign({}, props), {
      getPopupContainer: getPopupContainer,
      options: options,
      prefixCls: prefixCls,
      value: value,
      popupVisible: sPopupVisible,
      dropdownMenuColumnStyle: dropdownMenuColumnStyle,
      expandIcon: expandIcon,
      loadingIcon: loadingIcon
    }), getListenersFromContext(this)), {
      onPopupVisibleChange: this.handlePopupVisibleChange,
      onChange: this.handleChange
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_cascader, components_cascader_objectSpread({}, cascaderProps), [input]);
  }
});
/* istanbul ignore next */

Cascader.install = function (Vue) {
  Vue.use(base);
  Vue.component(Cascader.name, Cascader);
};

/* harmony default export */ var components_cascader = (Cascader);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/mixin/common-mixin.tsx

var common_mixin_useCommonMixin = function useCommonMixin(props) {
  var focusElement = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
  var rootInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
  return {
    focusElement: focusElement,
    rootInstance: rootInstance,
    setRootInstance: function setRootInstance(el) {
      rootInstance.value = el;
    },
    getFormat: function getFormat() {
      var format = props.format;
      var locale = props.locale,
          timePicker = props.timePicker;

      if (!format) {
        if (timePicker) {
          format = locale.dateTimeFormat;
        } else {
          format = locale.dateFormat;
        }
      }

      return format;
    },
    focus: function focus() {
      if (focusElement.value) {
        focusElement.value.focus();
      } else if (rootInstance.value) {
        rootInstance.value.focus();
      }
    },
    saveFocusElement: function saveFocusElement(ele) {
      focusElement.value = ele;
    }
  };
};
// CONCATENATED MODULE: ./src/components/vc-calendar/src/util/index.ts


var defaultDisabledTime = {
  disabledHours: function disabledHours() {
    return [];
  },
  disabledMinutes: function disabledMinutes() {
    return [];
  },
  disabledSeconds: function disabledSeconds() {
    return [];
  }
};
function getTodayTime(value) {
  var today = moment_default()();
  today.locale(value.locale()).utcOffset(value.utcOffset());
  return today;
}
function getTitleString(value) {
  return value.format('LL');
}
function getTodayTimeStr(value) {
  var today = getTodayTime(value);
  return getTitleString(today);
}
function getMonthName(month) {
  var locale = month.locale();
  var localeData = month.localeData();
  return localeData[locale === 'zh-cn' ? 'months' : 'monthsShort'](month);
}
function syncTime(from, to) {
  if (!moment_default.a.isMoment(from) || !moment_default.a.isMoment(to)) {
    return;
  }

  to.hour(from.hour());
  to.minute(from.minute());
  to.second(from.second());
  to.millisecond(from.millisecond());
}
function getTimeConfig(value, disabledTime) {
  var disabledTimeConfig = disabledTime ? disabledTime(value) : {};
  disabledTimeConfig = Object.assign(Object.assign({}, defaultDisabledTime), disabledTimeConfig);
  return disabledTimeConfig;
}
function isTimeValidByConfig(value, disabledTimeConfig) {
  var invalidTime = false;

  if (value) {
    var hour = value.hour();
    var minutes = value.minute();
    var seconds = value.second();
    var disabledHours = disabledTimeConfig.disabledHours();

    if (disabledHours.indexOf(hour) === -1) {
      var disabledMinutes = disabledTimeConfig.disabledMinutes(hour);

      if (disabledMinutes.indexOf(minutes) === -1) {
        var disabledSeconds = disabledTimeConfig.disabledSeconds(hour, minutes);
        invalidTime = disabledSeconds.indexOf(seconds) !== -1;
      } else {
        invalidTime = true;
      }
    } else {
      invalidTime = true;
    }
  }

  return !invalidTime;
}
function isTimeValid(value, disabledTime) {
  var disabledTimeConfig = getTimeConfig(value, disabledTime);
  return isTimeValidByConfig(value, disabledTimeConfig);
}
function util_isAllowedDate(value, disabledDate, disabledTime) {
  if (disabledDate) {
    if (disabledDate(value)) {
      return false;
    }
  }

  if (disabledTime) {
    if (!isTimeValid(value, disabledTime)) {
      return false;
    }
  }

  return true;
}
function formatDate(value, format) {
  if (!value) {
    return '';
  }

  var copyFormat = format;

  if (Array.isArray(copyFormat)) {
    copyFormat = copyFormat[0];
  }

  return value.format(copyFormat);
}
// CONCATENATED MODULE: ./src/components/vc-calendar/src/date/date-constants.ts

/* harmony default export */ var date_constants = ({
  DATE_ROW_COUNT: 6,
  DATE_COL_COUNT: 7
});
// CONCATENATED MODULE: ./src/components/vc-calendar/src/date/date-tbody.tsx








function date_tbody_noop() {}

function isSameDay(one, two) {
  return one && two && one.isSame(two, 'day');
}

function beforeCurrentMonthYear(current, today) {
  if (current.year() < today.year()) {
    return 1;
  }

  return current.year() === today.year() && current.month() < today.month();
}

function afterCurrentMonthYear(current, today) {
  if (current.year() > today.year()) {
    return 1;
  }

  return current.year() === today.year() && current.month() > today.month();
}

function getIdFromDate(date) {
  return "rc-calendar-".concat(date.year(), "-").concat(date.month(), "-").concat(date.date());
}

var DateTBody = {
  props: {
    contentRender: vue_types.func,
    dateRender: vue_types.func,
    disabledDate: vue_types.func,
    prefixCls: vue_types.string,
    selectedValue: vue_types.oneOfType([vue_types.any, vue_types.arrayOf(vue_types.any)]),
    value: vue_types.object,
    hoverValue: vue_types.any.def([]),
    showWeekNumber: vue_types.bool
  },
  render: function render() {
    var props = Object.assign(Object.assign({}, this.$props), this.$attrs);
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var contentRender = props.contentRender,
        prefixCls = props.prefixCls,
        selectedValue = props.selectedValue,
        value = props.value,
        showWeekNumber = props.showWeekNumber,
        dateRender = props.dateRender,
        disabledDate = props.disabledDate,
        hoverValue = props.hoverValue;

    var _getListenersFromInst = getListenersFromInstance(instance),
        _getListenersFromInst2 = _getListenersFromInst.onSelect,
        onSelect = _getListenersFromInst2 === void 0 ? date_tbody_noop : _getListenersFromInst2,
        _getListenersFromInst3 = _getListenersFromInst.onDayHover,
        onDayHover = _getListenersFromInst3 === void 0 ? date_tbody_noop : _getListenersFromInst3;

    var iIndex;
    var jIndex;
    var current;
    var dateTable = [];
    var today = getTodayTime(value);
    var cellClass = "".concat(prefixCls, "-cell");
    var weekNumberCellClass = "".concat(prefixCls, "-week-number-cell");
    var dateClass = "".concat(prefixCls, "-date");
    var todayClass = "".concat(prefixCls, "-today");
    var selectedClass = "".concat(prefixCls, "-selected-day");
    var selectedDateClass = "".concat(prefixCls, "-selected-date"); // do not move with mouse operation

    var selectedStartDateClass = "".concat(prefixCls, "-selected-start-date");
    var selectedEndDateClass = "".concat(prefixCls, "-selected-end-date");
    var inRangeClass = "".concat(prefixCls, "-in-range-cell");
    var lastMonthDayClass = "".concat(prefixCls, "-last-month-cell");
    var nextMonthDayClass = "".concat(prefixCls, "-next-month-btn-day");
    var disabledClass = "".concat(prefixCls, "-disabled-cell");
    var firstDisableClass = "".concat(prefixCls, "-disabled-cell-first-of-row");
    var lastDisableClass = "".concat(prefixCls, "-disabled-cell-last-of-row");
    var lastDayOfMonthClass = "".concat(prefixCls, "-last-day-of-month");
    var month1 = value.clone();
    month1.date(1);
    var day = month1.day();
    var lastMonthDiffDay = (day + 7 - value.localeData().firstDayOfWeek()) % 7; // calculate last month

    var lastMonth1 = month1.clone();
    lastMonth1.add(0 - lastMonthDiffDay, 'days');
    var passed = 0;

    for (iIndex = 0; iIndex < date_constants.DATE_ROW_COUNT; iIndex++) {
      for (jIndex = 0; jIndex < date_constants.DATE_COL_COUNT; jIndex++) {
        current = lastMonth1;

        if (passed) {
          current = current.clone();
          current.add(passed, 'days');
        }

        dateTable.push(current);
        passed++;
      }
    }

    var tableHtml = [];
    passed = 0;

    for (iIndex = 0; iIndex < date_constants.DATE_ROW_COUNT; iIndex++) {
      var _cx;

      var isCurrentWeek = void 0;
      var weekNumberCell = void 0;
      var isActiveWeek = false;
      var dateCells = [];

      if (showWeekNumber) {
        weekNumberCell = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("td", {
          "key": "week-".concat(dateTable[passed].week()),
          "role": "gridcell",
          "class": weekNumberCellClass
        }, [dateTable[passed].week()]);
      }

      for (jIndex = 0; jIndex < date_constants.DATE_COL_COUNT; jIndex++) {
        var next = null;
        var last = null;
        current = dateTable[passed];

        if (jIndex < date_constants.DATE_COL_COUNT - 1) {
          next = dateTable[passed + 1];
        }

        if (jIndex > 0) {
          last = dateTable[passed - 1];
        }

        var cls = cellClass;
        var disabled = false;
        var selected = false;

        if (isSameDay(current, today)) {
          cls += " ".concat(todayClass);
          isCurrentWeek = true;
        }

        var isBeforeCurrentMonthYear = beforeCurrentMonthYear(current, value);
        var isAfterCurrentMonthYear = afterCurrentMonthYear(current, value);

        if (selectedValue && Array.isArray(selectedValue)) {
          var rangeValue = hoverValue.length ? hoverValue : selectedValue;

          if (!isBeforeCurrentMonthYear && !isAfterCurrentMonthYear) {
            var startValue = rangeValue[0];
            var endValue = rangeValue[1];

            if (startValue) {
              if (isSameDay(current, startValue)) {
                selected = true;
                isActiveWeek = true;
                cls += " ".concat(selectedStartDateClass);
              }
            }

            if (startValue || endValue) {
              if (isSameDay(current, endValue)) {
                selected = true;
                isActiveWeek = true;
                cls += " ".concat(selectedEndDateClass);
              } else if ((startValue === null || startValue === undefined) && current.isBefore(endValue, 'day')) {
                cls += " ".concat(inRangeClass);
              } else if ((endValue === null || endValue === undefined) && current.isAfter(startValue, 'day')) {
                cls += " ".concat(inRangeClass);
              } else if (current.isAfter(startValue, 'day') && current.isBefore(endValue, 'day')) {
                cls += " ".concat(inRangeClass);
              }
            }
          }
        } else if (isSameDay(current, value)) {
          // keyboard change value, highlight works
          selected = true;
          isActiveWeek = true;
        }

        if (isSameDay(current, selectedValue)) {
          cls += " ".concat(selectedDateClass);
        }

        if (isBeforeCurrentMonthYear) {
          cls += " ".concat(lastMonthDayClass);
        }

        if (isAfterCurrentMonthYear) {
          cls += " ".concat(nextMonthDayClass);
        }

        if (current.clone().endOf('month').date() === current.date()) {
          cls += " ".concat(lastDayOfMonthClass);
        }

        if (disabledDate) {
          if (disabledDate(current, value)) {
            disabled = true;

            if (!last || !disabledDate(last, value)) {
              cls += " ".concat(firstDisableClass);
            }

            if (!next || !disabledDate(next, value)) {
              cls += " ".concat(lastDisableClass);
            }
          }
        }

        if (selected) {
          cls += " ".concat(selectedClass);
        }

        if (disabled) {
          cls += " ".concat(disabledClass);
        }

        var dateHtml = void 0;

        if (dateRender) {
          dateHtml = dateRender(current, value);
        } else {
          var content = contentRender ? contentRender(current, value) : current.date();
          dateHtml = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
            "key": getIdFromDate(current),
            "class": dateClass,
            "aria-selected": selected,
            "aria-disabled": disabled
          }, [content]);
        }

        dateCells.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("td", {
          "key": passed,
          "onClick": disabled ? date_tbody_noop : onSelect.bind(null, current),
          "onMouseenter": disabled ? date_tbody_noop : onDayHover.bind(null, current),
          "role": "gridcell",
          "title": getTitleString(current),
          "class": cls
        }, [dateHtml]));
        passed++;
      }

      tableHtml.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("tr", {
        "key": iIndex,
        "role": "row",
        "class": classnames_default()((_cx = {}, defineProperty_default()(_cx, "".concat(prefixCls, "-current-week"), isCurrentWeek), defineProperty_default()(_cx, "".concat(prefixCls, "-active-week"), isActiveWeek), _cx))
      }, [weekNumberCell, dateCells]));
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("tbody", {
      "class": "".concat(prefixCls, "-tbody")
    }, [tableHtml]);
  }
};
/* harmony default export */ var date_tbody = (DateTBody);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/date/date-thead.tsx



/* harmony default export */ var date_thead = ({
  functional: true,
  render: function render() {
    var props = Object.assign(Object.assign({}, this.$props), this.$attrs);
    var value = props.value;
    var localeData = value.localeData();
    var prefixCls = props.prefixCls;
    var veryShortWeekdays = [];
    var weekDays = [];
    var firstDayOfWeek = localeData.firstDayOfWeek();
    var showWeekNumberEl;
    var now = moment_default()();

    for (var dateColIndex = 0; dateColIndex < date_constants.DATE_COL_COUNT; dateColIndex++) {
      var index = (firstDayOfWeek + dateColIndex) % date_constants.DATE_COL_COUNT;
      now.day(index);
      veryShortWeekdays[dateColIndex] = localeData.weekdaysMin(now);
      weekDays[dateColIndex] = localeData.weekdaysShort(now);
    }

    if (props.showWeekNumber) {
      showWeekNumberEl = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("th", {
        "role": "columnheader",
        "class": "".concat(prefixCls, "-column-header ").concat(prefixCls, "-week-number-header")
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-column-header-inner")
      }, ["x"])]);
    }

    var weekDaysEls = weekDays.map(function (day, xindex) {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("th", {
        "key": xindex,
        "role": "columnheader",
        "title": day,
        "class": "".concat(prefixCls, "-column-header")
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-column-header-inner")
      }, [veryShortWeekdays[xindex]])]);
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("thead", {}, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("tr", {
      "role": "row"
    }, [showWeekNumberEl, weekDaysEls])]);
  }
});
// CONCATENATED MODULE: ./src/components/vc-calendar/src/date/date-table.tsx


function date_table_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function date_table_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { date_table_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { date_table_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }





/* harmony default export */ var date_table = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  functional: true,
  name: 'DateTable',
  render: function render() {
    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var props = Object.assign(Object.assign({}, this.$props), this.$attrs);
    var listeners = getListenersFromInstance(currentInstance);
    var prefixCls = props.prefixCls;
    var bodyProps = Object.assign(Object.assign({}, props), listeners);
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("table", {
      "class": "".concat(prefixCls, "-table"),
      "cellspacing": "0",
      "role": "grid"
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(date_thead, date_table_objectSpread({}, bodyProps), []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(date_tbody, date_table_objectSpread({}, bodyProps), [])]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-calendar/src/full-calendar/calendar-header.tsx



var CalendarHeader = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: {
    value: vue_types.object,
    locale: vue_types.object,
    yearSelectOffset: vue_types.number.def(10),
    yearSelectTotal: vue_types.number.def(20),
    // onValueChange: PropTypes.func,
    // onTypeChange: PropTypes.func,
    Select: vue_types.object,
    prefixCls: vue_types.string,
    type: vue_types.string,
    showTypeSwitch: vue_types.bool,
    headerComponents: vue_types.array
  },
  setup: function setup($props, _ref) {
    var emit = _ref.emit;

    var onYearChange = function onYearChange(year) {
      var newValue = $props.value.clone();
      newValue.year(parseInt(year, 10));
      emit('valueChange', newValue);
    };

    var onMonthChange = function onMonthChange(month) {
      var newValue = $props.value.clone();
      newValue.month(parseInt(month, 10));
      emit('valueChange', newValue);
    };

    var yearSelectElement = function yearSelectElement(year) {
      var yearSelectOffset = $props.yearSelectOffset,
          yearSelectTotal = $props.yearSelectTotal,
          prefixCls = $props.prefixCls,
          Select = $props.Select;
      var start = year - yearSelectOffset;
      var end = start + yearSelectTotal;
      var SelectOption = Select.Option;
      var options = [];

      for (var index = start; index < end; index++) {
        options.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(SelectOption, {
          "value": "".concat(index)
        }, [index]));
      }

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Select, {
        "class": "".concat(prefixCls, "-header-year-select"),
        "onChange": onYearChange,
        "dropdownStyle": {
          zIndex: 2000
        },
        "dropdownMenuStyle": {
          maxHeight: '250px',
          overflow: 'auto',
          fontSize: '12px'
        },
        "optionLabelProp": "children",
        "value": String(year),
        "showSearch": false
      }, [options]);
    };

    var monthSelectElement = function monthSelectElement(month) {
      var value = $props.value,
          Select = $props.Select,
          prefixCls = $props.prefixCls;
      var t = value.clone();
      var options = [];
      var SelectOption = Select.Option;

      for (var index = 0; index < 12; index++) {
        t.month(index);
        options.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(SelectOption, {
          "value": "".concat(index)
        }, [getMonthName(t)]));
      }

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Select, {
        "class": "".concat(prefixCls, "-header-month-select"),
        "dropdownStyle": {
          zIndex: 2000
        },
        "dropdownMenuStyle": {
          maxHeight: '250px',
          overflow: 'auto',
          overflowX: 'hidden',
          fontSize: '12px'
        },
        "optionLabelProp": "children",
        "value": String(month),
        "showSearch": false,
        "onChange": onMonthChange
      }, [options]);
    };

    var changeTypeToDate = function changeTypeToDate() {
      emit('typeChange', 'date');
    };

    var changeTypeToMonth = function changeTypeToMonth() {
      emit('typeChange', 'month');
    };

    return {
      onYearChange: onYearChange,
      onMonthChange: onMonthChange,
      yearSelectElement: yearSelectElement,
      monthSelectElement: monthSelectElement,
      changeTypeToDate: changeTypeToDate,
      changeTypeToMonth: changeTypeToMonth
    };
  },
  render: function render() {
    var value = this.value,
        locale = this.locale,
        prefixCls = this.prefixCls,
        type = this.type,
        showTypeSwitch = this.showTypeSwitch,
        headerComponents = this.headerComponents;
    var year = value.year();
    var month = value.month();
    var yearSelect = this.yearSelectElement(year);
    var monthSelect = type === 'month' ? null : this.monthSelectElement(month);
    var switchCls = "".concat(prefixCls, "-header-switcher");
    var typeSwitcher = showTypeSwitch ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": switchCls
    }, [type === 'date' ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(switchCls, "-focus")
    }, [locale.month]) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "onClick": this.changeTypeToDate,
      "class": "".concat(switchCls, "-normal")
    }, [locale.month]), type === 'month' ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(switchCls, "-focus")
    }, [locale.year]) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "onClick": this.changeTypeToMonth,
      "class": "".concat(switchCls, "-normal")
    }, [locale.year])]) : null;
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-header")
    }, [typeSwitcher, monthSelect, yearSelect, headerComponents]);
  }
});
/* harmony default export */ var calendar_header = (CalendarHeader);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/mixin/calendar-mixin.tsx







function calendar_mixin_noop() {}

function getNowByCurrentStateValue(value) {
  var ret;

  if (value) {
    ret = getTodayTime(value);
  } else {
    ret = moment_default()();
  }

  return ret;
}

function isMoment(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || value.findIndex(function (val) {
      return val === undefined || moment_default.a.isMoment(val);
    }) !== -1;
  } else {
    return value === undefined || moment_default.a.isMoment(value);
  }
}

var calendar_mixin_useCalendarMixin = function useCalendarMixin(props, emit, _ref) {
  var onKeyDown = _ref.onKeyDown,
      onBlur = _ref.onBlur;

  var _useLocalValue = value_useLocalValue(props.defaultValue || getNowByCurrentStateValue()),
      sValue = _useLocalValue.value,
      setLocalValue = _useLocalValue.setValue;

  var _useLocalValue2 = value_useLocalValue(props.defaultSelectedValue, 'selectedValue'),
      sSelectedValue = _useLocalValue2.value,
      setLocalSelectedValue = _useLocalValue2.setValue;

  var setValue = function setValue(value) {
    var originalValue = sValue.value;
    setLocalValue(value);

    if (originalValue && value && !originalValue.isSame(value) || !originalValue && value || originalValue && !value) {
      emit('change', value);
    }
  };

  var setSelectedValue = function setSelectedValue(selectedValue, cause) {
    setLocalSelectedValue(selectedValue);
    emit('select', selectedValue, cause);
  };

  return {
    sValue: sValue,
    selectedValue: sSelectedValue,
    setValue: setValue,
    setSelectedValue: setSelectedValue,
    onSelect: function onSelect(value, cause) {
      if (value) {
        setValue(value);
      }

      setSelectedValue(value, cause);
    },
    renderRoot: function renderRoot(newProps) {
      var _className;

      var prefixCls = props.prefixCls;
      var className = (_className = {}, defineProperty_default()(_className, prefixCls, 1), defineProperty_default()(_className, "".concat(prefixCls, "-hidden"), !props.visible), defineProperty_default()(_className, newProps["class"], !!newProps["class"]), _className);
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "ref": "rootInstance",
        "class": className,
        "tabindex": 0,
        "onKeydown": onKeyDown || calendar_mixin_noop,
        "onBlur": onBlur || calendar_mixin_noop
      }, [newProps.children]);
    },
    isAllowedDate: function isAllowedDate(value) {
      var disabledDate = props.disabledDate;
      var disabledTime = props.disabledTime;
      return util_isAllowedDate(value, disabledDate, disabledTime);
    }
  };
};
var MomentType = vue_types.custom(isMoment);
var CalendarMixin = {
  name: 'CalendarMixinWrapper',
  props: {
    value: MomentType,
    defaultValue: MomentType
  }
};
/* harmony default export */ var calendar_mixin = (CalendarMixin);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/month/month-table.tsx





var ROW = 4;
var COL = 3;

function month_table_noop() {}

var MonthTable = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: {
    cellRender: vue_types.func,
    prefixCls: vue_types.string,
    value: vue_types.object,
    locale: vue_types.any,
    contentRender: vue_types.any,
    disabledDate: vue_types.func
  },
  setup: function setup($props, _ref) {
    var emit = _ref.emit;

    var _useLocalValue = value_useLocalValue(),
        value = _useLocalValue.value,
        setValue = _useLocalValue.setValue,
        getValue = _useLocalValue.getValue;

    var months = function months() {
      var current = getValue().clone();
      var monthsValue = [];
      var index = 0;

      for (var rowIndex = 0; rowIndex < ROW; rowIndex++) {
        monthsValue[rowIndex] = [];

        for (var colIndex = 0; colIndex < COL; colIndex++) {
          current.month(index);
          var content = getMonthName(current);
          monthsValue[rowIndex][colIndex] = {
            value: index,
            content: content,
            title: content
          };
          index++;
        }
      }

      return monthsValue;
    };

    var setAndSelectValue = function setAndSelectValue(val) {
      setValue(val);
      emit('select', val);
    };

    var chooseMonth = function chooseMonth(month) {
      var next = getValue().clone();
      next.month(month);
      setAndSelectValue(next);
    };

    return {
      sValue: value,
      chooseMonth: chooseMonth,
      months: months
    };
  },
  render: function render() {
    var _this = this;

    var props = this.$props;
    var value = this.sValue;
    var today = getTodayTime(value);
    var months = this.months();
    var currentMonth = value.month();
    var prefixCls = props.prefixCls,
        locale = props.locale,
        contentRender = props.contentRender,
        cellRender = props.cellRender,
        disabledDate = props.disabledDate;
    var monthsEls = months.map(function (month, index) {
      var tds = month.map(function (monthData) {
        var _classNameMap;

        var disabled = false;

        if (disabledDate) {
          var testValue = value.clone();
          testValue.month(monthData.value);
          disabled = disabledDate(testValue);
        }

        var classNameMap = (_classNameMap = {}, defineProperty_default()(_classNameMap, "".concat(prefixCls, "-cell"), 1), defineProperty_default()(_classNameMap, "".concat(prefixCls, "-cell-disabled"), disabled), defineProperty_default()(_classNameMap, "".concat(prefixCls, "-selected-cell"), monthData.value === currentMonth), defineProperty_default()(_classNameMap, "".concat(prefixCls, "-current-cell"), today.year() === value.year() && monthData.value === today.month()), _classNameMap);
        var cellEl;

        if (cellRender) {
          var currentValue = value.clone();
          currentValue.month(monthData.value);
          cellEl = cellRender(currentValue, locale);
        } else {
          var content;

          if (contentRender) {
            var _currentValue = value.clone();

            _currentValue.month(monthData.value);

            content = contentRender(_currentValue, locale);
          } else {
            content = monthData.content;
          }

          cellEl = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
            "class": "".concat(prefixCls, "-month")
          }, [content]);
        }

        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("td", {
          "role": "gridcell",
          "key": monthData.value,
          "onClick": disabled ? month_table_noop : _this.chooseMonth.bind(_this, monthData.value),
          "title": monthData.title,
          "class": classNameMap
        }, [cellEl]);
      });
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("tr", {
        "key": index,
        "role": "row"
      }, [tds]);
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("table", {
      "class": "".concat(prefixCls, "-table"),
      "cellspacing": "0",
      "role": "grid"
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("tbody", {
      "class": "".concat(prefixCls, "-tbody")
    }, [monthsEls])]);
  }
}));
/* harmony default export */ var month_table = (MonthTable);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/full-calendar.tsx


function full_calendar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function full_calendar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { full_calendar_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { full_calendar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }











var FullCalendar = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: {
    locale: vue_types.object.def(zh_CN),
    format: vue_types.oneOfType([vue_types.string, vue_types.array]),
    visible: vue_types.bool.def(true),
    prefixCls: vue_types.string.def('rc-calendar'),
    defaultType: vue_types.string.def('date'),
    type: vue_types.string,
    fullscreen: vue_types.bool.def(false),
    monthCellRender: vue_types.func,
    dateCellRender: vue_types.func,
    showTypeSwitch: vue_types.bool.def(true),
    Select: vue_types.object.isRequired,
    headerComponents: vue_types.array,
    headerComponent: vue_types.object,
    headerRender: vue_types.func,
    showHeader: vue_types.bool.def(true),
    disabledDate: vue_types.func,
    value: vue_types.object,
    defaultValue: vue_types.object,
    selectedValue: vue_types.object,
    defaultSelectedValue: vue_types.object,
    renderFooter: vue_types.func.def(function () {
      return null;
    }),
    renderSidebar: vue_types.func.def(function () {
      return null;
    })
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var _useCommonMixin = common_mixin_useCommonMixin(props),
        focus = _useCommonMixin.focus,
        focusElement = _useCommonMixin.focusElement,
        getFormat = _useCommonMixin.getFormat,
        rootInstance = _useCommonMixin.rootInstance,
        saveFocusElement = _useCommonMixin.saveFocusElement,
        setRootInstance = _useCommonMixin.setRootInstance;

    var _useCalendarMixin = calendar_mixin_useCalendarMixin(props, emit, {}),
        setValue = _useCalendarMixin.setValue,
        renderRoot = _useCalendarMixin.renderRoot,
        onSelect = _useCalendarMixin.onSelect,
        sValue = _useCalendarMixin.sValue,
        sSelectedValue = _useCalendarMixin.selectedValue;

    var _useLocalValue = value_useLocalValue(props.defaultType, 'type'),
        sType = _useLocalValue.value,
        _setType = _useLocalValue.setValue;

    return {
      sType: sType,
      renderRoot: renderRoot,
      focus: focus,
      focusElement: focusElement,
      getFormat: getFormat,
      rootInstance: rootInstance,
      saveFocusElement: saveFocusElement,
      setRootInstance: setRootInstance,
      sValue: sValue,
      setValue: setValue,
      selectedValue: sSelectedValue,
      onSelect: onSelect,
      onMonthSelect: function onMonthSelect(value) {
        onSelect(value, {
          target: 'month'
        });
      },
      setType: function setType(type) {
        _setType(type);

        emit('typeChange', type);
      }
    };
  },
  render: function render(ctx) {
    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var props = getOptionProps(currentInstance);
    var locale = props.locale,
        prefixCls = props.prefixCls,
        fullscreen = props.fullscreen,
        showHeader = props.showHeader,
        headerComponent = props.headerComponent,
        headerRender = props.headerRender,
        disabledDate = props.disabledDate;
    var value = ctx.sValue,
        type = ctx.sType;
    var header = null;

    if (showHeader) {
      if (headerRender) {
        header = headerRender(value, type, locale);
      } else {
        var TheHeader = headerComponent || calendar_header;
        var headerProps = Object.assign(Object.assign(Object.assign(Object.assign({}, props), {
          prefixCls: "".concat(prefixCls, "-full"),
          type: type,
          value: value
        }), getListenersFromInstance(currentInstance)), {
          typeChange: ctx.setType,
          valueChange: ctx.setValue,
          key: 'calendar-header'
        });
        header = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(TheHeader, full_calendar_objectSpread({}, headerProps), []);
      }
    }

    var table = type === 'date' ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(date_table, {
      "dateRender": props.dateCellRender,
      "contentRender": props.dateCellContentRender,
      "locale": locale,
      "prefixCls": prefixCls,
      "onSelect": this.onSelect,
      "value": value,
      "disabledDate": disabledDate
    }, []) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(month_table, {
      "cellRender": props.monthCellRender,
      "contentRender": props.monthCellContentRender,
      "locale": locale,
      "onSelect": this.onMonthSelect,
      "prefixCls": "".concat(prefixCls, "-month-panel"),
      "value": value,
      "disabledDate": disabledDate
    }, []);
    var children = [header, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "key": "calendar-body",
      "class": "".concat(prefixCls, "-calendar-body")
    }, [table])];
    var className = ["".concat(prefixCls, "-full")];

    if (fullscreen) {
      className.push("".concat(prefixCls, "-fullscreen"));
    }

    return ctx.renderRoot({
      children: children,
      "class": className.join(' ')
    });
  }
});
/* harmony default export */ var full_calendar = (FullCalendar);
// CONCATENATED MODULE: ./node_modules/@vue/reactivity/node_modules/@vue/shared/dist/shared.esm-bundler.js
// Make a map and return a function for checking if a key
// is in that map.
//
// IMPORTANT: all calls of this function must be prefixed with /*#__PURE__*/
// So that rollup can tree-shake them if necessary.
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

// Patch flags are optimization hints generated by the compiler.
// when a block with dynamicChildren is encountered during diff, the algorithm
// enters "optimized mode". In this mode, we know that the vdom is produced by
// a render function generated by the compiler, so the algorithm only needs to
// handle updates explicitly marked by these patch flags.
// dev only flag -> name mapping
const PatchFlagNames = {
    [1 /* TEXT */]: `TEXT`,
    [2 /* CLASS */]: `CLASS`,
    [4 /* STYLE */]: `STYLE`,
    [8 /* PROPS */]: `PROPS`,
    [16 /* FULL_PROPS */]: `FULL_PROPS`,
    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [512 /* NEED_PATCH */]: `NEED_PATCH`,
    [-1 /* HOISTED */]: `HOISTED`,
    [-2 /* BAIL */]: `BAIL`
};

const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl';
const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

const shared_esm_bundler_range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    const lines = source.split(/\r?\n/);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count += lines[i].length + 1;
        if (count >= start) {
            for (let j = i - shared_esm_bundler_range; j <= i + shared_esm_bundler_range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(3 - String(line).length)}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                if (j === i) {
                    // push underline
                    const pad = start - (count - lineLength) + 1;
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + 1;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

const mockError = () => mockWarn(true);
function mockWarn(asError = false) {
    expect.extend({
        toHaveBeenWarned(received) {
            asserted.add(received);
            const passed = warn.mock.calls.some(args => args[0].indexOf(received) > -1);
            if (passed) {
                return {
                    pass: true,
                    message: () => `expected "${received}" not to have been warned.`
                };
            }
            else {
                const msgs = warn.mock.calls.map(args => args[0]).join('\n - ');
                return {
                    pass: false,
                    message: () => `expected "${received}" to have been warned.\n\nActual messages:\n\n - ${msgs}`
                };
            }
        },
        toHaveBeenWarnedLast(received) {
            asserted.add(received);
            const passed = warn.mock.calls[warn.mock.calls.length - 1][0].indexOf(received) > -1;
            if (passed) {
                return {
                    pass: true,
                    message: () => `expected "${received}" not to have been warned last.`
                };
            }
            else {
                const msgs = warn.mock.calls.map(args => args[0]).join('\n - ');
                return {
                    pass: false,
                    message: () => `expected "${received}" to have been warned last.\n\nActual messages:\n\n - ${msgs}`
                };
            }
        },
        toHaveBeenWarnedTimes(received, n) {
            asserted.add(received);
            let found = 0;
            warn.mock.calls.forEach(args => {
                if (args[0].indexOf(received) > -1) {
                    found++;
                }
            });
            if (found === n) {
                return {
                    pass: true,
                    message: () => `expected "${received}" to have been warned ${n} times.`
                };
            }
            else {
                return {
                    pass: false,
                    message: () => `expected "${received}" to have been warned ${n} times but got ${found}.`
                };
            }
        }
    });
    let warn;
    const asserted = new Set();
    beforeEach(() => {
        asserted.clear();
        warn = jest.spyOn(console, asError ? 'error' : 'warn');
        warn.mockImplementation(() => { });
    });
    afterEach(() => {
        const assertedArray = Array.from(asserted);
        const nonAssertedWarnings = warn.mock.calls
            .map(args => args[0])
            .filter(received => {
            return !assertedArray.some(assertedMsg => {
                return received.indexOf(assertedMsg) > -1;
            });
        });
        warn.mockRestore();
        if (nonAssertedWarnings.length) {
            nonAssertedWarnings.forEach(warning => {
                console.warn(warning);
            });
            throw new Error(`test case threw unexpected warnings.`);
        }
    });
}

/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */
const isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`);
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
    }
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
    }
    return (attrValidationCache[name] = !isUnsafe);
}
const propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */
const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`);
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */
const isKnownAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`);

function normalizeStyle(value) {
    if (shared_esm_bundler_isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    }
    else if (isObject(value)) {
        return value;
    }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach(item => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = '';
    if (!styles) {
        return ret;
    }
    for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) ||
            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {
            // only render valid values
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = '';
    if (isString(value)) {
        res = value;
    }
    else if (shared_esm_bundler_isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            res += normalizeClass(value[i]) + ' ';
        }
    }
    else if (isObject(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + ' ';
            }
        }
    }
    return res.trim();
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,menuitem,' +
    'summary,content,element,shadow,template,blockquote,iframe,tfoot';
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view';
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = '' + string;
    const match = escapeRE.exec(str);
    if (!match) {
        return str;
    }
    let html = '';
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escaped = '&quot;';
                break;
            case 38: // &
                escaped = '&amp;';
                break;
            case 39: // '
                escaped = '&#39;';
                break;
            case 60: // <
                escaped = '&lt;';
                break;
            case 62: // >
                escaped = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, '');
}

function looseEqual(a, b) {
    if (a === b)
        return true;
    const isObjectA = isObject(a);
    const isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
        try {
            const isArrayA = shared_esm_bundler_isArray(a);
            const isArrayB = shared_esm_bundler_isArray(b);
            if (isArrayA && isArrayB) {
                return (a.length === b.length &&
                    a.every((e, i) => looseEqual(e, b[i])));
            }
            else if (a instanceof Date && b instanceof Date) {
                return a.getTime() === b.getTime();
            }
            else if (!isArrayA && !isArrayB) {
                const keysA = Object.keys(a);
                const keysB = Object.keys(b);
                return (keysA.length === keysB.length &&
                    keysA.every(key => looseEqual(a[key], b[key])));
            }
            else {
                /* istanbul ignore next */
                return false;
            }
        }
        catch (e) {
            /* istanbul ignore next */
            return false;
        }
    }
    else if (!isObjectA && !isObjectB) {
        return String(a) === String(b);
    }
    else {
        return false;
    }
}
function looseIndexOf(arr, val) {
    return arr.findIndex(item => looseEqual(item, val));
}

// For converting {{ interpolation }} values to displayed strings.
const toDisplayString = (val) => {
    return val == null
        ? ''
        : isObject(val)
            ? JSON.stringify(val, replacer, 2)
            : String(val);
};
const replacer = (_key, val) => {
    if (val instanceof Map) {
        return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                entries[`${key} =>`] = val;
                return entries;
            }, {})
        };
    }
    else if (val instanceof Set) {
        return {
            [`Set(${val.size})`]: [...val.values()]
        };
    }
    else if (isObject(val) && !shared_esm_bundler_isArray(val) && !shared_esm_bundler_isPlainObject(val)) {
        return String(val);
    }
    return val;
};

const EMPTY_OBJ = ( false)
    ? undefined
    : {};
const EMPTY_ARR = [];
const NOOP = () => { };
/**
 * Always return false.
 */
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const extend = (a, b) => {
    for (const key in b) {
        a[key] = b[key];
    }
    return a;
};
const shared_esm_bundler_remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const shared_esm_bundler_hasOwnProperty = Object.prototype.hasOwnProperty;
const shared_esm_bundler_hasOwn = (val, key) => shared_esm_bundler_hasOwnProperty.call(val, key);
const shared_esm_bundler_isArray = Array.isArray;
const shared_esm_bundler_isFunction = (val) => typeof val === 'function';
const isString = (val) => typeof val === 'string';
const isSymbol = (val) => typeof val === 'symbol';
const isObject = (val) => val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject(val) && shared_esm_bundler_isFunction(val.then) && shared_esm_bundler_isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
};
const shared_esm_bundler_isPlainObject = (val) => toTypeString(val) === '[object Object]';
const isReservedProp = /*#__PURE__*/ makeMap('key,ref,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const shared_esm_bundler_camelizeRE = /-(\w)/g;
const shared_esm_bundler_camelize = cacheStringFunction((str) => {
    return str.replace(shared_esm_bundler_camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => {
    return str.replace(hyphenateRE, '-$1').toLowerCase();
});
const capitalize = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
});
// compare whether a value has changed, accounting for NaN.
const hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
    }
};
const shared_esm_bundler_def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        value
    });
};
const toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};



// CONCATENATED MODULE: ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js


const targetMap = new WeakMap();
const effectStack = [];
let activeEffect;
const ITERATE_KEY = Symbol(( false) ? undefined : '');
const MAP_KEY_ITERATE_KEY = Symbol(( false) ? undefined : '');
function isEffect(fn) {
    return fn && fn._isEffect === true;
}
function reactivity_esm_bundler_effect(fn, options = EMPTY_OBJ) {
    if (isEffect(fn)) {
        fn = fn.raw;
    }
    const effect = createReactiveEffect(fn, options);
    if (!options.lazy) {
        effect();
    }
    return effect;
}
function reactivity_esm_bundler_stop(effect) {
    if (effect.active) {
        reactivity_esm_bundler_cleanup(effect);
        if (effect.options.onStop) {
            effect.options.onStop();
        }
        effect.active = false;
    }
}
let reactivity_esm_bundler_uid = 0;
function createReactiveEffect(fn, options) {
    const effect = function reactiveEffect(...args) {
        if (!effect.active) {
            return options.scheduler ? undefined : fn(...args);
        }
        if (!effectStack.includes(effect)) {
            reactivity_esm_bundler_cleanup(effect);
            try {
                enableTracking();
                effectStack.push(effect);
                activeEffect = effect;
                return fn(...args);
            }
            finally {
                effectStack.pop();
                resetTracking();
                activeEffect = effectStack[effectStack.length - 1];
            }
        }
    };
    effect.id = reactivity_esm_bundler_uid++;
    effect._isEffect = true;
    effect.active = true;
    effect.raw = fn;
    effect.deps = [];
    effect.options = options;
    return effect;
}
function reactivity_esm_bundler_cleanup(effect) {
    const { deps } = effect;
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].delete(effect);
        }
        deps.length = 0;
    }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === undefined ? true : last;
}
function track(target, type, key) {
    if (!shouldTrack || activeEffect === undefined) {
        return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
        targetMap.set(target, (depsMap = new Map()));
    }
    let dep = depsMap.get(key);
    if (!dep) {
        depsMap.set(key, (dep = new Set()));
    }
    if (!dep.has(activeEffect)) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (false) {}
    }
}
function reactivity_esm_bundler_trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
        // never been tracked
        return;
    }
    const effects = new Set();
    const computedRunners = new Set();
    const add = (effectsToAdd) => {
        if (effectsToAdd) {
            effectsToAdd.forEach(effect => {
                if (effect !== activeEffect || !shouldTrack) {
                    if (effect.options.computed) {
                        computedRunners.add(effect);
                    }
                    else {
                        effects.add(effect);
                    }
                }
            });
        }
    };
    if (type === "clear" /* CLEAR */) {
        // collection being cleared
        // trigger all effects for target
        depsMap.forEach(add);
    }
    else if (key === 'length' && shared_esm_bundler_isArray(target)) {
        depsMap.forEach((dep, key) => {
            if (key === 'length' || key >= newValue) {
                add(dep);
            }
        });
    }
    else {
        // schedule runs for SET | ADD | DELETE
        if (key !== void 0) {
            add(depsMap.get(key));
        }
        // also run for iteration key on ADD | DELETE | Map.SET
        const isAddOrDelete = type === "add" /* ADD */ ||
            (type === "delete" /* DELETE */ && !shared_esm_bundler_isArray(target));
        if (isAddOrDelete ||
            (type === "set" /* SET */ && target instanceof Map)) {
            add(depsMap.get(shared_esm_bundler_isArray(target) ? 'length' : ITERATE_KEY));
        }
        if (isAddOrDelete && target instanceof Map) {
            add(depsMap.get(MAP_KEY_ITERATE_KEY));
        }
    }
    const run = (effect) => {
        if (false) {}
        if (effect.options.scheduler) {
            effect.options.scheduler(effect);
        }
        else {
            effect();
        }
    };
    // Important: computed effects must be run first so that computed getters
    // can be invalidated before any normal effects that depend on them are run.
    computedRunners.forEach(run);
    effects.forEach(run);
}

const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)
    .map(key => Symbol[key])
    .filter(isSymbol));
const reactivity_esm_bundler_get = /*#__PURE__*/ createGetter();
const shallowGet = /*#__PURE__*/ createGetter(false, true);
const readonlyGet = /*#__PURE__*/ createGetter(true);
const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
const arrayInstrumentations = {};
['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
    arrayInstrumentations[key] = function (...args) {
        const arr = toRaw(this);
        for (let i = 0, l = this.length; i < l; i++) {
            track(arr, "get" /* GET */, i + '');
        }
        // we run the method using the original args first (which may be reactive)
        const res = arr[key](...args);
        if (res === -1 || res === false) {
            // if that didn't work, run it again using raw values.
            return arr[key](...args.map(toRaw));
        }
        else {
            return res;
        }
    };
});
function createGetter(isReadonly = false, shallow = false) {
    return function get(target, key, receiver) {
        if (key === "__v_isReactive" /* isReactive */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* isReadonly */) {
            return isReadonly;
        }
        else if (key === "__v_raw" /* raw */) {
            return target;
        }
        const targetIsArray = shared_esm_bundler_isArray(target);
        if (targetIsArray && shared_esm_bundler_hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
        }
        const res = Reflect.get(target, key, receiver);
        if (isSymbol(key) && builtInSymbols.has(key) || key === '__proto__') {
            return res;
        }
        if (shallow) {
            !isReadonly && track(target, "get" /* GET */, key);
            return res;
        }
        if (isRef(res)) {
            if (targetIsArray) {
                !isReadonly && track(target, "get" /* GET */, key);
                return res;
            }
            else {
                // ref unwrapping, only for Objects, not for Arrays.
                return res.value;
            }
        }
        !isReadonly && track(target, "get" /* GET */, key);
        return isObject(res)
            ? isReadonly
                ? // need to lazy access readonly and reactive here to avoid
                    // circular dependency
                    readonly(res)
                : reactive(res)
            : res;
    };
}
const reactivity_esm_bundler_set = /*#__PURE__*/ createSetter();
const shallowSet = /*#__PURE__*/ createSetter(true);
function createSetter(shallow = false) {
    return function set(target, key, value, receiver) {
        const oldValue = target[key];
        if (!shallow) {
            value = toRaw(value);
            if (!shared_esm_bundler_isArray(target) && isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
                return true;
            }
        }
        const hadKey = shared_esm_bundler_hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        // don't trigger if target is something up in the prototype chain of original
        if (target === toRaw(receiver)) {
            if (!hadKey) {
                reactivity_esm_bundler_trigger(target, "add" /* ADD */, key, value);
            }
            else if (hasChanged(value, oldValue)) {
                reactivity_esm_bundler_trigger(target, "set" /* SET */, key, value, oldValue);
            }
        }
        return result;
    };
}
function deleteProperty(target, key) {
    const hadKey = shared_esm_bundler_hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
        reactivity_esm_bundler_trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function reactivity_esm_bundler_has(target, key) {
    const result = Reflect.has(target, key);
    track(target, "has" /* HAS */, key);
    return result;
}
function reactivity_esm_bundler_ownKeys(target) {
    track(target, "iterate" /* ITERATE */, ITERATE_KEY);
    return Reflect.ownKeys(target);
}
const mutableHandlers = {
    get: reactivity_esm_bundler_get,
    set: reactivity_esm_bundler_set,
    deleteProperty,
    has: reactivity_esm_bundler_has,
    ownKeys: reactivity_esm_bundler_ownKeys
};
const readonlyHandlers = {
    get: readonlyGet,
    has: reactivity_esm_bundler_has,
    ownKeys: reactivity_esm_bundler_ownKeys,
    set(target, key) {
        if ((false)) {}
        return true;
    },
    deleteProperty(target, key) {
        if ((false)) {}
        return true;
    }
};
const shallowReactiveHandlers = {
    ...mutableHandlers,
    get: shallowGet,
    set: shallowSet
};
// Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.
const shallowReadonlyHandlers = {
    ...readonlyHandlers,
    get: shallowReadonlyGet
};

const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, wrap) {
    target = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
        track(target, "get" /* GET */, key);
    }
    track(target, "get" /* GET */, rawKey);
    const { has, get } = getProto(target);
    if (has.call(target, key)) {
        return wrap(get.call(target, key));
    }
    else if (has.call(target, rawKey)) {
        return wrap(get.call(target, rawKey));
    }
}
function has$1(key) {
    const target = toRaw(this);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
        track(target, "has" /* HAS */, key);
    }
    track(target, "has" /* HAS */, rawKey);
    const has = getProto(target).has;
    return has.call(target, key) || has.call(target, rawKey);
}
function reactivity_esm_bundler_size(target) {
    target = toRaw(target);
    track(target, "iterate" /* ITERATE */, ITERATE_KEY);
    return Reflect.get(getProto(target), 'size', target);
}
function reactivity_esm_bundler_add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    const result = proto.add.call(target, value);
    if (!hadKey) {
        reactivity_esm_bundler_trigger(target, "add" /* ADD */, value, value);
    }
    return result;
}
function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has, get, set } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((false)) {}
    const oldValue = get.call(target, key);
    const result = set.call(target, key, value);
    if (!hadKey) {
        reactivity_esm_bundler_trigger(target, "add" /* ADD */, key, value);
    }
    else if (hasChanged(value, oldValue)) {
        reactivity_esm_bundler_trigger(target, "set" /* SET */, key, value, oldValue);
    }
    return result;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has, get, delete: del } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((false)) {}
    const oldValue = get ? get.call(target, key) : undefined;
    // forward the operation before queueing reactions
    const result = del.call(target, key);
    if (hadKey) {
        reactivity_esm_bundler_trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function reactivity_esm_bundler_clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = ( false)
        ? undefined
        : undefined;
    // forward the operation before queueing reactions
    const result = getProto(target).clear.call(target);
    if (hadItems) {
        reactivity_esm_bundler_trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);
    }
    return result;
}
function createForEach(isReadonly, shallow) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = toRaw(observed);
        const wrap = isReadonly ? toReadonly : shallow ? toShallow : toReactive;
        !isReadonly && track(target, "iterate" /* ITERATE */, ITERATE_KEY);
        // important: create sure the callback is
        // 1. invoked with the reactive map as `this` and 3rd arg
        // 2. the value received should be a corresponding reactive/readonly.
        function wrappedCallback(value, key) {
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        }
        return getProto(target).forEach.call(target, wrappedCallback);
    };
}
function createIterableMethod(method, isReadonly, shallow) {
    return function (...args) {
        const target = toRaw(this);
        const isMap = target instanceof Map;
        const isPair = method === 'entries' || (method === Symbol.iterator && isMap);
        const isKeyOnly = method === 'keys' && isMap;
        const innerIterator = getProto(target)[method].apply(target, args);
        const wrap = isReadonly ? toReadonly : shallow ? toShallow : toReactive;
        !isReadonly &&
            track(target, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        // return a wrapped iterator which returns observed versions of the
        // values emitted from the real iterator
        return {
            // iterator protocol
            next() {
                const { value, done } = innerIterator.next();
                return done
                    ? { value, done }
                    : {
                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                        done
                    };
            },
            // iterable protocol
            [Symbol.iterator]() {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function (...args) {
        if ((false)) {}
        return type === "delete" /* DELETE */ ? false : this;
    };
}
const mutableInstrumentations = {
    get(key) {
        return get$1(this, key, toReactive);
    },
    get size() {
        return reactivity_esm_bundler_size(this);
    },
    has: has$1,
    add: reactivity_esm_bundler_add,
    set: set$1,
    delete: deleteEntry,
    clear: reactivity_esm_bundler_clear,
    forEach: createForEach(false, false)
};
const shallowInstrumentations = {
    get(key) {
        return get$1(this, key, toShallow);
    },
    get size() {
        return reactivity_esm_bundler_size(this);
    },
    has: has$1,
    add: reactivity_esm_bundler_add,
    set: set$1,
    delete: deleteEntry,
    clear: reactivity_esm_bundler_clear,
    forEach: createForEach(false, true)
};
const readonlyInstrumentations = {
    get(key) {
        return get$1(this, key, toReadonly);
    },
    get size() {
        return reactivity_esm_bundler_size(this);
    },
    has: has$1,
    add: createReadonlyMethod("add" /* ADD */),
    set: createReadonlyMethod("set" /* SET */),
    delete: createReadonlyMethod("delete" /* DELETE */),
    clear: createReadonlyMethod("clear" /* CLEAR */),
    forEach: createForEach(true, false)
};
const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
iteratorMethods.forEach(method => {
    mutableInstrumentations[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations[method] = createIterableMethod(method, true, false);
    shallowInstrumentations[method] = createIterableMethod(method, true, true);
});
function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow
        ? shallowInstrumentations
        : isReadonly
            ? readonlyInstrumentations
            : mutableInstrumentations;
    return (target, key, receiver) => {
        if (key === "__v_isReactive" /* isReactive */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* isReadonly */) {
            return isReadonly;
        }
        else if (key === "__v_raw" /* raw */) {
            return target;
        }
        return Reflect.get(shared_esm_bundler_hasOwn(instrumentations, key) && key in target
            ? instrumentations
            : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: createInstrumentationGetter(true, false)
};
function checkIdentityKeys(target, has, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has.call(target, rawKey)) {
        const type = toRawType(target);
        console.warn(`Reactive ${type} contains both the raw and reactive ` +
            `versions of the same object${type === `Map` ? `as keys` : ``}, ` +
            `which can lead to inconsistencies. ` +
            `Avoid differentiating between the raw and reactive versions ` +
            `of an object and only use the reactive version if possible.`);
    }
}

const collectionTypes = new Set([Set, Map, WeakMap, WeakSet]);
const isObservableType = /*#__PURE__*/ makeMap('Object,Array,Map,Set,WeakMap,WeakSet');
const canObserve = (value) => {
    return (!value.__v_skip &&
        isObservableType(toRawType(value)) &&
        !Object.isFrozen(value));
};
function reactive(target) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (target && target.__v_isReadonly) {
        return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);
}
// Return a reactive-copy of the original object, where only the root level
// properties are reactive, and does NOT unwrap refs nor recursively convert
// returned properties.
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers);
}
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);
}
// Return a reactive-copy of the original object, where only the root level
// properties are readonly, and does NOT unwrap refs nor recursively convert
// returned properties.
// This is used for creating the props proxy object for stateful components.
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {
    if (!isObject(target)) {
        if ((false)) {}
        return target;
    }
    // target is already a Proxy, return it.
    // exception: calling readonly() on a reactive object
    if (target.__v_raw && !(isReadonly && target.__v_isReactive)) {
        return target;
    }
    // target already has corresponding Proxy
    if (shared_esm_bundler_hasOwn(target, isReadonly ? "__v_readonly" /* readonly */ : "__v_reactive" /* reactive */)) {
        return isReadonly ? target.__v_readonly : target.__v_reactive;
    }
    // only a whitelist of value types can be observed.
    if (!canObserve(target)) {
        return target;
    }
    const observed = new Proxy(target, collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers);
    shared_esm_bundler_def(target, isReadonly ? "__v_readonly" /* readonly */ : "__v_reactive" /* reactive */, observed);
    return observed;
}
function isReactive(value) {
    if (reactivity_esm_bundler_isReadonly(value)) {
        return isReactive(value.__v_raw);
    }
    return !!(value && value.__v_isReactive);
}
function reactivity_esm_bundler_isReadonly(value) {
    return !!(value && value.__v_isReadonly);
}
function isProxy(value) {
    return isReactive(value) || reactivity_esm_bundler_isReadonly(value);
}
function toRaw(observed) {
    return (observed && toRaw(observed.__v_raw)) || observed;
}
function markRaw(value) {
    shared_esm_bundler_def(value, "__v_skip" /* skip */, true);
    return value;
}

const convert = (val) => isObject(val) ? reactive(val) : val;
function isRef(r) {
    return r ? r.__v_isRef === true : false;
}
function reactivity_esm_bundler_ref(value) {
    return createRef(value);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow = false) {
    if (isRef(rawValue)) {
        return rawValue;
    }
    let value = shallow ? rawValue : convert(rawValue);
    const r = {
        __v_isRef: true,
        get value() {
            track(r, "get" /* GET */, 'value');
            return value;
        },
        set value(newVal) {
            if (hasChanged(toRaw(newVal), rawValue)) {
                rawValue = newVal;
                value = shallow ? newVal : convert(newVal);
                reactivity_esm_bundler_trigger(r, "set" /* SET */, 'value', ( false) ? undefined : void 0);
            }
        }
    };
    return r;
}
function triggerRef(ref) {
    reactivity_esm_bundler_trigger(ref, "set" /* SET */, 'value', ( false) ? undefined : void 0);
}
function unref(ref) {
    return isRef(ref) ? ref.value : ref;
}
function customRef(factory) {
    const { get, set } = factory(() => track(r, "get" /* GET */, 'value'), () => reactivity_esm_bundler_trigger(r, "set" /* SET */, 'value'));
    const r = {
        __v_isRef: true,
        get value() {
            return get();
        },
        set value(v) {
            set(v);
        }
    };
    return r;
}
function toRefs(object) {
    if (false) {}
    const ret = {};
    for (const key in object) {
        ret[key] = toRef(object, key);
    }
    return ret;
}
function toRef(object, key) {
    return {
        __v_isRef: true,
        get value() {
            return object[key];
        },
        set value(newVal) {
            object[key] = newVal;
        }
    };
}

function reactivity_esm_bundler_computed(getterOrOptions) {
    let getter;
    let setter;
    if (shared_esm_bundler_isFunction(getterOrOptions)) {
        getter = getterOrOptions;
        setter = ( false)
            ? undefined
            : NOOP;
    }
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    let dirty = true;
    let value;
    let computed;
    const runner = reactivity_esm_bundler_effect(getter, {
        lazy: true,
        // mark effect as computed so that it gets priority during trigger
        computed: true,
        scheduler: () => {
            if (!dirty) {
                dirty = true;
                reactivity_esm_bundler_trigger(computed, "set" /* SET */, 'value');
            }
        }
    });
    computed = {
        __v_isRef: true,
        // expose effect so computed can be stopped
        effect: runner,
        get value() {
            if (dirty) {
                value = runner();
                dirty = false;
            }
            track(computed, "get" /* GET */, 'value');
            return value;
        },
        set value(newValue) {
            setter(newValue);
        }
    };
    return computed;
}



// CONCATENATED MODULE: ./node_modules/@vue/runtime-core/node_modules/@vue/shared/dist/shared.esm-bundler.js
// Make a map and return a function for checking if a key
// is in that map.
//
// IMPORTANT: all calls of this function must be prefixed with /*#__PURE__*/
// So that rollup can tree-shake them if necessary.
function shared_esm_bundler_makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

// Patch flags are optimization hints generated by the compiler.
// when a block with dynamicChildren is encountered during diff, the algorithm
// enters "optimized mode". In this mode, we know that the vdom is produced by
// a render function generated by the compiler, so the algorithm only needs to
// handle updates explicitly marked by these patch flags.
// dev only flag -> name mapping
const shared_esm_bundler_PatchFlagNames = {
    [1 /* TEXT */]: `TEXT`,
    [2 /* CLASS */]: `CLASS`,
    [4 /* STYLE */]: `STYLE`,
    [8 /* PROPS */]: `PROPS`,
    [16 /* FULL_PROPS */]: `FULL_PROPS`,
    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [512 /* NEED_PATCH */]: `NEED_PATCH`,
    [-1 /* HOISTED */]: `HOISTED`,
    [-2 /* BAIL */]: `BAIL`
};

const shared_esm_bundler_GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl';
const shared_esm_bundler_isGloballyWhitelisted = /*#__PURE__*/ shared_esm_bundler_makeMap(shared_esm_bundler_GLOBALS_WHITE_LISTED);

const dist_shared_esm_bundler_range = 2;
function shared_esm_bundler_generateCodeFrame(source, start = 0, end = source.length) {
    const lines = source.split(/\r?\n/);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count += lines[i].length + 1;
        if (count >= start) {
            for (let j = i - dist_shared_esm_bundler_range; j <= i + dist_shared_esm_bundler_range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(3 - String(line).length)}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                if (j === i) {
                    // push underline
                    const pad = start - (count - lineLength) + 1;
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + 1;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

const shared_esm_bundler_mockError = () => shared_esm_bundler_mockWarn(true);
function shared_esm_bundler_mockWarn(asError = false) {
    expect.extend({
        toHaveBeenWarned(received) {
            asserted.add(received);
            const passed = warn.mock.calls.some(args => args[0].indexOf(received) > -1);
            if (passed) {
                return {
                    pass: true,
                    message: () => `expected "${received}" not to have been warned.`
                };
            }
            else {
                const msgs = warn.mock.calls.map(args => args[0]).join('\n - ');
                return {
                    pass: false,
                    message: () => `expected "${received}" to have been warned.\n\nActual messages:\n\n - ${msgs}`
                };
            }
        },
        toHaveBeenWarnedLast(received) {
            asserted.add(received);
            const passed = warn.mock.calls[warn.mock.calls.length - 1][0].indexOf(received) > -1;
            if (passed) {
                return {
                    pass: true,
                    message: () => `expected "${received}" not to have been warned last.`
                };
            }
            else {
                const msgs = warn.mock.calls.map(args => args[0]).join('\n - ');
                return {
                    pass: false,
                    message: () => `expected "${received}" to have been warned last.\n\nActual messages:\n\n - ${msgs}`
                };
            }
        },
        toHaveBeenWarnedTimes(received, n) {
            asserted.add(received);
            let found = 0;
            warn.mock.calls.forEach(args => {
                if (args[0].indexOf(received) > -1) {
                    found++;
                }
            });
            if (found === n) {
                return {
                    pass: true,
                    message: () => `expected "${received}" to have been warned ${n} times.`
                };
            }
            else {
                return {
                    pass: false,
                    message: () => `expected "${received}" to have been warned ${n} times but got ${found}.`
                };
            }
        }
    });
    let warn;
    const asserted = new Set();
    beforeEach(() => {
        asserted.clear();
        warn = jest.spyOn(console, asError ? 'error' : 'warn');
        warn.mockImplementation(() => { });
    });
    afterEach(() => {
        const assertedArray = Array.from(asserted);
        const nonAssertedWarnings = warn.mock.calls
            .map(args => args[0])
            .filter(received => {
            return !assertedArray.some(assertedMsg => {
                return received.indexOf(assertedMsg) > -1;
            });
        });
        warn.mockRestore();
        if (nonAssertedWarnings.length) {
            nonAssertedWarnings.forEach(warning => {
                console.warn(warning);
            });
            throw new Error(`test case threw unexpected warnings.`);
        }
    });
}

/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */
const shared_esm_bundler_specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const shared_esm_bundler_isSpecialBooleanAttr = /*#__PURE__*/ shared_esm_bundler_makeMap(shared_esm_bundler_specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */
const shared_esm_bundler_isBooleanAttr = /*#__PURE__*/ shared_esm_bundler_makeMap(shared_esm_bundler_specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`);
const shared_esm_bundler_unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const shared_esm_bundler_attrValidationCache = {};
function shared_esm_bundler_isSSRSafeAttrName(name) {
    if (shared_esm_bundler_attrValidationCache.hasOwnProperty(name)) {
        return shared_esm_bundler_attrValidationCache[name];
    }
    const isUnsafe = shared_esm_bundler_unsafeAttrCharRE.test(name);
    if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
    }
    return (shared_esm_bundler_attrValidationCache[name] = !isUnsafe);
}
const shared_esm_bundler_propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */
const shared_esm_bundler_isNoUnitNumericStyleProp = /*#__PURE__*/ shared_esm_bundler_makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`);
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */
const shared_esm_bundler_isKnownAttr = /*#__PURE__*/ shared_esm_bundler_makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`);

function shared_esm_bundler_normalizeStyle(value) {
    if (dist_shared_esm_bundler_isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = shared_esm_bundler_normalizeStyle(shared_esm_bundler_isString(item) ? shared_esm_bundler_parseStringStyle(item) : item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    }
    else if (shared_esm_bundler_isObject(value)) {
        return value;
    }
}
const shared_esm_bundler_listDelimiterRE = /;(?![^(]*\))/g;
const shared_esm_bundler_propertyDelimiterRE = /:(.+)/;
function shared_esm_bundler_parseStringStyle(cssText) {
    const ret = {};
    cssText.split(shared_esm_bundler_listDelimiterRE).forEach(item => {
        if (item) {
            const tmp = item.split(shared_esm_bundler_propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function shared_esm_bundler_stringifyStyle(styles) {
    let ret = '';
    if (!styles) {
        return ret;
    }
    for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : shared_esm_bundler_hyphenate(key);
        if (shared_esm_bundler_isString(value) ||
            (typeof value === 'number' && shared_esm_bundler_isNoUnitNumericStyleProp(normalizedKey))) {
            // only render valid values
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function shared_esm_bundler_normalizeClass(value) {
    let res = '';
    if (shared_esm_bundler_isString(value)) {
        res = value;
    }
    else if (dist_shared_esm_bundler_isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            res += shared_esm_bundler_normalizeClass(value[i]) + ' ';
        }
    }
    else if (shared_esm_bundler_isObject(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + ' ';
            }
        }
    }
    return res.trim();
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const shared_esm_bundler_HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,menuitem,' +
    'summary,content,element,shadow,template,blockquote,iframe,tfoot';
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const shared_esm_bundler_SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view';
const shared_esm_bundler_VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
const shared_esm_bundler_isHTMLTag = /*#__PURE__*/ shared_esm_bundler_makeMap(shared_esm_bundler_HTML_TAGS);
const shared_esm_bundler_isSVGTag = /*#__PURE__*/ shared_esm_bundler_makeMap(shared_esm_bundler_SVG_TAGS);
const shared_esm_bundler_isVoidTag = /*#__PURE__*/ shared_esm_bundler_makeMap(shared_esm_bundler_VOID_TAGS);

const shared_esm_bundler_escapeRE = /["'&<>]/;
function shared_esm_bundler_escapeHtml(string) {
    const str = '' + string;
    const match = shared_esm_bundler_escapeRE.exec(str);
    if (!match) {
        return str;
    }
    let html = '';
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escaped = '&quot;';
                break;
            case 38: // &
                escaped = '&amp;';
                break;
            case 39: // '
                escaped = '&#39;';
                break;
            case 60: // <
                escaped = '&lt;';
                break;
            case 62: // >
                escaped = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
// https://www.w3.org/TR/html52/syntax.html#comments
const shared_esm_bundler_commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function shared_esm_bundler_escapeHtmlComment(src) {
    return src.replace(shared_esm_bundler_commentStripRE, '');
}

function shared_esm_bundler_looseEqual(a, b) {
    if (a === b)
        return true;
    const isObjectA = shared_esm_bundler_isObject(a);
    const isObjectB = shared_esm_bundler_isObject(b);
    if (isObjectA && isObjectB) {
        try {
            const isArrayA = dist_shared_esm_bundler_isArray(a);
            const isArrayB = dist_shared_esm_bundler_isArray(b);
            if (isArrayA && isArrayB) {
                return (a.length === b.length &&
                    a.every((e, i) => shared_esm_bundler_looseEqual(e, b[i])));
            }
            else if (a instanceof Date && b instanceof Date) {
                return a.getTime() === b.getTime();
            }
            else if (!isArrayA && !isArrayB) {
                const keysA = Object.keys(a);
                const keysB = Object.keys(b);
                return (keysA.length === keysB.length &&
                    keysA.every(key => shared_esm_bundler_looseEqual(a[key], b[key])));
            }
            else {
                /* istanbul ignore next */
                return false;
            }
        }
        catch (e) {
            /* istanbul ignore next */
            return false;
        }
    }
    else if (!isObjectA && !isObjectB) {
        return String(a) === String(b);
    }
    else {
        return false;
    }
}
function shared_esm_bundler_looseIndexOf(arr, val) {
    return arr.findIndex(item => shared_esm_bundler_looseEqual(item, val));
}

// For converting {{ interpolation }} values to displayed strings.
const shared_esm_bundler_toDisplayString = (val) => {
    return val == null
        ? ''
        : shared_esm_bundler_isObject(val)
            ? JSON.stringify(val, shared_esm_bundler_replacer, 2)
            : String(val);
};
const shared_esm_bundler_replacer = (_key, val) => {
    if (val instanceof Map) {
        return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                entries[`${key} =>`] = val;
                return entries;
            }, {})
        };
    }
    else if (val instanceof Set) {
        return {
            [`Set(${val.size})`]: [...val.values()]
        };
    }
    else if (shared_esm_bundler_isObject(val) && !dist_shared_esm_bundler_isArray(val) && !dist_shared_esm_bundler_isPlainObject(val)) {
        return String(val);
    }
    return val;
};

const shared_esm_bundler_EMPTY_OBJ = ( false)
    ? undefined
    : {};
const shared_esm_bundler_EMPTY_ARR = [];
const shared_esm_bundler_NOOP = () => { };
/**
 * Always return false.
 */
const shared_esm_bundler_NO = () => false;
const shared_esm_bundler_onRE = /^on[^a-z]/;
const shared_esm_bundler_isOn = (key) => shared_esm_bundler_onRE.test(key);
const shared_esm_bundler_extend = (a, b) => {
    for (const key in b) {
        a[key] = b[key];
    }
    return a;
};
const dist_shared_esm_bundler_remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const dist_shared_esm_bundler_hasOwnProperty = Object.prototype.hasOwnProperty;
const dist_shared_esm_bundler_hasOwn = (val, key) => dist_shared_esm_bundler_hasOwnProperty.call(val, key);
const dist_shared_esm_bundler_isArray = Array.isArray;
const dist_shared_esm_bundler_isFunction = (val) => typeof val === 'function';
const shared_esm_bundler_isString = (val) => typeof val === 'string';
const shared_esm_bundler_isSymbol = (val) => typeof val === 'symbol';
const shared_esm_bundler_isObject = (val) => val !== null && typeof val === 'object';
const shared_esm_bundler_isPromise = (val) => {
    return shared_esm_bundler_isObject(val) && dist_shared_esm_bundler_isFunction(val.then) && dist_shared_esm_bundler_isFunction(val.catch);
};
const shared_esm_bundler_objectToString = Object.prototype.toString;
const shared_esm_bundler_toTypeString = (value) => shared_esm_bundler_objectToString.call(value);
const shared_esm_bundler_toRawType = (value) => {
    return shared_esm_bundler_toTypeString(value).slice(8, -1);
};
const dist_shared_esm_bundler_isPlainObject = (val) => shared_esm_bundler_toTypeString(val) === '[object Object]';
const shared_esm_bundler_isReservedProp = /*#__PURE__*/ shared_esm_bundler_makeMap('key,ref,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const shared_esm_bundler_cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const dist_shared_esm_bundler_camelizeRE = /-(\w)/g;
const dist_shared_esm_bundler_camelize = shared_esm_bundler_cacheStringFunction((str) => {
    return str.replace(dist_shared_esm_bundler_camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const shared_esm_bundler_hyphenateRE = /\B([A-Z])/g;
const shared_esm_bundler_hyphenate = shared_esm_bundler_cacheStringFunction((str) => {
    return str.replace(shared_esm_bundler_hyphenateRE, '-$1').toLowerCase();
});
const shared_esm_bundler_capitalize = shared_esm_bundler_cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
});
// compare whether a value has changed, accounting for NaN.
const shared_esm_bundler_hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
const shared_esm_bundler_invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
    }
};
const dist_shared_esm_bundler_def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        value
    });
};
const shared_esm_bundler_toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};



// CONCATENATED MODULE: ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js




const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function runtime_core_esm_bundler_warn(msg, ...args) {
    // avoid props formatting or warn handler tracking deps that might be mutated
    // during patch, leading to infinite recursion.
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [
            msg + args.join(''),
            instance && instance.proxy,
            trace
                .map(({ vnode }) => `at <${formatComponentName(vnode.type)}>`)
                .join('\n'),
            trace
        ]);
    }
    else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length &&
            // avoid spamming console during tests
            !false) {
            warnArgs.push(`\n`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
    }
    resetTracking();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
        return [];
    }
    // we can't just use the stack because it will be incomplete during updates
    // that did not start from the root. Re-construct the parent chain using
    // instance parent pointers.
    const normalizedStack = [];
    while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
            last.recurseCount++;
        }
        else {
            normalizedStack.push({
                vnode: currentVNode,
                recurseCount: 0
            });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
        logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props
        ? [open, ...formatProps(vnode.props), close]
        : [open + close];
}
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach(key => {
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
        res.push(` ...`);
    }
    return res;
}
function formatProp(key, value, raw) {
    if (shared_esm_bundler_isString(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
    }
    else if (typeof value === 'number' ||
        typeof value === 'boolean' ||
        value == null) {
        return raw ? value : [`${key}=${value}`];
    }
    else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
    }
    else if (dist_shared_esm_bundler_isFunction(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    }
    else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
    }
}

const ErrorTypeStrings = {
    ["bc" /* BEFORE_CREATE */]: 'beforeCreate hook',
    ["c" /* CREATED */]: 'created hook',
    ["bm" /* BEFORE_MOUNT */]: 'beforeMount hook',
    ["m" /* MOUNTED */]: 'mounted hook',
    ["bu" /* BEFORE_UPDATE */]: 'beforeUpdate hook',
    ["u" /* UPDATED */]: 'updated',
    ["bum" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
    ["um" /* UNMOUNTED */]: 'unmounted hook',
    ["a" /* ACTIVATED */]: 'activated hook',
    ["da" /* DEACTIVATED */]: 'deactivated hook',
    ["ec" /* ERROR_CAPTURED */]: 'errorCaptured hook',
    ["rtc" /* RENDER_TRACKED */]: 'renderTracked hook',
    ["rtg" /* RENDER_TRIGGERED */]: 'renderTriggered hook',
    [0 /* SETUP_FUNCTION */]: 'setup function',
    [1 /* RENDER_FUNCTION */]: 'render function',
    [2 /* WATCH_GETTER */]: 'watcher getter',
    [3 /* WATCH_CALLBACK */]: 'watcher callback',
    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
    [7 /* VNODE_HOOK */]: 'vnode hook',
    [8 /* DIRECTIVE_HOOK */]: 'directive hook',
    [9 /* TRANSITION_HOOK */]: 'transition hook',
    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',
    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',
    [12 /* FUNCTION_REF */]: 'ref function',
    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',
    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +
        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'
};
function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
        res = args ? fn(...args) : fn();
    }
    catch (err) {
        handleError(err, instance, type);
    }
    return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (dist_shared_esm_bundler_isFunction(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && shared_esm_bundler_isPromise(res)) {
            res.catch(err => {
                handleError(err, instance, type);
            });
        }
        return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
}
function handleError(err, instance, type) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        // the exposed instance is the render proxy to keep it consistent with 2.x
        const exposedInstance = instance.proxy;
        // in production the hook receives only the error code
        const errorInfo = ( false) ? undefined : type;
        while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
                for (let i = 0; i < errorCapturedHooks.length; i++) {
                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo)) {
                        return;
                    }
                }
            }
            cur = cur.parent;
        }
        // app-level handling
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);
            return;
        }
    }
    logError(err, type, contextVNode);
}
function logError(err, type, contextVNode) {
    // default behavior is crash in prod & test, recover in dev.
    if (false) {}
    else {
        throw err;
    }
}

const queue = [];
const postFlushCbs = [];
const runtime_core_esm_bundler_p = Promise.resolve();
let isFlushing = false;
let isFlushPending = false;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    return fn ? runtime_core_esm_bundler_p.then(fn) : runtime_core_esm_bundler_p;
}
function queueJob(job) {
    if (!queue.includes(job)) {
        queue.push(job);
        queueFlush();
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > -1) {
        queue[i] = null;
    }
}
function queuePostFlushCb(cb) {
    if (!dist_shared_esm_bundler_isArray(cb)) {
        postFlushCbs.push(cb);
    }
    else {
        postFlushCbs.push(...cb);
    }
    queueFlush();
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        nextTick(flushJobs);
    }
}
function flushPostFlushCbs(seen) {
    if (postFlushCbs.length) {
        const cbs = [...new Set(postFlushCbs)];
        postFlushCbs.length = 0;
        if ((false)) {}
        for (let i = 0; i < cbs.length; i++) {
            if ((false)) {}
            cbs[i]();
        }
    }
}
const getId = (job) => (job.id == null ? Infinity : job.id);
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    let job;
    if ((false)) {}
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child so its render effect will have smaller
    //    priority number)
    // 2. If a component is unmounted during a parent component's update,
    //    its update can be skipped.
    // Jobs can never be null before flush starts, since they are only invalidated
    // during execution of another flushed job.
    queue.sort((a, b) => getId(a) - getId(b));
    while ((job = queue.shift()) !== undefined) {
        if (job === null) {
            continue;
        }
        if ((false)) {}
        callWithErrorHandling(job, null, 14 /* SCHEDULER */);
    }
    flushPostFlushCbs(seen);
    isFlushing = false;
    // some postFlushCb queued jobs!
    // keep flushing until it drains.
    if (queue.length || postFlushCbs.length) {
        flushJobs(seen);
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) {
        seen.set(fn, 1);
    }
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            throw new Error('Maximum recursive updates exceeded. ' +
                "You may have code that is mutating state in your component's " +
                'render function or updated hook or watcher source function.');
        }
        else {
            seen.set(fn, count + 1);
        }
    }
}

// mark the current rendering instance for asset resolution (e.g.
// resolveComponent, resolveDirective) during render
let currentRenderingInstance = null;
function setCurrentRenderingInstance(instance) {
    currentRenderingInstance = instance;
}
// dev only flag to track whether $attrs was used during render.
// If $attrs was used during render then the warning for failed attrs
// fallthrough can be suppressed.
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component, parent, vnode, proxy, withProxy, props, slots, attrs, emit, renderCache } = instance;
    let result;
    currentRenderingInstance = instance;
    if ((false)) {}
    try {
        let fallthroughAttrs;
        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
            // withProxy is a proxy with a different `has` trap only for
            // runtime-compiled render functions using `with` block.
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(instance.render.call(proxyToUse, proxyToUse, renderCache));
            fallthroughAttrs = attrs;
        }
        else {
            // functional
            const render = Component;
            // in dev, mark attrs accessed if optional props (attrs === props)
            if (false) {}
            result = normalizeVNode(render.length > 1
                ? render(props, ( false)
                    ? undefined
                    : { attrs, slots, emit })
                : render(props, null /* we know it doesn't need it */));
            fallthroughAttrs = Component.props ? attrs : getFallthroughAttrs(attrs);
        }
        // attr merging
        // in dev mode, comments are preserved, and it's possible for a template
        // to have comments along side the root element which makes it a fragment
        let root = result;
        let setRoot = undefined;
        if ((false)) {}
        if (Component.inheritAttrs !== false &&
            fallthroughAttrs &&
            Object.keys(fallthroughAttrs).length) {
            if (root.shapeFlag & 1 /* ELEMENT */ ||
                root.shapeFlag & 6 /* COMPONENT */) {
                root = cloneVNode(root, fallthroughAttrs);
            }
            else if (false) {}
        }
        // inherit scopeId
        const parentScopeId = parent && parent.type.__scopeId;
        if (parentScopeId) {
            root = cloneVNode(root, { [parentScopeId]: '' });
        }
        // inherit directives
        if (vnode.dirs) {
            if (false) {}
            root.dirs = vnode.dirs;
        }
        // inherit transition data
        if (vnode.transition) {
            if (false) {}
            root.transition = vnode.transition;
        }
        if (false) {}
        else {
            result = root;
        }
    }
    catch (err) {
        handleError(err, instance, 1 /* RENDER_FUNCTION */);
        result = createVNode(Comment);
    }
    currentRenderingInstance = null;
    return result;
}
const getChildRoot = (vnode) => {
    if (vnode.type !== Fragment) {
        return [vnode, undefined];
    }
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const children = rawChildren.filter(child => {
        return !(isVNode(child) && child.type === Comment);
    });
    if (children.length !== 1) {
        return [vnode, undefined];
    }
    const childRoot = children[0];
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren
        ? dynamicChildren.indexOf(childRoot)
        : null;
    const setRoot = (updatedRoot) => {
        rawChildren[index] = updatedRoot;
        if (dynamicIndex !== null)
            dynamicChildren[dynamicIndex] = updatedRoot;
    };
    return [normalizeVNode(childRoot), setRoot];
};
const getFallthroughAttrs = (attrs) => {
    let res;
    for (const key in attrs) {
        if (key === 'class' || key === 'style' || shared_esm_bundler_isOn(key)) {
            (res || (res = {}))[key] = attrs[key];
        }
    }
    return res;
};
const isElementRoot = (vnode) => {
    return (vnode.shapeFlag & 6 /* COMPONENT */ ||
        vnode.shapeFlag & 1 /* ELEMENT */ ||
        vnode.type === Comment // potential v-if branch switch
    );
};
function shouldUpdateComponent(prevVNode, nextVNode, parentComponent, optimized) {
    const { props: prevProps, children: prevChildren } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    // Parent component's render function was hot-updated. Since this may have
    // caused the child component's slots content to have changed, we need to
    // force the child to update as well.
    if (false) {}
    // force child update for runtime directive or transition on component vnode.
    if (nextVNode.dirs || nextVNode.transition) {
        return true;
    }
    if (patchFlag > 0) {
        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {
            // slot content that references values that might have changed,
            // e.g. in a v-for
            return true;
        }
        if (patchFlag & 16 /* FULL_PROPS */) {
            // presence of this flag indicates props are always non-null
            return hasPropsChanged(prevProps, nextProps);
        }
        else if (patchFlag & 8 /* PROPS */) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key]) {
                    return true;
                }
            }
        }
    }
    else if (!optimized) {
        // this path is only taken by manually written render functions
        // so presence of any children leads to a forced update
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
                return true;
            }
        }
        if (prevProps === nextProps) {
            return false;
        }
        if (!prevProps) {
            return !!nextProps;
        }
        if (!nextProps) {
            return true;
        }
        return hasPropsChanged(prevProps, nextProps);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key]) {
            return true;
        }
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el // HostNode
) {
    while (parent && parent.subTree === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
    }
}

const isSuspense = (type) => type.__isSuspense;
// Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.
const SuspenseImpl = {
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, 
    // platform-specific impl passed from renderer
    rendererInternals) {
        if (n1 == null) {
            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals);
        }
        else {
            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, optimized, rendererInternals);
        }
    },
    hydrate: hydrateSuspense
};
// Force-casted public typing for h and TSX props inference
const Suspense = ( SuspenseImpl
    );
function mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement('div');
    const suspense = (n2.suspense = createSuspenseBoundary(n2, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals));
    // start mounting the content subtree in an off-dom container
    patch(null, suspense.subTree, hiddenContainer, null, parentComponent, suspense, isSVG, optimized);
    // now check if we have encountered any async deps
    if (suspense.deps > 0) {
        // mount the fallback tree
        patch(null, suspense.fallbackTree, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, optimized);
        n2.el = suspense.fallbackTree.el;
    }
    else {
        // Suspense has no async deps. Just resolve.
        suspense.resolve();
    }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, optimized, { p: patch }) {
    const suspense = (n2.suspense = n1.suspense);
    suspense.vnode = n2;
    const { content, fallback } = normalizeSuspenseChildren(n2);
    const oldSubTree = suspense.subTree;
    const oldFallbackTree = suspense.fallbackTree;
    if (!suspense.isResolved) {
        patch(oldSubTree, content, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, optimized);
        if (suspense.deps > 0) {
            // still pending. patch the fallback tree.
            patch(oldFallbackTree, fallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
            isSVG, optimized);
            n2.el = fallback.el;
        }
        // If deps somehow becomes 0 after the patch it means the patch caused an
        // async dep component to unmount and removed its dep. It will cause the
        // suspense to resolve and we don't need to do anything here.
    }
    else {
        // just normal patch inner content as a fragment
        patch(oldSubTree, content, container, anchor, parentComponent, suspense, isSVG, optimized);
        n2.el = content.el;
    }
    suspense.subTree = content;
    suspense.fallbackTree = fallback;
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals, isHydrating = false) {
    /* istanbul ignore if */
    if (false) {}
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode } } = rendererInternals;
    const getCurrentTree = () => suspense.isResolved || suspense.isHydrating
        ? suspense.subTree
        : suspense.fallbackTree;
    const { content, fallback } = normalizeSuspenseChildren(vnode);
    const suspense = {
        vnode,
        parent,
        parentComponent,
        isSVG,
        optimized,
        container,
        hiddenContainer,
        anchor,
        deps: 0,
        subTree: content,
        fallbackTree: fallback,
        isHydrating,
        isResolved: false,
        isUnmounted: false,
        effects: [],
        resolve() {
            if ((false)) {}
            const { vnode, subTree, fallbackTree, effects, parentComponent, container } = suspense;
            if (suspense.isHydrating) {
                suspense.isHydrating = false;
            }
            else {
                // this is initial anchor on mount
                let { anchor } = suspense;
                // unmount fallback tree
                if (fallbackTree.el) {
                    // if the fallback tree was mounted, it may have been moved
                    // as part of a parent suspense. get the latest anchor for insertion
                    anchor = next(fallbackTree);
                    unmount(fallbackTree, parentComponent, suspense, true);
                }
                // move content from off-dom container to actual container
                move(subTree, container, anchor, 0 /* ENTER */);
            }
            const el = (vnode.el = subTree.el);
            // suspense as the root node of a component...
            if (parentComponent && parentComponent.subTree === vnode) {
                parentComponent.vnode.el = el;
                updateHOCHostEl(parentComponent, el);
            }
            // check if there is a pending parent suspense
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while (parent) {
                if (!parent.isResolved) {
                    // found a pending parent suspense, merge buffered post jobs
                    // into that parent
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            // no pending parent suspense, flush all jobs
            if (!hasUnresolvedAncestor) {
                queuePostFlushCb(effects);
            }
            suspense.isResolved = true;
            suspense.effects = [];
            // invoke @resolve event
            const onResolve = vnode.props && vnode.props.onResolve;
            if (dist_shared_esm_bundler_isFunction(onResolve)) {
                onResolve();
            }
        },
        recede() {
            suspense.isResolved = false;
            const { vnode, subTree, fallbackTree, parentComponent, container, hiddenContainer, isSVG, optimized } = suspense;
            // move content tree back to the off-dom container
            const anchor = next(subTree);
            move(subTree, hiddenContainer, null, 1 /* LEAVE */);
            // remount the fallback tree
            patch(null, fallbackTree, container, anchor, parentComponent, null, // fallback tree will not have suspense context
            isSVG, optimized);
            const el = (vnode.el = fallbackTree.el);
            // suspense as the root node of a component...
            if (parentComponent && parentComponent.subTree === vnode) {
                parentComponent.vnode.el = el;
                updateHOCHostEl(parentComponent, el);
            }
            // invoke @recede event
            const onRecede = vnode.props && vnode.props.onRecede;
            if (dist_shared_esm_bundler_isFunction(onRecede)) {
                onRecede();
            }
        },
        move(container, anchor, type) {
            move(getCurrentTree(), container, anchor, type);
            suspense.container = container;
        },
        next() {
            return next(getCurrentTree());
        },
        registerDep(instance, setupRenderEffect) {
            // suspense is already resolved, need to recede.
            // use queueJob so it's handled synchronously after patching the current
            // suspense tree
            if (suspense.isResolved) {
                queueJob(() => {
                    suspense.recede();
                });
            }
            const hydratedEl = instance.vnode.el;
            suspense.deps++;
            instance
                .asyncDep.catch(err => {
                handleError(err, instance, 0 /* SETUP_FUNCTION */);
            })
                .then(asyncSetupResult => {
                // retry when the setup() promise resolves.
                // component may have been unmounted before resolve.
                if (instance.isUnmounted || suspense.isUnmounted) {
                    return;
                }
                suspense.deps--;
                // retry from this component
                instance.asyncResolved = true;
                const { vnode } = instance;
                if ((false)) {}
                handleSetupResult(instance, asyncSetupResult);
                if (hydratedEl) {
                    // vnode may have been replaced if an update happened before the
                    // async dep is resolved.
                    vnode.el = hydratedEl;
                }
                setupRenderEffect(instance, vnode, 
                // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                hydratedEl
                    ? parentNode(hydratedEl)
                    : parentNode(instance.subTree.el), 
                // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
                updateHOCHostEl(instance, vnode.el);
                if ((false)) {}
                if (suspense.deps === 0) {
                    suspense.resolve();
                }
            });
        },
        unmount(parentSuspense, doRemove) {
            suspense.isUnmounted = true;
            unmount(suspense.subTree, parentComponent, parentSuspense, doRemove);
            if (!suspense.isResolved) {
                unmount(suspense.fallbackTree, parentComponent, parentSuspense, doRemove);
            }
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, optimized, rendererInternals, hydrateNode) {
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, optimized, rendererInternals, true /* hydrating */));
    // there are two possible scenarios for server-rendered suspense:
    // - success: ssr content should be fully resolved
    // - failure: ssr content should be the fallback branch.
    // however, on the client we don't really know if it has failed or not
    // attempt to hydrate the DOM assuming it has succeeded, but we still
    // need to construct a suspense boundary first
    const result = hydrateNode(node, suspense.subTree, parentComponent, suspense, optimized);
    if (suspense.deps === 0) {
        suspense.resolve();
    }
    return result;
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    if (shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const { default: d, fallback } = children;
        return {
            content: normalizeVNode(dist_shared_esm_bundler_isFunction(d) ? d() : d),
            fallback: normalizeVNode(dist_shared_esm_bundler_isFunction(fallback) ? fallback() : fallback)
        };
    }
    else {
        return {
            content: normalizeVNode(children),
            fallback: normalizeVNode(null)
        };
    }
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && !suspense.isResolved) {
        if (dist_shared_esm_bundler_isArray(fn)) {
            suspense.effects.push(...fn);
        }
        else {
            suspense.effects.push(fn);
        }
    }
    else {
        queuePostFlushCb(fn);
    }
}

/**
 * Wrap a slot function to memoize current rendering instance
 * @internal
 */
function withCtx(fn, ctx = currentRenderingInstance) {
    if (!ctx)
        return fn;
    return function renderFnWithContext() {
        const owner = currentRenderingInstance;
        setCurrentRenderingInstance(ctx);
        const res = fn.apply(null, arguments);
        setCurrentRenderingInstance(owner);
        return res;
    };
}

// SFC scoped style ID management.
let currentScopeId = null;
const scopeIdStack = [];
/**
 * @internal
 */
function pushScopeId(id) {
    scopeIdStack.push((currentScopeId = id));
}
/**
 * @internal
 */
function popScopeId() {
    scopeIdStack.pop();
    currentScopeId = scopeIdStack[scopeIdStack.length - 1] || null;
}
/**
 * @internal
 */
function withScopeId(id) {
    return ((fn) => withCtx(function () {
        pushScopeId(id);
        const res = fn.apply(this, arguments);
        popScopeId();
        return res;
    }));
}

const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');
const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if (shared_esm_bundler_isString(targetSelector)) {
        if (!select) {
            ( false) &&
                false;
            return null;
        }
        else {
            const target = select(targetSelector);
            if (!target) {
                ( false) &&
                    false;
            }
            return target;
        }
    }
    else {
        if (false) {}
        return targetSelector;
    }
};
const TeleportImpl = {
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        const { shapeFlag, children } = n2;
        if (n1 == null) {
            // insert anchors in the main view
            const placeholder = (n2.el = ( false)
                ? undefined
                : createText(''));
            const mainAnchor = (n2.anchor = ( false)
                ? undefined
                : createText(''));
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = (n2.target = resolveTarget(n2.props, querySelector));
            const targetAnchor = (n2.targetAnchor = createText(''));
            if (target) {
                insert(targetAnchor, target);
            }
            else if ((false)) {}
            const mount = (container, anchor) => {
                // Teleport *always* has Array children. This is enforced in both the
                // compiler and vnode children normalization.
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                }
            };
            if (disabled) {
                mount(container, mainAnchor);
            }
            else if (target) {
                mount(target, targetAnchor);
            }
        }
        else {
            // update content
            n2.el = n1.el;
            const mainAnchor = (n2.anchor = n1.anchor);
            const target = (n2.target = n1.target);
            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            if (n2.dynamicChildren) {
                // fast path when the teleport happens to be a block root
                patchBlockChildren(n1.dynamicChildren, n2.dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG);
            }
            else if (!optimized) {
                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG);
            }
            if (disabled) {
                if (!wasDisabled) {
                    // enabled -> disabled
                    // move into main container
                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);
                }
            }
            else {
                // target changed
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));
                    if (nextTarget) {
                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);
                    }
                    else if ((false)) {}
                }
                else if (wasDisabled) {
                    // disabled -> enabled
                    // move into teleport target
                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);
                }
            }
        }
    },
    remove(vnode, { r: remove, o: { remove: hostRemove } }) {
        const { shapeFlag, children, anchor } = vnode;
        hostRemove(anchor);
        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
            for (let i = 0; i < children.length; i++) {
                remove(children[i]);
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {
    // move target anchor if this is a target change.
    if (moveType === 0 /* TARGET_CHANGE */) {
        insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2 /* REORDER */;
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(el, container, parentAnchor);
    }
    // if this is a re-order and teleport is enabled (content is in target)
    // do not move children. So the opposite is: only move children if this
    // is not a reorder, or the teleport is disabled
    if (!isReorder || isTeleportDisabled(props)) {
        // Teleport has either Array children or no children.
        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, parentAnchor, 2 /* REORDER */);
            }
        }
    }
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(anchor, container, parentAnchor);
    }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = (vnode.target = resolveTarget(vnode.props, querySelector));
    if (target) {
        // if multiple teleports rendered to the same target element, we need to
        // pick up from where the last teleport finished instead of the first node
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, optimized);
                vnode.targetAnchor = targetNode;
            }
            else {
                vnode.anchor = nextSibling(node);
                vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, optimized);
            }
            target._lpa = nextSibling(vnode.targetAnchor);
        }
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
// Force-casted public typing for h and TSX props inference
const Teleport = TeleportImpl;

const COMPONENTS = 'components';
const DIRECTIVES = 'directives';
function resolveComponent(name) {
    return resolveAsset(COMPONENTS, name) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component) {
    if (shared_esm_bundler_isString(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
    }
    else {
        // invalid types will fallthrough to createVNode and raise warning
        return component || NULL_DYNAMIC_COMPONENT;
    }
}
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true) {
    const instance = currentRenderingInstance || runtime_core_esm_bundler_currentInstance;
    if (instance) {
        let camelized, capitalized;
        const registry = instance[type];
        let res = registry[name] ||
            registry[(camelized = dist_shared_esm_bundler_camelize(name))] ||
            registry[(capitalized = shared_esm_bundler_capitalize(camelized))];
        if (!res && type === COMPONENTS) {
            const self = instance.type;
            const selfName = self.displayName || self.name;
            if (selfName &&
                (selfName === name ||
                    selfName === camelized ||
                    selfName === capitalized)) {
                res = self;
            }
        }
        if ((false)) {}
        return res;
    }
    else if ((false)) {}
}

const Fragment = Symbol(( false) ? undefined : undefined);
const Text = Symbol(( false) ? undefined : undefined);
const Comment = Symbol(( false) ? undefined : undefined);
const Static = Symbol(( false) ? undefined : undefined);
// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
const blockStack = [];
let currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @internal
 */
function openBlock(disableTracking = false) {
    blockStack.push((currentBlock = disableTracking ? null : []));
}
// Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)
let runtime_core_esm_bundler_shouldTrack = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @internal
 */
function setBlockTracking(value) {
    runtime_core_esm_bundler_shouldTrack += value;
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @internal
 */
function createBlock(type, props, children, patchFlag, dynamicProps) {
    const vnode = createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */);
    // save current block children on the block vnode
    vnode.dynamicChildren = currentBlock || shared_esm_bundler_EMPTY_ARR;
    // close block
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
    // a block is always going to be patched, so track it as a child of its
    // parent block
    if (currentBlock) {
        currentBlock.push(vnode);
    }
    return vnode;
}
function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (false) {}
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
    return _createVNode(...(vnodeArgsTransformer
        ? vnodeArgsTransformer(args, currentRenderingInstance)
        : args));
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref }) => (ref != null
    ? dist_shared_esm_bundler_isArray(ref)
        ? ref
        : [currentRenderingInstance, ref]
    : null);
const createVNode = (( false)
    ? undefined
    : _createVNode);
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (false) {}
        type = Comment;
    }
    // class component normalization.
    if (dist_shared_esm_bundler_isFunction(type) && '__vccOpts' in type) {
        type = type.__vccOpts;
    }
    // class & style normalization.
    if (props) {
        // for reactive or proxy objects, we need to clone it to enable mutation.
        if (isProxy(props) || InternalObjectKey in props) {
            props = shared_esm_bundler_extend({}, props);
        }
        let { class: klass, style } = props;
        if (klass && !shared_esm_bundler_isString(klass)) {
            props.class = shared_esm_bundler_normalizeClass(klass);
        }
        if (shared_esm_bundler_isObject(style)) {
            // reactive state objects need to be cloned since they are likely to be
            // mutated
            if (isProxy(style) && !dist_shared_esm_bundler_isArray(style)) {
                style = shared_esm_bundler_extend({}, style);
            }
            props.style = shared_esm_bundler_normalizeStyle(style);
        }
    }
    // encode the vnode type information into a bitmap
    const shapeFlag = shared_esm_bundler_isString(type)
        ? 1 /* ELEMENT */
        :  isSuspense(type)
            ? 128 /* SUSPENSE */
            : isTeleport(type)
                ? 64 /* TELEPORT */
                : shared_esm_bundler_isObject(type)
                    ? 4 /* STATEFUL_COMPONENT */
                    : dist_shared_esm_bundler_isFunction(type)
                        ? 2 /* FUNCTIONAL_COMPONENT */
                        : 0;
    if (false) {}
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        children: null,
        component: null,
        suspense: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null
    };
    normalizeChildren(vnode, children);
    // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    if (runtime_core_esm_bundler_shouldTrack > 0 &&
        !isBlockNode &&
        currentBlock &&
        // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        patchFlag !== 32 /* HYDRATE_EVENTS */ &&
        (patchFlag > 0 ||
            shapeFlag & 128 /* SUSPENSE */ ||
            shapeFlag & 64 /* TELEPORT */ ||
            shapeFlag & 4 /* STATEFUL_COMPONENT */ ||
            shapeFlag & 2 /* FUNCTIONAL_COMPONENT */)) {
        currentBlock.push(vnode);
    }
    return vnode;
}
function cloneVNode(vnode, extraProps) {
    const props = (extraProps
        ? vnode.props
            ? runtime_core_esm_bundler_mergeProps(vnode.props, extraProps)
            : shared_esm_bundler_extend({}, extraProps)
        : vnode.props);
    // This is intentionally NOT using spread or extend to avoid the runtime
    // key enumeration cost.
    return {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: vnode.scopeId,
        children: vnode.children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to bail out of optimized mode.
        // however we don't want block nodes to de-opt their children, so if the
        // vnode is a block node, we only add the FULL_PROPS flag to it.
        patchFlag: extraProps
            ? vnode.dynamicChildren
                ? vnode.patchFlag | 16 /* FULL_PROPS */
                : -2 /* BAIL */
            : vnode.patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        el: vnode.el,
        anchor: vnode.anchor
    };
}
/**
 * @internal
 */
function createTextVNode(text = ' ', flag = 0) {
    return createVNode(Text, null, text, flag);
}
/**
 * @internal
 */
function createStaticVNode(content, numberOfNodes) {
    // A static vnode can contain multiple stringified elements, and the number
    // of elements is necessary for hydration.
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
/**
 * @internal
 */
function createCommentVNode(text = '', 
// when used as the v-else branch, the comment node must be created as a
// block to ensure correct updates.
asBlock = false) {
    return asBlock
        ? (openBlock(), createBlock(Comment, null, text))
        : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === 'boolean') {
        // empty placeholder
        return createVNode(Comment);
    }
    else if (dist_shared_esm_bundler_isArray(child)) {
        // fragment
        return createVNode(Fragment, null, child);
    }
    else if (typeof child === 'object') {
        // already vnode, this should be the most common since compiled templates
        // always produce all-vnode children arrays
        return child.el === null ? child : cloneVNode(child);
    }
    else {
        // strings and numbers
        return createVNode(Text, null, String(child));
    }
}
// optimized normalization for template-compiled render fns
function cloneIfMounted(child) {
    return child.el === null ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
        children = null;
    }
    else if (dist_shared_esm_bundler_isArray(children)) {
        type = 16 /* ARRAY_CHILDREN */;
    }
    else if (typeof children === 'object') {
        // Normalize slot to plain children
        if ((shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) &&
            children.default) {
            normalizeChildren(vnode, children.default());
            return;
        }
        else {
            type = 32 /* SLOTS_CHILDREN */;
            if (!children._ && !(InternalObjectKey in children)) {
                children._ctx = currentRenderingInstance;
            }
        }
    }
    else if (dist_shared_esm_bundler_isFunction(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32 /* SLOTS_CHILDREN */;
    }
    else {
        children = String(children);
        // force teleport children to array so it can be moved around
        if (shapeFlag & 64 /* TELEPORT */) {
            type = 16 /* ARRAY_CHILDREN */;
            children = [createTextVNode(children)];
        }
        else {
            type = 8 /* TEXT_CHILDREN */;
        }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
const handlersRE = /^on|^vnode/;
function runtime_core_esm_bundler_mergeProps(...args) {
    const ret = {};
    shared_esm_bundler_extend(ret, args[0]);
    for (let i = 1; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
            if (key === 'class') {
                if (ret.class !== toMerge.class) {
                    ret.class = shared_esm_bundler_normalizeClass([ret.class, toMerge.class]);
                }
            }
            else if (key === 'style') {
                ret.style = shared_esm_bundler_normalizeStyle([ret.style, toMerge.style]);
            }
            else if (handlersRE.test(key)) {
                // on*, vnode*
                const existing = ret[key];
                const incoming = toMerge[key];
                if (existing !== incoming) {
                    ret[key] = existing
                        ? [].concat(existing, toMerge[key])
                        : incoming;
                }
            }
            else {
                ret[key] = toMerge[key];
            }
        }
    }
    return ret;
}

function runtime_core_esm_bundler_emit(instance, event, ...args) {
    const props = instance.vnode.props || shared_esm_bundler_EMPTY_OBJ;
    if ((false)) {}
    let handler = props[`on${shared_esm_bundler_capitalize(event)}`];
    // for v-model update:xxx events, also trigger kebab-case equivalent
    // for props passed via kebab-case
    if (!handler && event.startsWith('update:')) {
        event = shared_esm_bundler_hyphenate(event);
        handler = props[`on${shared_esm_bundler_capitalize(event)}`];
    }
    if (handler) {
        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
}
function normalizeEmitsOptions(options) {
    if (!options) {
        return;
    }
    else if (dist_shared_esm_bundler_isArray(options)) {
        if (options._n) {
            return options._n;
        }
        const normalized = {};
        options.forEach(key => (normalized[key] = null));
        dist_shared_esm_bundler_def(options, '_n', normalized);
        return normalized;
    }
    else {
        return options;
    }
}
// Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.
function isEmitListener(emits, key) {
    return (shared_esm_bundler_isOn(key) &&
        (dist_shared_esm_bundler_hasOwn((emits = normalizeEmitsOptions(emits)), key[2].toLowerCase() + key.slice(3)) ||
            dist_shared_esm_bundler_hasOwn(emits, key.slice(2))));
}

function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison
isSSR = false) {
    const props = {};
    const attrs = {};
    dist_shared_esm_bundler_def(attrs, InternalObjectKey, 1);
    setFullProps(instance, rawProps, props, attrs);
    const options = instance.type.props;
    // validation
    if (false) {}
    if (isStateful) {
        // stateful
        instance.props = isSSR ? props : shallowReactive(props);
    }
    else {
        if (!options) {
            // functional w/ optional props, props === attrs
            instance.props = attrs;
        }
        else {
            // functional w/ declared props
            instance.props = props;
        }
    }
    instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawOptions = instance.type.props;
    const rawCurrentProps = toRaw(props);
    const { 0: options } = normalizePropsOptions(rawOptions);
    if ((optimized || patchFlag > 0) && !(patchFlag & 16 /* FULL_PROPS */)) {
        if (patchFlag & 8 /* PROPS */) {
            // Compiler-generated props & no keys change, just set the updated
            // the props.
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                // PROPS flag guarantees rawProps to be non-null
                const value = rawProps[key];
                if (options) {
                    // attr / props separation was done on init and will be consistent
                    // in this code path, so just check if attrs have it.
                    if (dist_shared_esm_bundler_hasOwn(attrs, key)) {
                        attrs[key] = value;
                    }
                    else {
                        const camelizedKey = dist_shared_esm_bundler_camelize(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value);
                    }
                }
                else {
                    attrs[key] = value;
                }
            }
        }
    }
    else {
        // full props update.
        setFullProps(instance, rawProps, props, attrs);
        // in case of dynamic props, check if we need to delete keys from
        // the props object
        let kebabKey;
        for (const key in rawCurrentProps) {
            if (!rawProps ||
                (!dist_shared_esm_bundler_hasOwn(rawProps, key) &&
                    // it's possible the original props was passed in as kebab-case
                    // and converted to camelCase (#955)
                    ((kebabKey = shared_esm_bundler_hyphenate(key)) === key || !dist_shared_esm_bundler_hasOwn(rawProps, kebabKey)))) {
                if (options) {
                    if (rawPrevProps && rawPrevProps[kebabKey] !== undefined) {
                        props[key] = resolvePropValue(options, rawProps || shared_esm_bundler_EMPTY_OBJ, key, undefined);
                    }
                }
                else {
                    delete props[key];
                }
            }
        }
        // in the case of functional component w/o props declaration, props and
        // attrs point to the same object so it should already have been updated.
        if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
                if (!rawProps || !dist_shared_esm_bundler_hasOwn(rawProps, key)) {
                    delete attrs[key];
                }
            }
        }
    }
    if (false) {}
}
function setFullProps(instance, rawProps, props, attrs) {
    const { 0: options, 1: needCastKeys } = normalizePropsOptions(instance.type.props);
    const emits = instance.type.emits;
    if (rawProps) {
        for (const key in rawProps) {
            const value = rawProps[key];
            // key, ref are reserved and never passed down
            if (shared_esm_bundler_isReservedProp(key)) {
                continue;
            }
            // prop option names are camelized during normalization, so to support
            // kebab -> camel conversion here we need to camelize the key.
            let camelKey;
            if (options && dist_shared_esm_bundler_hasOwn(options, (camelKey = dist_shared_esm_bundler_camelize(key)))) {
                props[camelKey] = value;
            }
            else if (!emits || !isEmitListener(emits, key)) {
                // Any non-declared (either as a prop or an emitted event) props are put
                // into a separate `attrs` object for spreading. Make sure to preserve
                // original key casing
                attrs[key] = value;
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, rawCurrentProps[key]);
        }
    }
}
function resolvePropValue(options, props, key, value) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = dist_shared_esm_bundler_hasOwn(opt, 'default');
        // default values
        if (hasDefault && value === undefined) {
            const defaultValue = opt.default;
            value = dist_shared_esm_bundler_isFunction(defaultValue) ? defaultValue() : defaultValue;
        }
        // boolean casting
        if (opt[0 /* shouldCast */]) {
            if (!dist_shared_esm_bundler_hasOwn(props, key) && !hasDefault) {
                value = false;
            }
            else if (opt[1 /* shouldCastTrue */] &&
                (value === '' || value === shared_esm_bundler_hyphenate(key))) {
                value = true;
            }
        }
    }
    return value;
}
function normalizePropsOptions(raw) {
    if (!raw) {
        return shared_esm_bundler_EMPTY_ARR;
    }
    if (raw._n) {
        return raw._n;
    }
    const normalized = {};
    const needCastKeys = [];
    if (dist_shared_esm_bundler_isArray(raw)) {
        for (let i = 0; i < raw.length; i++) {
            if (false) {}
            const normalizedKey = dist_shared_esm_bundler_camelize(raw[i]);
            if (validatePropName(normalizedKey)) {
                normalized[normalizedKey] = shared_esm_bundler_EMPTY_OBJ;
            }
        }
    }
    else {
        if (false) {}
        for (const key in raw) {
            const normalizedKey = dist_shared_esm_bundler_camelize(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = (normalized[normalizedKey] =
                    dist_shared_esm_bundler_isArray(opt) || dist_shared_esm_bundler_isFunction(opt) ? { type: opt } : opt);
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* shouldCast */] = booleanIndex > -1;
                    prop[1 /* shouldCastTrue */] =
                        stringIndex < 0 || booleanIndex < stringIndex;
                    // if the prop needs boolean casting or default value
                    if (booleanIndex > -1 || dist_shared_esm_bundler_hasOwn(prop, 'default')) {
                        needCastKeys.push(normalizedKey);
                    }
                }
            }
        }
    }
    const normalizedEntry = [normalized, needCastKeys];
    dist_shared_esm_bundler_def(raw, '_n', normalizedEntry);
    return normalizedEntry;
}
// use function string name to check type constructors
// so that it works across vms / iframes.
function runtime_core_esm_bundler_getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : '';
}
function isSameType(a, b) {
    return runtime_core_esm_bundler_getType(a) === runtime_core_esm_bundler_getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if (dist_shared_esm_bundler_isArray(expectedTypes)) {
        for (let i = 0, len = expectedTypes.length; i < len; i++) {
            if (isSameType(expectedTypes[i], type)) {
                return i;
            }
        }
    }
    else if (dist_shared_esm_bundler_isFunction(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
}
function validateProps(props, rawOptions) {
    const rawValues = toRaw(props);
    const options = normalizePropsOptions(rawOptions)[0];
    for (const key in options) {
        let opt = options[key];
        if (opt == null)
            continue;
        validateProp(key, rawValues[key], opt, !dist_shared_esm_bundler_hasOwn(rawValues, key));
    }
}
function validatePropName(key) {
    if (key[0] !== '$') {
        return true;
    }
    else if ((false)) {}
    return false;
}
function validateProp(name, value, prop, isAbsent) {
    const { type, required, validator } = prop;
    // required!
    if (required && isAbsent) {
        runtime_core_esm_bundler_warn('Missing required prop: "' + name + '"');
        return;
    }
    // missing but optional
    if (value == null && !prop.required) {
        return;
    }
    // type check
    if (type != null && type !== true) {
        let isValid = false;
        const types = dist_shared_esm_bundler_isArray(type) ? type : [type];
        const expectedTypes = [];
        // value is valid as long as one of the specified types match
        for (let i = 0; i < types.length && !isValid; i++) {
            const { valid, expectedType } = assertType(value, types[i]);
            expectedTypes.push(expectedType || '');
            isValid = valid;
        }
        if (!isValid) {
            runtime_core_esm_bundler_warn(getInvalidTypeMessage(name, value, expectedTypes));
            return;
        }
    }
    // custom validator
    if (validator && !validator(value)) {
        runtime_core_esm_bundler_warn('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
}
const isSimpleType = /*#__PURE__*/ shared_esm_bundler_makeMap('String,Number,Boolean,Function,Symbol');
function assertType(value, type) {
    let valid;
    const expectedType = runtime_core_esm_bundler_getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    }
    else if (expectedType === 'Object') {
        valid = shared_esm_bundler_toRawType(value) === 'Object';
    }
    else if (expectedType === 'Array') {
        valid = dist_shared_esm_bundler_isArray(value);
    }
    else {
        valid = value instanceof type;
    }
    return {
        valid,
        expectedType
    };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}".` +
        ` Expected ${expectedTypes.map(shared_esm_bundler_capitalize).join(', ')}`;
    const expectedType = expectedTypes[0];
    const receivedType = shared_esm_bundler_toRawType(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        !isBoolean(expectedType, receivedType)) {
        message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += `with value ${receivedValue}.`;
    }
    return message;
}
function styleValue(value, type) {
    if (type === 'String') {
        return `"${value}"`;
    }
    else if (type === 'Number') {
        return `${Number(value)}`;
    }
    else {
        return `${value}`;
    }
}
function isExplicable(type) {
    const explicitTypes = ['string', 'number', 'boolean'];
    return explicitTypes.some(elem => type.toLowerCase() === elem);
}
function isBoolean(...args) {
    return args.some(elem => elem.toLowerCase() === 'boolean');
}

const isInternalKey = (key) => key[0] === '_' || key === '$stable';
const normalizeSlotValue = (value) => dist_shared_esm_bundler_isArray(value)
    ? value.map(normalizeVNode)
    : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => withCtx((props) => {
    if (false) {}
    return normalizeSlotValue(rawSlot(props));
}, ctx);
const normalizeObjectSlots = (rawSlots, slots) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
        if (isInternalKey(key))
            continue;
        const value = rawSlots[key];
        if (dist_shared_esm_bundler_isFunction(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
        }
        else if (value != null) {
            if ((false)) {}
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children) => {
    if (false) {}
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        if (children._ === 1) {
            instance.slots = children;
        }
        else {
            normalizeObjectSlots(children, (instance.slots = {}));
        }
    }
    else {
        instance.slots = {};
        if (children) {
            normalizeVNodeSlots(instance, children);
        }
    }
    dist_shared_esm_bundler_def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = shared_esm_bundler_EMPTY_OBJ;
    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        if (children._ === 1) {
            // compiled slots.
            if (
            // bail on dynamic slots (v-if, v-for, reference of scope variables)
            !(vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) &&
                // bail on HRM updates
                !( false && false)) {
                // compiled AND static.
                // no need to update, and skip stale slots removal.
                needDeletionCheck = false;
            }
            else {
                // compiled but dynamic - update slots, but skip normalization.
                shared_esm_bundler_extend(slots, children);
            }
        }
        else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    }
    else if (children) {
        // non slot object children (direct value) passed to a component
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
    }
    // delete stale slots
    if (needDeletionCheck) {
        for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
                delete slots[key];
            }
        }
    }
};

/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/
const isBuiltInDirective = /*#__PURE__*/ shared_esm_bundler_makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text');
function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
        runtime_core_esm_bundler_warn('Do not use built-in directive ids as custom directive id: ' + name);
    }
}
/**
 * Adds directives to a VNode.
 */
function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
        ( false) && false;
        return vnode;
    }
    const instance = internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = shared_esm_bundler_EMPTY_OBJ] = directives[i];
        if (dist_shared_esm_bundler_isFunction(dir)) {
            dir = {
                mounted: dir,
                updated: dir
            };
        }
        bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
        });
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
        }
        const hook = binding.dir[name];
        if (hook) {
            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
        }
    }
}

function createAppContext() {
    return {
        config: {
            isNativeTag: shared_esm_bundler_NO,
            devtools: true,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            isCustomElement: shared_esm_bundler_NO,
            errorHandler: undefined,
            warnHandler: undefined
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null)
    };
}
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (rootProps != null && !shared_esm_bundler_isObject(rootProps)) {
            ( false) && false;
            rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = new Set();
        let isMounted = false;
        const app = {
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            get config() {
                return context.config;
            },
            set config(v) {
                if ((false)) {}
            },
            use(plugin, ...options) {
                if (installedPlugins.has(plugin)) {
                    ( false) && false;
                }
                else if (plugin && dist_shared_esm_bundler_isFunction(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                }
                else if (dist_shared_esm_bundler_isFunction(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                }
                else if ((false)) {}
                return app;
            },
            mixin(mixin) {
                {
                    if (!context.mixins.includes(mixin)) {
                        context.mixins.push(mixin);
                    }
                    else if ((false)) {}
                }
                return app;
            },
            component(name, component) {
                if ((false)) {}
                if (!component) {
                    return context.components[name];
                }
                if (false) {}
                context.components[name] = component;
                return app;
            },
            directive(name, directive) {
                if ((false)) {}
                if (!directive) {
                    return context.directives[name];
                }
                if (false) {}
                context.directives[name] = directive;
                return app;
            },
            mount(rootContainer, isHydrate) {
                if (!isMounted) {
                    const vnode = createVNode(rootComponent, rootProps);
                    // store app context on the root VNode.
                    // this will be set on the root instance on initial mount.
                    vnode.appContext = context;
                    // HMR root reload
                    if ((false)) {}
                    if (isHydrate && hydrate) {
                        hydrate(vnode, rootContainer);
                    }
                    else {
                        render(vnode, rootContainer);
                    }
                    isMounted = true;
                    app._container = rootContainer;
                    return vnode.component.proxy;
                }
                else if ((false)) {}
            },
            unmount() {
                if (isMounted) {
                    render(null, app._container);
                }
                else if ((false)) {}
            },
            provide(key, value) {
                if (false) {}
                // TypeScript doesn't allow symbols as index type
                // https://github.com/Microsoft/TypeScript/issues/24587
                context.provides[key] = value;
                return app;
            }
        };
        return app;
    };
}

// Expose the HMR runtime on the global object
// This makes it entirely tree-shakable without polluting the exports and makes
// it easier to be used in toolings like vue-loader
// Note: for a component to be eligible for HMR it also needs the __hmrId option
// to be set so that its instances can be registered / removed.
if ((false)) {}
const map = new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).delete(instance);
}
function createRecord(id, comp) {
    if (map.has(id)) {
        return false;
    }
    map.set(id, new Set());
    return true;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record)
        return;
    // Array.from creates a snapshot which avoids the set being mutated during
    // updates
    Array.from(record).forEach(instance => {
        if (newRender) {
            instance.render = newRender;
        }
        instance.renderCache = [];
        // this flag forces child components with slot content to update
        instance.renderUpdated = true;
        instance.update();
        instance.renderUpdated = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
        return;
    // Array.from creates a snapshot which avoids the set being mutated during
    // updates
    Array.from(record).forEach(instance => {
        const comp = instance.type;
        if (!comp.__hmrUpdated) {
            // 1. Update existing comp definition to match new one
            Object.assign(comp, newComp);
            for (const key in comp) {
                if (!(key in newComp)) {
                    delete comp[key];
                }
            }
            // 2. Mark component dirty. This forces the renderer to replace the component
            // on patch.
            comp.__hmrUpdated = true;
            // 3. Make sure to unmark the component after the reload.
            queuePostFlushCb(() => {
                comp.__hmrUpdated = false;
            });
        }
        if (instance.parent) {
            // 4. Force the parent instance to re-render. This will cause all updated
            // components to be unmounted and re-mounted. Queue the update so that we
            // don't end up forcing the same parent to re-render multiple times.
            queueJob(instance.parent.update);
        }
        else if (instance.appContext.reload) {
            // root instance mounted via createApp() has a reload method
            instance.appContext.reload();
        }
        else if (typeof window !== 'undefined') {
            // root instance inside tree created via raw render(). Force reload.
            window.location.reload();
        }
        else {
            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
        }
    });
}
function tryWrap(fn) {
    return (id, arg) => {
        try {
            return fn(id, arg);
        }
        catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +
                `Full reload required.`);
        }
    };
}

let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
const isComment = (node) => node.nodeType === 8 /* COMMENT */;
// Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
    const hydrate = (vnode, container) => {
        if (false) {}
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null);
        flushPostFlushCbs();
        if (hasMismatch && !false) {
            // this error should show up in production
            console.error(`Hydration completed but contains mismatches.`);
        }
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, optimized = false) => {
        const isFragmentStart = isComment(node) && node.data === '[';
        const onMismatch = () => handleMismtach(node, vnode, parentComponent, parentSuspense, isFragmentStart);
        const { type, shapeFlag } = vnode;
        const domType = node.nodeType;
        vnode.el = node;
        switch (type) {
            case Text:
                if (domType !== 3 /* TEXT */) {
                    return onMismatch();
                }
                if (node.data !== vnode.children) {
                    hasMismatch = true;
                    ( false) &&
                        false;
                    node.data = vnode.children;
                }
                return nextSibling(node);
            case Comment:
                if (domType !== 8 /* COMMENT */ || isFragmentStart) {
                    return onMismatch();
                }
                return nextSibling(node);
            case Static:
                if (domType !== 1 /* ELEMENT */) {
                    return onMismatch();
                }
                // determine anchor, adopt content
                let cur = node;
                // if the static vnode has its content stripped during build,
                // adopt it from the server-rendered HTML.
                const needToAdoptContent = !vnode.children.length;
                for (let i = 0; i < vnode.staticCount; i++) {
                    if (needToAdoptContent)
                        vnode.children += cur.outerHTML;
                    if (i === vnode.staticCount - 1) {
                        vnode.anchor = cur;
                    }
                    cur = nextSibling(cur);
                }
                return cur;
            case Fragment:
                if (!isFragmentStart) {
                    return onMismatch();
                }
                return hydrateFragment(node, vnode, parentComponent, parentSuspense, optimized);
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    if (domType !== 1 /* ELEMENT */ ||
                        vnode.type !== node.tagName.toLowerCase()) {
                        return onMismatch();
                    }
                    return hydrateElement(node, vnode, parentComponent, parentSuspense, optimized);
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    // when setting up the render effect, if the initial vnode already
                    // has .el set, the component will perform hydration instead of mount
                    // on its sub-tree.
                    const container = parentNode(node);
                    const hydrateComponent = () => {
                        mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                    };
                    // async component
                    const loadAsync = vnode.type.__asyncLoader;
                    if (loadAsync) {
                        loadAsync().then(hydrateComponent);
                    }
                    else {
                        hydrateComponent();
                    }
                    // component may be async, so in the case of fragments we cannot rely
                    // on component's rendered output to determine the end of the fragment
                    // instead, we do a lookahead to find the end anchor node.
                    return isFragmentStart
                        ? locateClosingAsyncAnchor(node)
                        : nextSibling(node);
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    if (domType !== 8 /* COMMENT */) {
                        return onMismatch();
                    }
                    return vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, optimized, rendererInternals, hydrateChildren);
                }
                else if ( shapeFlag & 128 /* SUSPENSE */) {
                    return vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), optimized, rendererInternals, hydrateNode);
                }
                else if ((false)) {}
                return null;
        }
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const { props, patchFlag, shapeFlag, dirs } = vnode;
        // skip props & children if this is hoisted static nodes
        if (patchFlag !== -1 /* HOISTED */) {
            // props
            if (props) {
                if (!optimized ||
                    (patchFlag & 16 /* FULL_PROPS */ ||
                        patchFlag & 32 /* HYDRATE_EVENTS */)) {
                    for (const key in props) {
                        if (!shared_esm_bundler_isReservedProp(key) && shared_esm_bundler_isOn(key)) {
                            patchProp(el, key, null, props[key]);
                        }
                    }
                }
                else if (props.onClick) {
                    // Fast path for click listeners (which is most often) to avoid
                    // iterating through props.
                    patchProp(el, 'onClick', null, props.onClick);
                }
            }
            // vnode / directive hooks
            let vnodeHooks;
            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
            }
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
                queueEffectWithSuspense(() => {
                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
                }, parentSuspense);
            }
            // children
            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&
                // skip if element has innerHTML / textContent
                !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, optimized);
                let hasWarned = false;
                while (next) {
                    hasMismatch = true;
                    if (false) {}
                    // The SSRed DOM contains more nodes than it should. Remove them.
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            }
            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    ( false) &&
                        false;
                    el.textContent = vnode.children;
                }
            }
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, vnode, container, parentComponent, parentSuspense, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const children = vnode.children;
        const l = children.length;
        let hasWarned = false;
        for (let i = 0; i < l; i++) {
            const vnode = optimized
                ? children[i]
                : (children[i] = normalizeVNode(children[i]));
            if (node) {
                node = hydrateNode(node, vnode, parentComponent, parentSuspense, optimized);
            }
            else {
                hasMismatch = true;
                if (false) {}
                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.
                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container));
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, optimized) => {
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, optimized);
        if (next && isComment(next) && next.data === ']') {
            return nextSibling((vnode.anchor = next));
        }
        else {
            // fragment didn't hydrate successfully, since we didn't get a end anchor
            // back. This should have led to node/children mismatch warnings.
            hasMismatch = true;
            // since the anchor is missing, we need to create one and insert it
            insert((vnode.anchor = createComment(`]`)), container, next);
            return next;
        }
    };
    const handleMismtach = (node, vnode, parentComponent, parentSuspense, isFragment) => {
        hasMismatch = true;
        ( false) &&
            false;
        vnode.el = null;
        if (isFragment) {
            // remove excessive fragment nodes
            const end = locateClosingAsyncAnchor(node);
            while (true) {
                const next = nextSibling(node);
                if (next && next !== end) {
                    remove(next);
                }
                else {
                    break;
                }
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container));
        return next;
    };
    const locateClosingAsyncAnchor = (node) => {
        let match = 0;
        while (node) {
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === '[')
                    match++;
                if (node.data === ']') {
                    if (match === 0) {
                        return nextSibling(node);
                    }
                    else {
                        match--;
                    }
                }
            }
        }
        return node;
    };
    return [hydrate, hydrateNode];
}

let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        perf.mark(`vue-${type}-${instance.uid}`);
    }
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
}
function isSupported() {
    if (supported !== undefined) {
        return supported;
    }
    if (typeof window !== 'undefined' && window.performance) {
        supported = true;
        perf = window.performance;
    }
    else {
        supported = false;
    }
    return supported;
}

const prodEffectOptions = {
    scheduler: queueJob
};
function createDevEffectOptions(instance) {
    return {
        scheduler: queueJob,
        onTrack: instance.rtc ? e => shared_esm_bundler_invokeArrayFns(instance.rtc, e) : void 0,
        onTrigger: instance.rtg ? e => shared_esm_bundler_invokeArrayFns(instance.rtg, e) : void 0
    };
}
const queuePostRenderEffect =  queueEffectWithSuspense
    ;
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */
function createRenderer(options) {
    return baseCreateRenderer(options);
}
// Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
// implementation
function baseCreateRenderer(options, createHydrationFns) {
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = shared_esm_bundler_NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
    // Note: functions inside this closure should use `const xxx = () => {}`
    // style in order to prevent being inlined by minifiers.
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) => {
        // patching & not same type, unmount old tree
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2 /* BAIL */) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch (type) {
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) {
                    mountStaticNode(n2, container, anchor, isSVG);
                }
                else if ((false)) {}
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);
                }
                else if ( shapeFlag & 128 /* SUSPENSE */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);
                }
                else if ((false)) {}
        }
        // set ref
        if (ref != null && parentComponent) {
            const refValue = shapeFlag & 4 /* STATEFUL_COMPONENT */ ? n2.component.proxy : n2.el;
            setRef(ref, n1 && n1.ref, parentComponent, refValue);
        }
    };
    const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);
        }
        else {
            const el = (n2.el = n1.el);
            if (n2.children !== n1.children) {
                hostSetText(el, n2.children);
            }
        }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);
        }
        else {
            // there's no support for dynamic comments
            n2.el = n1.el;
        }
    };
    const mountStaticNode = (n2, container, anchor, isSVG) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    };
    /**
     * Dev / HMR only
     */
    const patchStaticNode = (n1, n2, container, isSVG) => {
        // static nodes are only patched during dev for HMR
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            // remove existing
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
        }
        else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    /**
     * Dev / HMR only
     */
    const moveStaticNode = (vnode, container, anchor) => {
        let cur = vnode.el;
        const end = vnode.anchor;
        while (cur && cur !== end) {
            const next = hostNextSibling(cur);
            hostInsert(cur, container, anchor);
            cur = next;
        }
        hostInsert(end, container, anchor);
    };
    /**
     * Dev / HMR only
     */
    const removeStaticNode = (vnode) => {
        let cur = vnode.el;
        while (cur && cur !== vnode.anchor) {
            const next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(vnode.anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        isSVG = isSVG || n2.type === 'svg';
        if (n1 == null) {
            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        }
        else {
            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);
        }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, scopeId, patchFlag, dirs } = vnode;
        if (vnode.el &&
            hostCloneNode !== undefined &&
            patchFlag === -1 /* HOISTED */) {
            // If a vnode has non-null el, it means it's being reused.
            // Only static vnodes can be reused, so its mounted DOM nodes should be
            // exactly the same, and we can simply do a clone here.
            el = vnode.el = hostCloneNode(vnode.el);
        }
        else {
            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is);
            // props
            if (props) {
                for (const key in props) {
                    if (!shared_esm_bundler_isReservedProp(key)) {
                        hostPatchProp(el, key, null, props[key], isSVG);
                    }
                }
                if ((vnodeHook = props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parentComponent, vnode);
                }
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
            }
            // scopeId
            if (scopeId) {
                hostSetScopeId(el, scopeId);
            }
            const treeOwnerId = parentComponent && parentComponent.type.__scopeId;
            // vnode's own scopeId and the current patched component's scopeId is
            // different - this is a slot content node.
            if (treeOwnerId && treeOwnerId !== scopeId) {
                hostSetScopeId(el, treeOwnerId + '-s');
            }
            // children
            if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                hostSetElementText(el, vnode.children);
            }
            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', optimized || !!vnode.dynamicChildren);
            }
            if (transition && !transition.persisted) {
                transition.beforeEnter(el);
            }
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) ||
            (transition && !transition.persisted) ||
            dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                transition && !transition.persisted && transition.enter(el);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
            }, parentSuspense);
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
            const child = (children[i] = optimized
                ? cloneIfMounted(children[i])
                : normalizeVNode(children[i]));
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, optimized) => {
        const el = (n2.el = n1.el);
        let { patchFlag, dynamicChildren, dirs } = n2;
        const oldProps = (n1 && n1.props) || shared_esm_bundler_EMPTY_OBJ;
        const newProps = n2.props || shared_esm_bundler_EMPTY_OBJ;
        let vnodeHook;
        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
        }
        if (false) {}
        if (patchFlag > 0) {
            // the presence of a patchFlag means this element's render code was
            // generated by the compiler and can take the fast path.
            // in this path old node and new node are guaranteed to have the same shape
            // (i.e. at the exact same position in the source template)
            if (patchFlag & 16 /* FULL_PROPS */) {
                // element props contain dynamic keys, full diff needed
                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            }
            else {
                // class
                // this flag is matched when the element has dynamic class bindings.
                if (patchFlag & 2 /* CLASS */) {
                    if (oldProps.class !== newProps.class) {
                        hostPatchProp(el, 'class', null, newProps.class, isSVG);
                    }
                }
                // style
                // this flag is matched when the element has dynamic style bindings
                if (patchFlag & 4 /* STYLE */) {
                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
                }
                // props
                // This flag is matched when the element has dynamic prop/attr bindings
                // other than class and style. The keys of dynamic prop/attrs are saved for
                // faster iteration.
                // Note dynamic keys like :[foo]="bar" will cause this optimization to
                // bail out and go through a full diff because we need to unset the old key
                if (patchFlag & 8 /* PROPS */) {
                    // if the flag is present then dynamicProps must be non-null
                    const propsToUpdate = n2.dynamicProps;
                    for (let i = 0; i < propsToUpdate.length; i++) {
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        if (prev !== next) {
                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                        }
                    }
                }
            }
            // text
            // This flag is matched when the element has only dynamic text children.
            if (patchFlag & 1 /* TEXT */) {
                if (n1.children !== n2.children) {
                    hostSetElementText(el, n2.children);
                }
            }
        }
        else if (!optimized && dynamicChildren == null) {
            // unoptimized, full diff
            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        }
        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG);
            if (false) {}
        }
        else if (!optimized) {
            // full diff
            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
            }, parentSuspense);
        }
    };
    // The fast path for blocks.
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG) => {
        for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            // Determine the container (parent element) for the patch.
            const container = 
            // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            oldVNode.type === Fragment ||
                // - In the case of different nodes, there is going to be a replacement
                // which also requires the correct parent container
                !isSameVNodeType(oldVNode, newVNode) ||
                // - In the case of a component, it could contain anything.
                oldVNode.shapeFlag & 6 /* COMPONENT */
                ? hostParentNode(oldVNode.el)
                : // In other cases, the parent container is not actually used so we
                    // just pass the block element here to avoid a DOM parentNode call.
                    fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
        if (oldProps !== newProps) {
            for (const key in newProps) {
                if (shared_esm_bundler_isReservedProp(key))
                    continue;
                const next = newProps[key];
                const prev = oldProps[key];
                if (next !== prev) {
                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                }
            }
            if (oldProps !== shared_esm_bundler_EMPTY_OBJ) {
                for (const key in oldProps) {
                    if (!shared_esm_bundler_isReservedProp(key) && !(key in newProps)) {
                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));
        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));
        let { patchFlag, dynamicChildren } = n2;
        if (patchFlag > 0) {
            optimized = true;
        }
        if (false) {}
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            // a fragment can only have array children
            // since they are either generated by the compiler, or implicitly created
            // from arrays.
            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);
        }
        else {
            if (patchFlag > 0 &&
                patchFlag & 64 /* STABLE_FRAGMENT */ &&
                dynamicChildren) {
                // a stable fragment (template root or <template v-for>) doesn't need to
                // patch children order, but it may contain dynamicChildren.
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG);
                if (false) {}
            }
            else {
                // keyed / unkeyed, or manual fragments.
                // for keyed & unkeyed, since they are compiler generated from v-for,
                // each child is guaranteed to be a block so the fragment will never
                // have dynamicChildren.
                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);
            }
        }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        if (n1 == null) {
            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
            }
            else {
                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
            }
        }
        else {
            updateComponent(n1, n2, parentComponent, optimized);
        }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));
        if (false) {}
        if ((false)) {}
        // inject renderer internals for keepAlive
        if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
        }
        // resolve props and slots for setup context
        if ((false)) {}
        setupComponent(instance);
        if ((false)) {}
        // setup() is async. This component relies on async logic to be resolved
        // before proceeding
        if ( instance.asyncDep) {
            if (!parentSuspense) {
                if ((false))
                    {}
                return;
            }
            parentSuspense.registerDep(instance, setupRenderEffect);
            // Give it a placeholder if this is not hydration
            if (!initialVNode.el) {
                const placeholder = (instance.subTree = createVNode(Comment));
                processCommentNode(null, placeholder, container, anchor);
            }
            return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
        if ((false)) {}
    };
    const updateComponent = (n1, n2, parentComponent, optimized) => {
        const instance = (n2.component = n1.component);
        if (shouldUpdateComponent(n1, n2, parentComponent, optimized)) {
            if (
                instance.asyncDep &&
                !instance.asyncResolved) {
                // async & still pending - just update props and slots
                // since the component's reactive effect for render isn't set-up yet
                if ((false)) {}
                updateComponentPreRender(instance, n2, optimized);
                if ((false)) {}
                return;
            }
            else {
                // normal update
                instance.next = n2;
                // in case the child component is also queued, remove it to avoid
                // double updating the same child component in the same flush.
                invalidateJob(instance.update);
                // instance.update is the reactive effect runner.
                instance.update();
            }
        }
        else {
            // no update needed. just copy over properties
            n2.component = n1.component;
            n2.el = n1.el;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
        // create reactive effect for rendering
        instance.update = reactivity_esm_bundler_effect(function componentEffect() {
            if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, a, parent } = instance;
                if ((false)) {}
                const subTree = (instance.subTree = renderComponentRoot(instance));
                if ((false)) {}
                // beforeMount hook
                if (bm) {
                    shared_esm_bundler_invokeArrayFns(bm);
                }
                // onVnodeBeforeMount
                if ((vnodeHook = props && props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parent, initialVNode);
                }
                if (el && hydrateNode) {
                    if ((false)) {}
                    // vnode has adopted host node - perform hydration instead of mount.
                    hydrateNode(initialVNode.el, subTree, instance, parentSuspense);
                    if ((false)) {}
                }
                else {
                    if ((false)) {}
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    if ((false)) {}
                    initialVNode.el = subTree.el;
                }
                // mounted hook
                if (m) {
                    queuePostRenderEffect(m, parentSuspense);
                }
                // onVnodeMounted
                if ((vnodeHook = props && props.onVnodeMounted)) {
                    queuePostRenderEffect(() => {
                        invokeVNodeHook(vnodeHook, parent, initialVNode);
                    }, parentSuspense);
                }
                // activated hook for keep-alive roots.
                if (a &&
                    initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
                    queuePostRenderEffect(a, parentSuspense);
                }
                instance.isMounted = true;
            }
            else {
                // updateComponent
                // This is triggered by mutation of component's own state (next: null)
                // OR parent calling processComponent (next: VNode)
                let { next, bu, u, parent, vnode } = instance;
                let vnodeHook;
                if ((false)) {}
                if (next) {
                    updateComponentPreRender(instance, next, optimized);
                }
                else {
                    next = vnode;
                }
                if ((false)) {}
                const nextTree = renderComponentRoot(instance);
                if ((false)) {}
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                next.el = vnode.el;
                // beforeUpdate hook
                if (bu) {
                    shared_esm_bundler_invokeArrayFns(bu);
                }
                // onVnodeBeforeUpdate
                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
                    invokeVNodeHook(vnodeHook, parent, next, vnode);
                }
                // reset refs
                // only needed if previous patch had refs
                if (instance.refs !== shared_esm_bundler_EMPTY_OBJ) {
                    instance.refs = {};
                }
                if ((false)) {}
                patch(prevTree, nextTree, 
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), 
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                if ((false)) {}
                next.el = nextTree.el;
                if (next === null) {
                    // self-triggered update. In case of HOC, update parent component
                    // vnode el. HOC is indicated by parent instance's subTree pointing
                    // to child component's vnode
                    updateHOCHostEl(instance, nextTree.el);
                }
                // updated hook
                if (u) {
                    queuePostRenderEffect(u, parentSuspense);
                }
                // onVnodeUpdated
                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
                    queuePostRenderEffect(() => {
                        invokeVNodeHook(vnodeHook, parent, next, vnode);
                    }, parentSuspense);
                }
                if ((false)) {}
            }
        }, ( false) ? undefined : prodEffectOptions);
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
        if (false) {}
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children);
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        // fast path
        if (patchFlag > 0) {
            if (patchFlag & 128 /* KEYED_FRAGMENT */) {
                // this could be either fully-keyed or mixed (some keyed some not)
                // presence of patchFlag means children are guaranteed to be arrays
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                return;
            }
            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {
                // unkeyed
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                return;
            }
        }
        // children has 3 possibilities: text, array or no children.
        if (shapeFlag & 8 /* TEXT_CHILDREN */) {
            // text children fast path
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
                hostSetElementText(container, c2);
            }
        }
        else {
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                // prev children was array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    // two arrays, cannot assume anything, do full diff
                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                }
                else {
                    // no new children, just unmount old
                    unmountChildren(c1, parentComponent, parentSuspense, true);
                }
            }
            else {
                // prev children was text OR null
                // new children is array OR null
                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {
                    hostSetElementText(container, '');
                }
                // mount new if array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                }
            }
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        c1 = c1 || shared_esm_bundler_EMPTY_ARR;
        c2 = c2 || shared_esm_bundler_EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
            const nextChild = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, optimized);
        }
        if (oldLength > newLength) {
            // remove old
            unmountChildren(c1, parentComponent, parentSuspense, true, commonLength);
        }
        else {
            // mount new
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, commonLength);
        }
    };
    // can be all-keyed or mixed
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1; // prev ending index
        let e2 = l2 - 1; // next ending index
        // 1. sync from start
        // (a b) c
        // (a b) d e
        while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);
            }
            else {
                break;
            }
            i++;
        }
        // 2. sync from end
        // a (b c)
        // d e (b c)
        while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = (c2[e2] = optimized
                ? cloneIfMounted(c2[e2])
                : normalizeVNode(c2[e2]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);
            }
            else {
                break;
            }
            e1--;
            e2--;
        }
        // 3. common sequence + mount
        // (a b)
        // (a b) c
        // i = 2, e1 = 1, e2 = 2
        // (a b)
        // c (a b)
        // i = 0, e1 = -1, e2 = 0
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while (i <= e2) {
                    patch(null, (c2[i] = optimized
                        ? cloneIfMounted(c2[i])
                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG);
                    i++;
                }
            }
        }
        // 4. common sequence + unmount
        // (a b) c
        // (a b)
        // i = 2, e1 = 2, e2 = 1
        // a (b c)
        // (b c)
        // i = 0, e1 = 0, e2 = -1
        else if (i > e2) {
            while (i <= e1) {
                unmount(c1[i], parentComponent, parentSuspense, true);
                i++;
            }
        }
        // 5. unknown sequence
        // [i ... e1 + 1]: a b [c d e] f g
        // [i ... e2 + 1]: a b [e d c h] f g
        // i = 2, e1 = 4, e2 = 5
        else {
            const s1 = i; // prev starting index
            const s2 = i; // next starting index
            // 5.1 build key:index map for newChildren
            const keyToNewIndexMap = new Map();
            for (i = s2; i <= e2; i++) {
                const nextChild = (c2[i] = optimized
                    ? cloneIfMounted(c2[i])
                    : normalizeVNode(c2[i]));
                if (nextChild.key != null) {
                    if (false) {}
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            // 5.2 loop through old children left to be patched and try to patch
            // matching nodes & remove nodes that are no longer present
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            // used to track whether any node has moved
            let maxNewIndexSoFar = 0;
            // works as Map<newIndex, oldIndex>
            // Note that oldIndex is offset by +1
            // and oldIndex = 0 is a special value indicating the new node has
            // no corresponding old node.
            // used for determining longest stable subsequence
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++)
                newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    // all new children have been patched so this can only be a removal
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) {
                    newIndex = keyToNewIndexMap.get(prevChild.key);
                }
                else {
                    // key-less node, try to locate a key-less node of the same type
                    for (j = s2; j <= e2; j++) {
                        if (newIndexToOldIndexMap[j - s2] === 0 &&
                            isSameVNodeType(prevChild, c2[j])) {
                            newIndex = j;
                            break;
                        }
                    }
                }
                if (newIndex === undefined) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                }
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) {
                        maxNewIndexSoFar = newIndex;
                    }
                    else {
                        moved = true;
                    }
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, optimized);
                    patched++;
                }
            }
            // 5.3 move and mount
            // generate longest stable subsequence only when nodes have moved
            const increasingNewIndexSequence = moved
                ? getSequence(newIndexToOldIndexMap)
                : shared_esm_bundler_EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            // looping backwards so that we can use last patched node as anchor
            for (i = toBePatched - 1; i >= 0; i--) {
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) {
                    // mount new
                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG);
                }
                else if (moved) {
                    // move if:
                    // There is no stable subsequence (e.g. a reverse)
                    // OR current node is not among the stable sequence
                    if (j < 0 || i !== increasingNewIndexSequence[j]) {
                        move(nextChild, container, anchor, 2 /* REORDER */);
                    }
                    else {
                        j--;
                    }
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6 /* COMPONENT */) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if ( shapeFlag & 128 /* SUSPENSE */) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64 /* TELEPORT */) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        // static node move can only happen when force updating HMR
        if (false) {}
        // single nodes
        const needTransition = moveType !== 2 /* REORDER */ &&
            shapeFlag & 1 /* ELEMENT */ &&
            transition;
        if (needTransition) {
            if (moveType === 0 /* ENTER */) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            }
            else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove = () => hostInsert(el, container, anchor);
                const performLeave = () => {
                    leave(el, () => {
                        remove();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) {
                    delayLeave(el, remove, performLeave);
                }
                else {
                    performLeave();
                }
            }
        }
        else {
            hostInsert(el, container, anchor);
        }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false) => {
        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;
        const shouldKeepAlive = shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
        let vnodeHook;
        // unset ref
        if (ref != null && parentComponent) {
            setRef(ref, null, parentComponent, null);
        }
        if ((vnodeHook = props && props.onVnodeBeforeUnmount) && !shouldKeepAlive) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6 /* COMPONENT */) {
            if (shouldKeepAlive) {
                parentComponent.ctx.deactivate(vnode);
            }
            else {
                unmountComponent(vnode.component, parentSuspense, doRemove);
            }
        }
        else {
            if ( shapeFlag & 128 /* SUSPENSE */) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
            }
            if (dynamicChildren &&
                // #1153: fast path should not be taken for non-stable (v-for) fragments
                (type !== Fragment ||
                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {
                // fast path for block nodes: only need to unmount dynamic children.
                unmountChildren(dynamicChildren, parentComponent, parentSuspense);
            }
            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                unmountChildren(children, parentComponent, parentSuspense);
            }
            // an unmounted teleport should always remove its children
            if (shapeFlag & 64 /* TELEPORT */) {
                vnode.type.remove(vnode, internals);
            }
            if (doRemove) {
                remove(vnode);
            }
        }
        if (((vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) &&
            !shouldKeepAlive) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                shouldInvokeDirs &&
                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
            }, parentSuspense);
        }
    };
    const remove = vnode => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
            removeFragment(el, anchor);
            return;
        }
        if (false) {}
        const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
                transition.afterLeave();
            }
        };
        if (vnode.shapeFlag & 1 /* ELEMENT */ &&
            transition &&
            !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
                delayLeave(vnode.el, performRemove, performLeave);
            }
            else {
                performLeave();
            }
        }
        else {
            performRemove();
        }
    };
    const removeFragment = (cur, end) => {
        // For fragments, directly remove all contained DOM nodes.
        // (fragment child nodes cannot have transition)
        let next;
        while (cur !== end) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
        if (false) {}
        const { bum, effects, update, subTree, um, da, isDeactivated } = instance;
        // beforeUnmount hook
        if (bum) {
            shared_esm_bundler_invokeArrayFns(bum);
        }
        if (effects) {
            for (let i = 0; i < effects.length; i++) {
                reactivity_esm_bundler_stop(effects[i]);
            }
        }
        // update may be null if a component is unmounted before its async
        // setup has resolved.
        if (update) {
            reactivity_esm_bundler_stop(update);
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        // unmounted hook
        if (um) {
            queuePostRenderEffect(um, parentSuspense);
        }
        // deactivated hook
        if (da &&
            !isDeactivated &&
            instance.vnode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
            queuePostRenderEffect(da, parentSuspense);
        }
        queuePostRenderEffect(() => {
            instance.isUnmounted = true;
        }, parentSuspense);
        // A component with async dep inside a pending suspense is unmounted before
        // its async dep resolves. This should remove the dep from the suspense, and
        // cause the suspense to resolve immediately if that was the last dep.
        if (
            parentSuspense &&
            !parentSuspense.isResolved &&
            !parentSuspense.isUnmounted &&
            instance.asyncDep &&
            !instance.asyncResolved) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
                parentSuspense.resolve();
            }
        }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove);
        }
    };
    const getNextHostNode = vnode => {
        if (vnode.shapeFlag & 6 /* COMPONENT */) {
            return getNextHostNode(vnode.component.subTree);
        }
        if ( vnode.shapeFlag & 128 /* SUSPENSE */) {
            return vnode.suspense.next();
        }
        return hostNextSibling((vnode.anchor || vnode.el));
    };
    const setRef = (rawRef, oldRawRef, parent, value) => {
        const [owner, ref] = rawRef;
        if (false) {}
        const oldRef = oldRawRef && oldRawRef[1];
        const refs = owner.refs === shared_esm_bundler_EMPTY_OBJ ? (owner.refs = {}) : owner.refs;
        const setupState = owner.setupState;
        // unset old ref
        if (oldRef != null && oldRef !== ref) {
            if (shared_esm_bundler_isString(oldRef)) {
                refs[oldRef] = null;
                if (dist_shared_esm_bundler_hasOwn(setupState, oldRef)) {
                    setupState[oldRef] = null;
                }
            }
            else if (isRef(oldRef)) {
                oldRef.value = null;
            }
        }
        if (shared_esm_bundler_isString(ref)) {
            refs[ref] = value;
            if (dist_shared_esm_bundler_hasOwn(setupState, ref)) {
                setupState[ref] = value;
            }
        }
        else if (isRef(ref)) {
            ref.value = value;
        }
        else if (dist_shared_esm_bundler_isFunction(ref)) {
            callWithErrorHandling(ref, parent, 12 /* FUNCTION_REF */, [value, refs]);
        }
        else if ((false)) {}
    };
    /**
     * #1156
     * When a component is HMR-enabled, we need to make sure that all static nodes
     * inside a block also inherit the DOM element from the previous tree so that
     * HMR updates (which are full updates) can retrieve the element for patching.
     *
     * Dev only.
     */
    const traverseStaticChildren = (n1, n2) => {
        const ch1 = n1.children;
        const ch2 = n2.children;
        if (dist_shared_esm_bundler_isArray(ch1) && dist_shared_esm_bundler_isArray(ch2)) {
            for (let i = 0; i < ch1.length; i++) {
                const c1 = ch1[i];
                const c2 = ch2[i];
                if (isVNode(c1) &&
                    isVNode(c2) &&
                    c2.shapeFlag & 1 /* ELEMENT */ &&
                    !c2.dynamicChildren) {
                    if (c2.patchFlag <= 0) {
                        c2.el = c1.el;
                    }
                    traverseStaticChildren(c1, c2);
                }
            }
        }
    };
    const render = (vnode, container) => {
        if (vnode == null) {
            if (container._vnode) {
                unmount(container._vnode, null, null, true);
            }
        }
        else {
            patch(container._vnode || null, vnode, container);
        }
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(internals);
    }
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [
        vnode,
        prevVNode
    ]);
}
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function getSequence(arr) {
    const p = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
                c = ((u + v) / 2) | 0;
                if (arr[result[c]] < arrI) {
                    u = c + 1;
                }
                else {
                    v = c;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
        result[u] = v;
        v = p[v];
    }
    return result;
}

function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: new Map()
    };
    onMounted(() => {
        state.isMounted = true;
    });
    onBeforeUnmount(() => {
        state.isUnmounting = true;
    });
    return state;
}
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: Function,
        onEnter: Function,
        onAfterEnter: Function,
        onEnterCancelled: Function,
        // leave
        onBeforeLeave: Function,
        onLeave: Function,
        onAfterLeave: Function,
        onLeaveCancelled: Function
    },
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        return () => {
            const children = slots.default && slots.default();
            if (!children || !children.length) {
                return;
            }
            // warn multiple elements
            if (false) {}
            // there's no need to track reactivity for these props so use the raw
            // props for a bit better perf
            const rawProps = toRaw(props);
            const { mode } = rawProps;
            // check mode
            if (false) {}
            // at this point children has a guaranteed length of 1.
            const child = children[0];
            if (state.isLeaving) {
                return emptyPlaceholder(child);
            }
            // in the case of <transition><keep-alive/></transition>, we need to
            // compare the type of the kept-alive children.
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
                return emptyPlaceholder(child);
            }
            const enterHooks = (innerChild.transition = resolveTransitionHooks(innerChild, rawProps, state, instance));
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            // handle mode
            if (oldInnerChild &&
                oldInnerChild.type !== Comment &&
                !isSameVNodeType(innerChild, oldInnerChild)) {
                const prevHooks = oldInnerChild.transition;
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                // update old tree's hooks in case of dynamic transition
                setTransitionHooks(oldInnerChild, leavingHooks);
                // switching between different views
                if (mode === 'out-in') {
                    state.isLeaving = true;
                    // return placeholder node and queue update when leave finishes
                    leavingHooks.afterLeave = () => {
                        state.isLeaving = false;
                        instance.update();
                    };
                    return emptyPlaceholder(child);
                }
                else if (mode === 'in-out') {
                    delete prevHooks.delayedLeave;
                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                        // early removal callback
                        el._leaveCb = () => {
                            earlyRemove();
                            el._leaveCb = undefined;
                            delete enterHooks.delayedLeave;
                        };
                        enterHooks.delayedLeave = delayedLeave;
                    };
                }
            }
            return child;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
// The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.
function resolveTransitionHooks(vnode, { appear, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled }, state, instance) {
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args) => {
        hook &&
            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);
    };
    const hooks = {
        persisted,
        beforeEnter(el) {
            if (!appear && !state.isMounted) {
                return;
            }
            // for same element (v-show)
            if (el._leaveCb) {
                el._leaveCb(true /* cancelled */);
            }
            // for toggled element with same key (v-if)
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode &&
                isSameVNodeType(vnode, leavingVNode) &&
                leavingVNode.el._leaveCb) {
                // force early removal (not cancelled)
                leavingVNode.el._leaveCb();
            }
            callHook(onBeforeEnter, [el]);
        },
        enter(el) {
            if (!appear && !state.isMounted) {
                return;
            }
            let called = false;
            const afterEnter = (el._enterCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                if (cancelled) {
                    callHook(onEnterCancelled, [el]);
                }
                else {
                    callHook(onAfterEnter, [el]);
                }
                if (hooks.delayedLeave) {
                    hooks.delayedLeave();
                }
                el._enterCb = undefined;
            });
            if (onEnter) {
                onEnter(el, afterEnter);
            }
            else {
                afterEnter();
            }
        },
        leave(el, remove) {
            const key = String(vnode.key);
            if (el._enterCb) {
                el._enterCb(true /* cancelled */);
            }
            if (state.isUnmounting) {
                return remove();
            }
            callHook(onBeforeLeave, [el]);
            let called = false;
            const afterLeave = (el._leaveCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                remove();
                if (cancelled) {
                    callHook(onLeaveCancelled, [el]);
                }
                else {
                    callHook(onAfterLeave, [el]);
                }
                el._leaveCb = undefined;
                if (leavingVNodesCache[key] === vnode) {
                    delete leavingVNodesCache[key];
                }
            });
            leavingVNodesCache[key] = vnode;
            if (onLeave) {
                onLeave(el, afterLeave);
            }
            else {
                afterLeave();
            }
        }
    };
    return hooks;
}
// the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode)
        ? vnode.children
            ? vnode.children[0]
            : undefined
        : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
    }
    else {
        vnode.transition = hooks;
    }
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(props, { slots }) {
        const cache = new Map();
        const keys = new Set();
        let current = null;
        const instance = getCurrentInstance();
        const parentSuspense = instance.suspense;
        // KeepAlive communicates with the instantiated renderer via the
        // ctx where the renderer passes in its internals,
        // and the KeepAlive instance exposes activate/deactivate implementations.
        // The whole point of this is to avoid importing KeepAlive directly in the
        // renderer to facilitate tree-shaking.
        const sharedContext = instance.ctx;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement('div');
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
            const child = vnode.component;
            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);
            // in case props have changed
            patch(child.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, optimized);
            queuePostRenderEffect(() => {
                child.isDeactivated = false;
                if (child.a) {
                    shared_esm_bundler_invokeArrayFns(child.a);
                }
            }, parentSuspense);
        };
        sharedContext.deactivate = (vnode) => {
            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);
            queuePostRenderEffect(() => {
                const component = vnode.component;
                if (component.da) {
                    shared_esm_bundler_invokeArrayFns(component.da);
                }
                component.isDeactivated = true;
            }, parentSuspense);
        };
        function unmount(vnode) {
            // reset the shapeFlag so it can be properly unmounted
            vnode.shapeFlag = 4 /* STATEFUL_COMPONENT */;
            _unmount(vnode, instance, parentSuspense);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key) => {
                const name = getName(vnode.type);
                if (name && (!filter || !filter(name))) {
                    pruneCacheEntry(key);
                }
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || cached.type !== current.type) {
                unmount(cached);
            }
            else if (current) {
                // current active instance should no longer be kept-alive.
                // we can't unmount it now but it might be later, so reset its flag now.
                current.shapeFlag = 4 /* STATEFUL_COMPONENT */;
            }
            cache.delete(key);
            keys.delete(key);
        }
        watch(() => [props.include, props.exclude], ([include, exclude]) => {
            include && pruneCache(name => matches(include, name));
            exclude && pruneCache(name => matches(exclude, name));
        });
        onBeforeUnmount(() => {
            cache.forEach(unmount);
        });
        return () => {
            if (!slots.default) {
                return null;
            }
            const children = slots.default();
            let vnode = children[0];
            if (children.length > 1) {
                if ((false)) {}
                current = null;
                return children;
            }
            else if (!isVNode(vnode) ||
                !(vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */)) {
                current = null;
                return vnode;
            }
            const comp = vnode.type;
            const name = getName(comp);
            const { include, exclude, max } = props;
            if ((include && (!name || !matches(include, name))) ||
                (exclude && name && matches(exclude, name))) {
                return vnode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            // clone vnode if it's reused because we are going to mutate it
            if (vnode.el) {
                vnode = cloneVNode(vnode);
            }
            cache.set(key, vnode);
            if (cachedVNode) {
                // copy over mounted state
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) {
                    // recursively update transition hooks on subTree
                    setTransitionHooks(vnode, vnode.transition);
                }
                // avoid vnode being mounted as fresh
                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;
                // make this key the freshest
                keys.delete(key);
                keys.add(key);
            }
            else {
                keys.add(key);
                // prune oldest entry
                if (max && keys.size > parseInt(max, 10)) {
                    pruneCacheEntry(Array.from(keys)[0]);
                }
            }
            // avoid vnode being unmounted
            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
            current = vnode;
            return vnode;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const KeepAlive = KeepAliveImpl;
function getName(comp) {
    return comp.displayName || comp.name;
}
function matches(pattern, name) {
    if (dist_shared_esm_bundler_isArray(pattern)) {
        return pattern.some((p) => matches(p, name));
    }
    else if (shared_esm_bundler_isString(pattern)) {
        return pattern.split(',').indexOf(name) > -1;
    }
    else if (pattern.test) {
        return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);
}
function registerKeepAliveHook(hook, type, target = runtime_core_esm_bundler_currentInstance) {
    // cache the deactivate branch check wrapper for injected hooks so the same
    // hook can be properly deduped by the scheduler. "__wdc" stands for "with
    // deactivation check".
    const wrappedHook = hook.__wdc ||
        (hook.__wdc = () => {
            // only fire the hook if the target instance is NOT in a deactivated branch.
            let current = target;
            while (current) {
                if (current.isDeactivated) {
                    return;
                }
                current = current.parent;
            }
            hook();
        });
    injectHook(type, wrappedHook, target);
    // In addition to registering it on the target instance, we walk up the parent
    // chain and register it on all ancestor instances that are keep-alive roots.
    // This avoids the need to walk the entire component tree when invoking these
    // hooks, and more importantly, avoids the need to track child components in
    // arrays.
    if (target) {
        let current = target.parent;
        while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
                injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    injectHook(type, hook, keepAliveRoot, true /* prepend */);
    onUnmounted(() => {
        dist_shared_esm_bundler_remove(keepAliveRoot[type], hook);
    }, target);
}

function injectHook(type, hook, target = runtime_core_esm_bundler_currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        // cache the error handling wrapper for injected hooks so the same hook
        // can be properly deduped by the scheduler. "__weh" stands for "with error
        // handling".
        const wrappedHook = hook.__weh ||
            (hook.__weh = (...args) => {
                if (target.isUnmounted) {
                    return;
                }
                // disable tracking inside all lifecycle hooks
                // since they can potentially be called inside effects.
                pauseTracking();
                // Set currentInstance during hook invocation.
                // This assumes the hook does not synchronously trigger other hooks, which
                // can only be false when the user does something really funky.
                setCurrentInstance(target);
                const res = callWithAsyncErrorHandling(hook, target, type, args);
                setCurrentInstance(null);
                resetTracking();
                return res;
            });
        if (prepend) {
            hooks.unshift(wrappedHook);
        }
        else {
            hooks.push(wrappedHook);
        }
    }
    else if ((false)) {}
}
const createHook = (lifecycle) => (hook, target = runtime_core_esm_bundler_currentInstance) => 
// post-create lifecycle registrations are noops during SSR
!isInSSRComponentSetup && injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);
const onMounted = createHook("m" /* MOUNTED */);
const onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);
const onUpdated = createHook("u" /* UPDATED */);
const onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);
const onUnmounted = createHook("um" /* UNMOUNTED */);
const onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);
const onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);
const onErrorCaptured = (hook, target = runtime_core_esm_bundler_currentInstance) => {
    injectHook("ec" /* ERROR_CAPTURED */, hook, target);
};

const invoke = (fn) => fn();
// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
// initial value for watchers to trigger on undefined initial values
const INITIAL_WATCHER_VALUE = {};
// implementation
function watch(source, cb, options) {
    if (false) {}
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = shared_esm_bundler_EMPTY_OBJ) {
    if (false) {}
    const warnInvalidSource = (s) => {
        runtime_core_esm_bundler_warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +
            `a reactive object, or an array of these types.`);
    };
    const instance = runtime_core_esm_bundler_currentInstance;
    let getter;
    if (dist_shared_esm_bundler_isArray(source)) {
        getter = () => source.map(s => {
            if (isRef(s)) {
                return s.value;
            }
            else if (isReactive(s)) {
                return traverse(s);
            }
            else if (dist_shared_esm_bundler_isFunction(s)) {
                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);
            }
            else {
                ( false) && false;
            }
        });
    }
    else if (isRef(source)) {
        getter = () => source.value;
    }
    else if (isReactive(source)) {
        getter = () => source;
        deep = true;
    }
    else if (dist_shared_esm_bundler_isFunction(source)) {
        if (cb) {
            // getter with cb
            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);
        }
        else {
            // no cb -> simple effect
            getter = () => {
                if (instance && instance.isUnmounted) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);
            };
        }
    }
    else {
        getter = shared_esm_bundler_NOOP;
        ( false) && false;
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
    }
    let cleanup;
    const onInvalidate = (fn) => {
        cleanup = runner.options.onStop = () => {
            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);
        };
    };
    let oldValue = dist_shared_esm_bundler_isArray(source) ? [] : INITIAL_WATCHER_VALUE;
    const applyCb = cb
        ? () => {
            if (instance && instance.isUnmounted) {
                return;
            }
            const newValue = runner();
            if (deep || shared_esm_bundler_hasChanged(newValue, oldValue)) {
                // cleanup before running cb again
                if (cleanup) {
                    cleanup();
                }
                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onInvalidate
                ]);
                oldValue = newValue;
            }
        }
        : void 0;
    let scheduler;
    if (flush === 'sync') {
        scheduler = invoke;
    }
    else if (flush === 'pre') {
        scheduler = job => {
            if (!instance || instance.isMounted) {
                queueJob(job);
            }
            else {
                // with 'pre' option, the first call must happen before
                // the component is mounted so it is called synchronously.
                job();
            }
        };
    }
    else {
        scheduler = job => queuePostRenderEffect(job, instance && instance.suspense);
    }
    const runner = reactivity_esm_bundler_effect(getter, {
        lazy: true,
        // so it runs before component update effects in pre flush mode
        computed: true,
        onTrack,
        onTrigger,
        scheduler: applyCb ? () => scheduler(applyCb) : scheduler
    });
    recordInstanceBoundEffect(runner);
    // initial run
    if (applyCb) {
        if (immediate) {
            applyCb();
        }
        else {
            oldValue = runner();
        }
    }
    else {
        runner();
    }
    return () => {
        reactivity_esm_bundler_stop(runner);
        if (instance) {
            dist_shared_esm_bundler_remove(instance.effects, runner);
        }
    };
}
// this.$watch
function instanceWatch(source, cb, options) {
    const publicThis = this.proxy;
    const getter = shared_esm_bundler_isString(source)
        ? () => publicThis[source]
        : source.bind(publicThis);
    const stop = watch(getter, cb.bind(publicThis), options);
    onBeforeUnmount(stop, this);
    return stop;
}
function traverse(value, seen = new Set()) {
    if (!shared_esm_bundler_isObject(value) || seen.has(value)) {
        return value;
    }
    seen.add(value);
    if (dist_shared_esm_bundler_isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            traverse(value[i], seen);
        }
    }
    else if (value instanceof Map) {
        value.forEach((v, key) => {
            // to register mutation dep for existing keys
            traverse(value.get(key), seen);
        });
    }
    else if (value instanceof Set) {
        value.forEach(v => {
            traverse(v, seen);
        });
    }
    else {
        for (const key in value) {
            traverse(value[key], seen);
        }
    }
    return value;
}

function provide(key, value) {
    if (!runtime_core_esm_bundler_currentInstance) {
        if ((false)) {}
    }
    else {
        let provides = runtime_core_esm_bundler_currentInstance.provides;
        // by default an instance inherits its parent's provides object
        // but when it needs to provide values of its own, it creates its
        // own provides object using parent provides object as prototype.
        // this way in `inject` we can simply look up injections from direct
        // parent and let the prototype chain do the work.
        const parentProvides = runtime_core_esm_bundler_currentInstance.parent && runtime_core_esm_bundler_currentInstance.parent.provides;
        if (parentProvides === provides) {
            provides = runtime_core_esm_bundler_currentInstance.provides = Object.create(parentProvides);
        }
        // TS doesn't allow symbol as index type
        provides[key] = value;
    }
}
function inject(key, defaultValue) {
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    const instance = runtime_core_esm_bundler_currentInstance || currentRenderingInstance;
    if (instance) {
        const provides = instance.provides;
        if (key in provides) {
            // TS doesn't allow symbol as index type
            return provides[key];
        }
        else if (arguments.length > 1) {
            return defaultValue;
        }
        else if ((false)) {}
    }
    else if ((false)) {}
}

function createDuplicateChecker() {
    const cache = Object.create(null);
    return (type, key) => {
        if (cache[key]) {
            runtime_core_esm_bundler_warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
        }
        else {
            cache[key] = type;
        }
    };
}
function applyOptions(instance, options, deferredData = [], deferredWatch = [], asMixin = false) {
    const { 
    // composition
    mixins, extends: extendsOptions, 
    // state
    props: propsOptions, data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, 
    // assets
    components, directives, 
    // lifecycle
    beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeUnmount, unmounted, renderTracked, renderTriggered, errorCaptured } = options;
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    const globalMixins = instance.appContext.mixins;
    // call it only during dev
    // applyOptions is called non-as-mixin once per instance
    if (!asMixin) {
        callSyncHook('beforeCreate', options, publicThis, globalMixins);
        // global mixins are applied first
        applyMixins(instance, globalMixins, deferredData, deferredWatch);
    }
    // extending a base component...
    if (extendsOptions) {
        applyOptions(instance, extendsOptions, deferredData, deferredWatch, true);
    }
    // local mixins
    if (mixins) {
        applyMixins(instance, mixins, deferredData, deferredWatch);
    }
    const checkDuplicateProperties = ( false) ? undefined : null;
    if (false) {}
    // options initialization order (to be consistent with Vue 2):
    // - props (already done outside of this function)
    // - inject
    // - methods
    // - data (deferred since it relies on `this` access)
    // - computed
    // - watch (deferred since it relies on `this` access)
    if (injectOptions) {
        if (dist_shared_esm_bundler_isArray(injectOptions)) {
            for (let i = 0; i < injectOptions.length; i++) {
                const key = injectOptions[i];
                ctx[key] = inject(key);
                if ((false)) {}
            }
        }
        else {
            for (const key in injectOptions) {
                const opt = injectOptions[key];
                if (shared_esm_bundler_isObject(opt)) {
                    ctx[key] = inject(opt.from, opt.default);
                }
                else {
                    ctx[key] = inject(opt);
                }
                if ((false)) {}
            }
        }
    }
    if (methods) {
        for (const key in methods) {
            const methodHandler = methods[key];
            if (dist_shared_esm_bundler_isFunction(methodHandler)) {
                ctx[key] = methodHandler.bind(publicThis);
                if ((false)) {}
            }
            else if ((false)) {}
        }
    }
    if (dataOptions) {
        if (false) {}
        if (asMixin) {
            deferredData.push(dataOptions);
        }
        else {
            resolveData(instance, dataOptions, publicThis);
        }
    }
    if (!asMixin) {
        if (deferredData.length) {
            deferredData.forEach(dataFn => resolveData(instance, dataFn, publicThis));
        }
        if ((false)) {}
    }
    if (computedOptions) {
        for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get = dist_shared_esm_bundler_isFunction(opt)
                ? opt.bind(publicThis, publicThis)
                : dist_shared_esm_bundler_isFunction(opt.get)
                    ? opt.get.bind(publicThis, publicThis)
                    : shared_esm_bundler_NOOP;
            if (false) {}
            const set = !dist_shared_esm_bundler_isFunction(opt) && dist_shared_esm_bundler_isFunction(opt.set)
                ? opt.set.bind(publicThis)
                : ( false)
                    ? undefined
                    : shared_esm_bundler_NOOP;
            const c = runtime_core_esm_bundler_computed({
                get,
                set
            });
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => c.value,
                set: v => (c.value = v)
            });
            if ((false)) {}
        }
    }
    if (watchOptions) {
        deferredWatch.push(watchOptions);
    }
    if (!asMixin && deferredWatch.length) {
        deferredWatch.forEach(watchOptions => {
            for (const key in watchOptions) {
                createWatcher(watchOptions[key], ctx, publicThis, key);
            }
        });
    }
    if (provideOptions) {
        const provides = dist_shared_esm_bundler_isFunction(provideOptions)
            ? provideOptions.call(publicThis)
            : provideOptions;
        for (const key in provides) {
            provide(key, provides[key]);
        }
    }
    // asset options
    if (components) {
        shared_esm_bundler_extend(instance.components, components);
    }
    if (directives) {
        shared_esm_bundler_extend(instance.directives, directives);
    }
    // lifecycle options
    if (!asMixin) {
        callSyncHook('created', options, publicThis, globalMixins);
    }
    if (beforeMount) {
        onBeforeMount(beforeMount.bind(publicThis));
    }
    if (mounted) {
        onMounted(mounted.bind(publicThis));
    }
    if (beforeUpdate) {
        onBeforeUpdate(beforeUpdate.bind(publicThis));
    }
    if (updated) {
        onUpdated(updated.bind(publicThis));
    }
    if (activated) {
        onActivated(activated.bind(publicThis));
    }
    if (deactivated) {
        onDeactivated(deactivated.bind(publicThis));
    }
    if (errorCaptured) {
        onErrorCaptured(errorCaptured.bind(publicThis));
    }
    if (renderTracked) {
        onRenderTracked(renderTracked.bind(publicThis));
    }
    if (renderTriggered) {
        onRenderTriggered(renderTriggered.bind(publicThis));
    }
    if (beforeUnmount) {
        onBeforeUnmount(beforeUnmount.bind(publicThis));
    }
    if (unmounted) {
        onUnmounted(unmounted.bind(publicThis));
    }
}
function callSyncHook(name, options, ctx, globalMixins) {
    callHookFromMixins(name, globalMixins, ctx);
    const baseHook = options.extends && options.extends[name];
    if (baseHook) {
        baseHook.call(ctx);
    }
    const mixins = options.mixins;
    if (mixins) {
        callHookFromMixins(name, mixins, ctx);
    }
    const selfHook = options[name];
    if (selfHook) {
        selfHook.call(ctx);
    }
}
function callHookFromMixins(name, mixins, ctx) {
    for (let i = 0; i < mixins.length; i++) {
        const fn = mixins[i][name];
        if (fn) {
            fn.call(ctx);
        }
    }
}
function applyMixins(instance, mixins, deferredData, deferredWatch) {
    for (let i = 0; i < mixins.length; i++) {
        applyOptions(instance, mixins[i], deferredData, deferredWatch, true);
    }
}
function resolveData(instance, dataFn, publicThis) {
    const data = dataFn.call(publicThis, publicThis);
    if (false) {}
    if (!shared_esm_bundler_isObject(data)) {
        ( false) && false;
    }
    else if (instance.data === shared_esm_bundler_EMPTY_OBJ) {
        instance.data = reactive(data);
    }
    else {
        // existing data: this is a mixin or extends.
        shared_esm_bundler_extend(instance.data, data);
    }
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = () => publicThis[key];
    if (shared_esm_bundler_isString(raw)) {
        const handler = ctx[raw];
        if (dist_shared_esm_bundler_isFunction(handler)) {
            watch(getter, handler);
        }
        else if ((false)) {}
    }
    else if (dist_shared_esm_bundler_isFunction(raw)) {
        watch(getter, raw.bind(publicThis));
    }
    else if (shared_esm_bundler_isObject(raw)) {
        if (dist_shared_esm_bundler_isArray(raw)) {
            raw.forEach(r => createWatcher(r, ctx, publicThis, key));
        }
        else {
            watch(getter, raw.handler.bind(publicThis), raw);
        }
    }
    else if ((false)) {}
}
function resolveMergedOptions(instance) {
    const raw = instance.type;
    const { __merged, mixins, extends: extendsOptions } = raw;
    if (__merged)
        return __merged;
    const globalMixins = instance.appContext.mixins;
    if (!globalMixins.length && !mixins && !extendsOptions)
        return raw;
    const options = {};
    globalMixins.forEach(m => mergeOptions(options, m, instance));
    extendsOptions && mergeOptions(options, extendsOptions, instance);
    mixins && mixins.forEach(m => mergeOptions(options, m, instance));
    mergeOptions(options, raw, instance);
    return (raw.__merged = options);
}
function mergeOptions(to, from, instance) {
    const strats = instance.appContext.config.optionMergeStrategies;
    for (const key in from) {
        const strat = strats && strats[key];
        if (strat) {
            to[key] = strat(to[key], from[key], instance.proxy, key);
        }
        else if (!dist_shared_esm_bundler_hasOwn(to, key)) {
            to[key] = from[key];
        }
    }
}

const publicPropertiesMap = {
    $: i => i,
    $el: i => i.vnode.el,
    $data: i => i.data,
    $props: i => (( false) ? undefined : i.props),
    $attrs: i => (( false) ? undefined : i.attrs),
    $slots: i => (( false) ? undefined : i.slots),
    $refs: i => (( false) ? undefined : i.refs),
    $parent: i => i.parent && i.parent.proxy,
    $root: i => i.root && i.root.proxy,
    $emit: i => i.emit,
    $options: i => ( resolveMergedOptions(i) ),
    $forceUpdate: i => () => queueJob(i.update),
    $nextTick: () => nextTick,
    $watch:  i => instanceWatch.bind(i) 
};
const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        // let @vue/reatvitiy know it should never observe Vue public instances.
        if (key === "__v_skip" /* skip */) {
            return true;
        }
        // data / props / ctx
        // This getter gets called for every property access on the render context
        // during render and is a major hotspot. The most expensive part of this
        // is the multiple hasOwn() calls. It's much faster to do a simple property
        // access on a plain object, so we use an accessCache object (with null
        // prototype) to memoize what access type a key corresponds to.
        if (key[0] !== '$') {
            const n = accessCache[key];
            if (n !== undefined) {
                switch (n) {
                    case 0 /* SETUP */:
                        return setupState[key];
                    case 1 /* DATA */:
                        return data[key];
                    case 3 /* CONTEXT */:
                        return ctx[key];
                    case 2 /* PROPS */:
                        return props[key];
                    // default: just fallthrough
                }
            }
            else if (setupState !== shared_esm_bundler_EMPTY_OBJ && dist_shared_esm_bundler_hasOwn(setupState, key)) {
                accessCache[key] = 0 /* SETUP */;
                return setupState[key];
            }
            else if (data !== shared_esm_bundler_EMPTY_OBJ && dist_shared_esm_bundler_hasOwn(data, key)) {
                accessCache[key] = 1 /* DATA */;
                return data[key];
            }
            else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            type.props &&
                dist_shared_esm_bundler_hasOwn(normalizePropsOptions(type.props)[0], key)) {
                accessCache[key] = 2 /* PROPS */;
                return props[key];
            }
            else if (ctx !== shared_esm_bundler_EMPTY_OBJ && dist_shared_esm_bundler_hasOwn(ctx, key)) {
                accessCache[key] = 3 /* CONTEXT */;
                return ctx[key];
            }
            else {
                accessCache[key] = 4 /* OTHER */;
            }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        // public $xxx properties
        if (publicGetter) {
            if (false) {}
            return publicGetter(instance);
        }
        else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) &&
            (cssModule = cssModule[key])) {
            return cssModule;
        }
        else if (ctx !== shared_esm_bundler_EMPTY_OBJ && dist_shared_esm_bundler_hasOwn(ctx, key)) {
            // user may set custom properties to `this` that start with `$`
            accessCache[key] = 3 /* CONTEXT */;
            return ctx[key];
        }
        else if (
        // global properties
        ((globalProperties = appContext.config.globalProperties),
            dist_shared_esm_bundler_hasOwn(globalProperties, key))) {
            return globalProperties[key];
        }
        else if (false) {}
    },
    set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (setupState !== shared_esm_bundler_EMPTY_OBJ && dist_shared_esm_bundler_hasOwn(setupState, key)) {
            setupState[key] = value;
        }
        else if (data !== shared_esm_bundler_EMPTY_OBJ && dist_shared_esm_bundler_hasOwn(data, key)) {
            data[key] = value;
        }
        else if (key in instance.props) {
            ( false) &&
                false;
            return false;
        }
        if (key[0] === '$' && key.slice(1) in instance) {
            ( false) &&
                false;
            return false;
        }
        else {
            if (false) {}
            else {
                ctx[key] = value;
            }
        }
        return true;
    },
    has({ _: { data, setupState, accessCache, ctx, type, appContext } }, key) {
        return (accessCache[key] !== undefined ||
            (data !== shared_esm_bundler_EMPTY_OBJ && dist_shared_esm_bundler_hasOwn(data, key)) ||
            (setupState !== shared_esm_bundler_EMPTY_OBJ && dist_shared_esm_bundler_hasOwn(setupState, key)) ||
            (type.props && dist_shared_esm_bundler_hasOwn(normalizePropsOptions(type.props)[0], key)) ||
            dist_shared_esm_bundler_hasOwn(ctx, key) ||
            dist_shared_esm_bundler_hasOwn(publicPropertiesMap, key) ||
            dist_shared_esm_bundler_hasOwn(appContext.config.globalProperties, key));
    }
};
if (false) {}
const RuntimeCompiledPublicInstanceProxyHandlers = {
    ...PublicInstanceProxyHandlers,
    get(target, key) {
        // fast path for unscopables when using `with` block
        if (key === Symbol.unscopables) {
            return;
        }
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_, key) {
        const has = key[0] !== '_' && !shared_esm_bundler_isGloballyWhitelisted(key);
        if (false) {}
        return has;
    }
};
// In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.
function createRenderContext(instance) {
    const target = {};
    // expose internal instance for proxy handlers
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: () => instance
    });
    // expose public properties
    Object.keys(publicPropertiesMap).forEach(key => {
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: () => publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: shared_esm_bundler_NOOP
        });
    });
    // expose global properties
    const { globalProperties } = instance.appContext.config;
    Object.keys(globalProperties).forEach(key => {
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: () => globalProperties[key],
            set: shared_esm_bundler_NOOP
        });
    });
    return target;
}
// dev only
function exposePropsOnRenderContext(instance) {
    const { ctx, type: { props: propsOptions } } = instance;
    if (propsOptions) {
        Object.keys(normalizePropsOptions(propsOptions)[0]).forEach(key => {
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => instance.props[key],
                set: shared_esm_bundler_NOOP
            });
        });
    }
}
// dev only
function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys(toRaw(setupState)).forEach(key => {
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => setupState[key],
            set: shared_esm_bundler_NOOP
        });
    });
}

const emptyAppContext = createAppContext();
let runtime_core_esm_bundler_uid = 0;
function createComponentInstance(vnode, parent, suspense) {
    // inherit parent app context - or - if root, adopt from root vnode
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: runtime_core_esm_bundler_uid++,
        vnode,
        parent,
        appContext,
        type: vnode.type,
        root: null,
        next: null,
        subTree: null,
        update: null,
        render: null,
        proxy: null,
        withProxy: null,
        effects: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // state
        ctx: shared_esm_bundler_EMPTY_OBJ,
        data: shared_esm_bundler_EMPTY_OBJ,
        props: shared_esm_bundler_EMPTY_OBJ,
        attrs: shared_esm_bundler_EMPTY_OBJ,
        slots: shared_esm_bundler_EMPTY_OBJ,
        refs: shared_esm_bundler_EMPTY_OBJ,
        setupState: shared_esm_bundler_EMPTY_OBJ,
        setupContext: null,
        // per-instance asset storage (mutable during options resolution)
        components: Object.create(appContext.components),
        directives: Object.create(appContext.directives),
        // suspense related
        suspense,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        emit: null // to be set immediately
    };
    if ((false)) {}
    else {
        instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = runtime_core_esm_bundler_emit.bind(null, instance);
    return instance;
}
let runtime_core_esm_bundler_currentInstance = null;
const getCurrentInstance = () => runtime_core_esm_bundler_currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
    runtime_core_esm_bundler_currentInstance = instance;
};
const isBuiltInTag = /*#__PURE__*/ shared_esm_bundler_makeMap('slot,component');
function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || shared_esm_bundler_NO;
    if (isBuiltInTag(name) || appIsNativeTag(name)) {
        runtime_core_esm_bundler_warn('Do not use built-in or reserved HTML elements as component id: ' + name);
    }
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children, shapeFlag } = instance.vnode;
    const isStateful = shapeFlag & 4 /* STATEFUL_COMPONENT */;
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful
        ? setupStatefulComponent(instance, isSSR)
        : undefined;
    isInSSRComponentSetup = false;
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    if ((false)) {}
    // 0. create render proxy property access cache
    instance.accessCache = {};
    // 1. create public instance / render proxy
    // also mark it raw so it's never observed
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    if ((false)) {}
    // 2. call setup()
    const { setup } = Component;
    if (setup) {
        const setupContext = (instance.setupContext =
            setup.length > 1 ? createSetupContext(instance) : null);
        runtime_core_esm_bundler_currentInstance = instance;
        pauseTracking();
        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [( false) ? undefined : instance.props, setupContext]);
        resetTracking();
        runtime_core_esm_bundler_currentInstance = null;
        if (shared_esm_bundler_isPromise(setupResult)) {
            if (isSSR) {
                // return the promise so server-renderer can wait on it
                return setupResult.then((resolvedResult) => {
                    handleSetupResult(instance, resolvedResult);
                });
            }
            else {
                // async setup returned Promise.
                // bail here and wait for re-entry.
                instance.asyncDep = setupResult;
            }
        }
        else {
            handleSetupResult(instance, setupResult);
        }
    }
    else {
        finishComponentSetup(instance);
    }
}
function handleSetupResult(instance, setupResult, isSSR) {
    if (dist_shared_esm_bundler_isFunction(setupResult)) {
        // setup returned an inline render function
        instance.render = setupResult;
    }
    else if (shared_esm_bundler_isObject(setupResult)) {
        if (false) {}
        // setup returned bindings.
        // assuming a render function compiled from template is present.
        instance.setupState = reactive(setupResult);
        if ((false)) {}
    }
    else if (false) {}
    finishComponentSetup(instance);
}
let compile;
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */
function registerRuntimeCompiler(_compile) {
    compile = _compile;
}
function finishComponentSetup(instance, isSSR) {
    const Component = instance.type;
    // template / render function normalization
    if (!instance.render) {
        if (compile && Component.template && !Component.render) {
            if ((false)) {}
            Component.render = compile(Component.template, {
                isCustomElement: instance.appContext.config.isCustomElement || shared_esm_bundler_NO
            });
            if ((false)) {}
            Component.render._rc = true;
        }
        if (false) {}
        instance.render = (Component.render || shared_esm_bundler_NOOP);
        // for runtime-compiled render functions using `with` blocks, the render
        // proxy used needs a different `has` handler which is more performant and
        // also only allows a whitelist of globals to fallthrough.
        if (instance.render._rc) {
            instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
        }
    }
    // support for 2.x options
    {
        runtime_core_esm_bundler_currentInstance = instance;
        applyOptions(instance, Component);
        runtime_core_esm_bundler_currentInstance = null;
    }
}
const attrHandlers = {
    get: (target, key) => {
        if ((false)) {}
        return target[key];
    },
    set: () => {
        runtime_core_esm_bundler_warn(`setupContext.attrs is readonly.`);
        return false;
    },
    deleteProperty: () => {
        runtime_core_esm_bundler_warn(`setupContext.attrs is readonly.`);
        return false;
    }
};
function createSetupContext(instance) {
    if ((false)) {}
    else {
        return {
            attrs: instance.attrs,
            slots: instance.slots,
            emit: instance.emit
        };
    }
}
// record effects created during a component's setup() so that they can be
// stopped when the component unmounts
function recordInstanceBoundEffect(effect) {
    if (runtime_core_esm_bundler_currentInstance) {
        (runtime_core_esm_bundler_currentInstance.effects || (runtime_core_esm_bundler_currentInstance.effects = [])).push(effect);
    }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
function formatComponentName(Component, isRoot = false) {
    let name = dist_shared_esm_bundler_isFunction(Component)
        ? Component.displayName || Component.name
        : Component.name;
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.vue$/);
        if (match) {
            name = match[1];
        }
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}

function runtime_core_esm_bundler_computed(getterOrOptions) {
    const c = reactivity_esm_bundler_computed(getterOrOptions);
    recordInstanceBoundEffect(c.effect);
    return c;
}

// implementation, close to no-op
function defineComponent(options) {
    return dist_shared_esm_bundler_isFunction(options) ? { setup: options } : options;
}

function defineAsyncComponent(source) {
    if (dist_shared_esm_bundler_isFunction(source)) {
        source = { loader: source };
    }
    const { loader, loadingComponent: loadingComponent, errorComponent: errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = true, onError: userOnError } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = () => {
        let thisRequest;
        return (pendingRequest ||
            (thisRequest = pendingRequest = loader()
                .catch(err => {
                err = err instanceof Error ? err : new Error(String(err));
                if (userOnError) {
                    return new Promise((resolve, reject) => {
                        const userRetry = () => resolve(retry());
                        const userFail = () => reject(err);
                        userOnError(err, userRetry, userFail, retries + 1);
                    });
                }
                else {
                    throw err;
                }
            })
                .then((comp) => {
                if (thisRequest !== pendingRequest && pendingRequest) {
                    return pendingRequest;
                }
                if (false) {}
                // interop module default
                if (comp &&
                    (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                    comp = comp.default;
                }
                if (false) {}
                resolvedComp = comp;
                return comp;
            })));
    };
    return defineComponent({
        __asyncLoader: load,
        name: 'AsyncComponentWrapper',
        setup() {
            const instance = runtime_core_esm_bundler_currentInstance;
            // already resolved
            if (resolvedComp) {
                return () => createInnerComp(resolvedComp, instance);
            }
            const onError = (err) => {
                pendingRequest = null;
                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */);
            };
            // suspense-controlled or SSR.
            if (( suspensible && instance.suspense) ||
                (false )) {
                return load()
                    .then(comp => {
                    return () => createInnerComp(comp, instance);
                })
                    .catch(err => {
                    onError(err);
                    return () => errorComponent
                        ? createVNode(errorComponent, { error: err })
                        : null;
                });
            }
            const loaded = reactivity_esm_bundler_ref(false);
            const error = reactivity_esm_bundler_ref();
            const delayed = reactivity_esm_bundler_ref(!!delay);
            if (delay) {
                setTimeout(() => {
                    delayed.value = false;
                }, delay);
            }
            if (timeout != null) {
                setTimeout(() => {
                    if (!loaded.value) {
                        const err = new Error(`Async component timed out after ${timeout}ms.`);
                        onError(err);
                        error.value = err;
                    }
                }, timeout);
            }
            load()
                .then(() => {
                loaded.value = true;
            })
                .catch(err => {
                onError(err);
                error.value = err;
            });
            return () => {
                if (loaded.value && resolvedComp) {
                    return createInnerComp(resolvedComp, instance);
                }
                else if (error.value && errorComponent) {
                    return createVNode(errorComponent, {
                        error: error.value
                    });
                }
                else if (loadingComponent && !delayed.value) {
                    return createVNode(loadingComponent);
                }
            };
        }
    });
}
function createInnerComp(comp, { vnode: { props, children } }) {
    return createVNode(comp, props, children);
}

// Actual implementation
function runtime_core_esm_bundler_h(type, propsOrChildren, children) {
    if (arguments.length === 2) {
        if (shared_esm_bundler_isObject(propsOrChildren) && !dist_shared_esm_bundler_isArray(propsOrChildren)) {
            // single vnode without props
            if (isVNode(propsOrChildren)) {
                return createVNode(type, null, [propsOrChildren]);
            }
            // props without children
            return createVNode(type, propsOrChildren);
        }
        else {
            // omit props
            return createVNode(type, null, propsOrChildren);
        }
    }
    else {
        if (isVNode(children)) {
            children = [children];
        }
        return createVNode(type, propsOrChildren, children);
    }
}

const useCSSModule = (name = '$style') => {
    {
        const instance = getCurrentInstance();
        if (!instance) {
            ( false) && false;
            return shared_esm_bundler_EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            ( false) && false;
            return shared_esm_bundler_EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            ( false) &&
                false;
            return shared_esm_bundler_EMPTY_OBJ;
        }
        return mod;
    }
};

const ssrContextKey = Symbol(( false) ? undefined : ``);
const useSSRContext = () => {
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
            runtime_core_esm_bundler_warn(`Server rendering context not provided. Make sure to only call ` +
                `useSsrContext() conditionally in the server build.`);
        }
        return ctx;
    }
};

// actual implementation
function renderList(source, renderItem) {
    let ret;
    if (dist_shared_esm_bundler_isArray(source) || shared_esm_bundler_isString(source)) {
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
            ret[i] = renderItem(source[i], i);
        }
    }
    else if (typeof source === 'number') {
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i);
        }
    }
    else if (shared_esm_bundler_isObject(source)) {
        if (source[Symbol.iterator]) {
            ret = Array.from(source, renderItem);
        }
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for (let i = 0, l = keys.length; i < l; i++) {
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i);
            }
        }
    }
    else {
        ret = [];
    }
    return ret;
}

/**
 * For prefixing keys in v-on="obj" with "on"
 * @internal
 */
function toHandlers(obj) {
    const ret = {};
    if (false) {}
    for (const key in obj) {
        ret[`on${key}`] = obj[key];
    }
    return ret;
}

/**
 * Compiler runtime helper for rendering <slot/>
 * @internal
 */
function renderSlot(slots, name, props = {}, 
// this is not a user-facing function, so the fallback is always generated by
// the compiler and guaranteed to be a function returning an array
fallback) {
    let slot = slots[name];
    if (false) {}
    return (openBlock(),
        createBlock(Fragment, { key: props.key }, slot ? slot(props) : fallback ? fallback() : [], slots._ ? 64 /* STABLE_FRAGMENT */ : -2 /* BAIL */));
}

/**
 * Compiler runtime helper for creating dynamic slots object
 * @internal
 */
function createSlots(slots, dynamicSlots) {
    for (let i = 0; i < dynamicSlots.length; i++) {
        const slot = dynamicSlots[i];
        // array of dynamic slot generated by <template v-for="..." #[...]>
        if (dist_shared_esm_bundler_isArray(slot)) {
            for (let j = 0; j < slot.length; j++) {
                slots[slot[j].name] = slot[j].fn;
            }
        }
        else if (slot) {
            // conditional single slot generated by <template v-if="..." #foo>
            slots[slot.name] = slot.fn;
        }
    }
    return slots;
}

// Core API ------------------------------------------------------------------
const version = "3.0.0-beta.14";
/**
 * @internal
 */
const _toDisplayString = shared_esm_bundler_toDisplayString;
/**
 * @internal
 */
const _camelize = dist_shared_esm_bundler_camelize;
/**
 * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
 * @internal
 */
const ssrUtils = ( null);



// CONCATENATED MODULE: ./src/components/_util/base-mixin.tsx


/* harmony default export */ var base_mixin = (function (instance) {
  return {
    __emit: function __emit() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // 直接调用listeners，底层组件不需要vueTool记录events
      var eventName = args[0];
      var eventHandlerName = "on".concat(eventName.substr(0, 1).toUpperCase()).concat(eventName.substr(1));
      var eventHandler = instance.attrs[eventHandlerName];

      if (args.length && eventHandler) {
        if (Array.isArray(eventHandler)) {
          for (var i = 0, l = eventHandler.length; i < l; i++) {
            eventHandler[i].apply(eventHandler, toConsumableArray_default()(args.slice(1)));
          }
        } else {
          eventHandler.apply(void 0, toConsumableArray_default()(args.slice(1)));
        }
      }
    }
  };
});
// CONCATENATED MODULE: ./src/components/vc-checkbox/src/index.tsx


function src_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function src_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { src_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { src_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }









/* harmony default export */ var vc_checkbox_src = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'Checkbox',
  inheritAttrs: false,
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: initDefaultProps({
    prefixCls: vue_types.string,
    name: vue_types.string,
    id: vue_types.string,
    type: vue_types.string,
    defaultChecked: vue_types.oneOfType([vue_types.number, vue_types.bool]),
    checked: vue_types.oneOfType([vue_types.number, vue_types.bool]),
    disabled: vue_types.bool,
    // onFocus: PropTypes.func,
    // onBlur: PropTypes.func,
    // onChange: PropTypes.func,
    // onClick: PropTypes.func,
    tabIndex: vue_types.oneOfType([vue_types.string, vue_types.number]),
    readOnly: vue_types.bool,
    autoFocus: vue_types.bool,
    value: vue_types.any
  }, {
    prefixCls: 'rc-checkbox',
    type: 'checkbox',
    defaultChecked: false
  }),
  setup: function setup(props) {
    var sChecked = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.checked !== undefined ? props.checked : props.defaultChecked);
    var componentInstance = getCurrentInstance();
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.checked;
    }, function (val) {
      sChecked.value = val;
    });

    var _BaseMixin = base_mixin(componentInstance),
        __emit = _BaseMixin.__emit;

    var eventShiftKey = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);

    var _DataEntryFocus = data_entry_focus(),
        setEl = _DataEntryFocus.setEl,
        getEl = _DataEntryFocus.getEl,
        focus = _DataEntryFocus.focus,
        blur = _DataEntryFocus.blur;

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        var _a;

        if (props.autoFocus) {
          (_a = getEl()) === null || _a === void 0 ? void 0 : _a.focus();
        }
      });
    });

    var handleChange = function handleChange(e) {
      if (props.disabled) {
        return;
      }

      if (props.checked === undefined) {
        sChecked.value = e.target.checked;
      }

      e.shiftKey = eventShiftKey.value;

      __emit('change', {
        target: Object.assign(Object.assign({}, props), {
          checked: e.target.checked
        }),
        stopPropagation: function stopPropagation() {
          e.stopPropagation();
        },
        preventDefault: function preventDefault() {
          e.preventDefault();
        },
        nativeEvent: e
      });

      eventShiftKey.value = false;
    };

    var onClick = function onClick(e) {
      __emit('click', e); // onChange没能获取到shiftKey，使用onClick hack


      eventShiftKey.value = e.shiftKey;
    };

    return {
      sChecked: sChecked,
      focus: focus,
      blur: blur,
      setEl: setEl,
      onClick: onClick,
      handleChange: handleChange
    };
  },
  render: function render() {
    var _classNames;

    var currentInstance = getCurrentInstance();

    var _a = getOptionProps(currentInstance),
        prefixCls = _a.prefixCls,
        name = _a.name,
        id = _a.id,
        type = _a.type,
        disabled = _a.disabled,
        readOnly = _a.readOnly,
        tabIndex = _a.tabIndex,
        autoFocus = _a.autoFocus,
        value = _a.value,
        others = __rest(_a, ["prefixCls", "name", "id", "type", "disabled", "readOnly", "tabIndex", "autoFocus", "value"]);

    var attrs = this.$attrs;
    var globalProps = Object.keys(Object.assign(Object.assign({}, others), attrs)).reduce(function (prev, key) {
      if (key.substr(0, 5) === 'aria-' || key.substr(0, 5) === 'data-' || key === 'role') {
        prev[key] = others[key];
      }

      return prev;
    }, {});
    var sChecked = this.sChecked;
    var classString = classnames_default()(prefixCls, attrs["class"], (_classNames = {}, defineProperty_default()(_classNames, "".concat(prefixCls, "-checked"), sChecked), defineProperty_default()(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": classString
    }, [// @ts-ignore
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", src_objectSpread({
      "onChange": this.handleChange,
      "onClick": this.onClick,
      "name": name,
      "id": id,
      "type": type,
      "readonly": readOnly,
      "disabled": disabled,
      "tabindex": tabIndex,
      "class": "".concat(prefixCls, "-input"),
      "checked": !!sChecked,
      "autofocus": autoFocus,
      "ref": "input",
      "value": value
    }, globalProps), []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-inner")
    }, [])]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-checkbox/index.ts

// based on rc-checkbox 2.1.7

// CONCATENATED MODULE: ./src/components/radio/group.tsx









function group_noop() {}

var group_useRadioGroupContext = function useRadioGroupContext() {
  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('radioGroupContext');
};
var Props = {
  prefixCls: vue_types.string,
  defaultValue: vue_types.any,
  value: vue_types.any,
  size: {
    "default": 'default',
    validator: function validator(value) {
      return ['large', 'default', 'small'].includes(value);
    }
  },
  options: {
    "default": function _default() {
      return [];
    },
    type: Array
  },
  disabled: Boolean,
  name: String,
  buttonStyle: vue_types.string.def('outline')
};
/* harmony default export */ var radio_group = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ARadioGroup',
  props: Props,
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        attrs = _ref.attrs;
    form_useForm().registerControl();
    var value = props.value,
        defaultValue = props.defaultValue;

    var _useConfigProvider = config_provider_useConfigProvider(),
        getPrefixCls = _useConfigProvider.getPrefixCls;

    var updatingValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var stateValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(value === undefined ? defaultValue : value);
    var radioOptions = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function () {
      var disabled = props.disabled;
      return props.options.map(function (option) {
        return typeof option === 'string' ? {
          label: option,
          value: option
        } : Object.assign(Object.assign({}, option), {
          disabled: option.disabled === undefined ? disabled : option.disabled
        });
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.value;
    }, function (val) {
      updatingValue.value = false;
      stateValue.value = val;
    });
    var classes = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function () {
      var _ref2;

      var prefixCls = props.prefixCls,
          size = props.size;
      return _ref2 = {}, defineProperty_default()(_ref2, "".concat(prefixCls), true), defineProperty_default()(_ref2, "".concat(prefixCls, "-").concat(size), size), _ref2;
    });

    var onRadioChange = function onRadioChange(ev) {
      var lastValue = stateValue.value;
      var value = ev.target.value;

      if (props.value === undefined) {
        stateValue.value = value;
      } // nextTick for https://github.com/vueComponent/ant-design-vue/issues/1280


      if (!updatingValue.value && value !== lastValue) {
        updatingValue.value = true;
        emit('update:value', value);
        emit('change', ev);
      }

      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        updatingValue.value = false;
      });
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])('radioGroupContext', {
      getValue: function getValue() {
        return stateValue.value;
      },
      onRadioChange: onRadioChange,
      name: props.name,
      disabled: props.disabled
    });
    return {
      classes: classes,
      radioOptions: radioOptions,
      stateValue: stateValue,
      getPrefixCls: getPrefixCls,
      updatingValue: updatingValue,
      onRadioChange: onRadioChange
    };
  },
  render: function render(ctx) {
    var _this = this;

    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var _getListenersFromInst = getListenersFromInstance(currentInstance),
        _getListenersFromInst2 = _getListenersFromInst.mouseenter,
        mouseenter = _getListenersFromInst2 === void 0 ? group_noop : _getListenersFromInst2,
        _getListenersFromInst3 = _getListenersFromInst.mouseleave,
        mouseleave = _getListenersFromInst3 === void 0 ? group_noop : _getListenersFromInst3;

    var props = getOptionProps(currentInstance);
    var customizePrefixCls = props.prefixCls,
        options = props.options,
        buttonStyle = props.buttonStyle;
    var prefixCls = ctx.getPrefixCls('radio', customizePrefixCls);
    var groupPrefixCls = "".concat(prefixCls, "-group");
    var classString = classnames_default()(groupPrefixCls, "".concat(groupPrefixCls, "-").concat(buttonStyle), defineProperty_default()({}, "".concat(groupPrefixCls, "-").concat(props.size), props.size));
    var children = filterEmpty(this.$slots["default"]); // 如果存在 options, 优先使用

    if (options && options.length > 0) {
      children = options.map(function (option) {
        if (typeof option === 'string') {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(radio_radio, {
            "key": option,
            "prefixCls": prefixCls,
            "disabled": props.disabled,
            "value": option,
            "checked": _this.stateValue === option
          }, [option]);
        } else {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(radio_radio, {
            "key": "radio-group-value-options-".concat(option.value),
            "prefixCls": prefixCls,
            "disabled": option.disabled || props.disabled,
            "value": option.value,
            "checked": _this.stateValue === option.value
          }, [option.label]);
        }
      });
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": classString,
      "onMouseenter": mouseenter,
      "onMouseleave": mouseleave
    }, [children]);
  }
}));
// CONCATENATED MODULE: ./src/components/radio/radio.tsx


function radio_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function radio_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radio_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radio_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }











function radio_noop() {}

/* harmony default export */ var radio_radio = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ARadio',
  props: {
    prefixCls: vue_types.string,
    defaultChecked: Boolean,
    checked: {
      type: Boolean,
      "default": undefined
    },
    disabled: Boolean,
    isGroup: Boolean,
    value: vue_types.any,
    name: String,
    id: String,
    autoFocus: Boolean,
    type: vue_types.string.def('radio')
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    form_useForm().registerControl();
    var checkboxRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var focus = function focus() {
      var _a;

      (_a = checkboxRef.value) === null || _a === void 0 ? void 0 : _a.focus();
    };

    var blur = function blur() {
      var _a;

      (_a = checkboxRef.value) === null || _a === void 0 ? void 0 : _a.blur();
    };

    var handleChange = function handleChange(event) {
      var targetChecked = event.target.checked;
      emit('update:value', targetChecked);
      emit('change', event);
    };

    var radioGroup = group_useRadioGroupContext();

    var onChange = function onChange(e) {
      emit('change', e);

      if (radioGroup && radioGroup.onRadioChange) {
        radioGroup.onRadioChange(e);
      }
    };

    var setCheckbox = function setCheckbox(el) {
      checkboxRef.value = el;
    };

    var _useConfigProvider = config_provider_useConfigProvider(),
        getPrefixCls = _useConfigProvider.getPrefixCls;

    return {
      getPrefixCls: getPrefixCls,
      radioGroup: radioGroup,
      setCheckbox: setCheckbox,
      focus: focus,
      blur: blur,
      handleChange: handleChange,
      onChange: onChange
    };
  },
  render: function render(ctx) {
    var _classNames;

    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var $slots = this.$slots;
    var radioGroup = ctx.radioGroup;
    var props = getOptionProps(currentInstance);
    var children = $slots["default"] && $slots["default"]();

    var _getListenersFromInst = getListenersFromInstance(currentInstance),
        _getListenersFromInst2 = _getListenersFromInst.mouseenter,
        mouseenter = _getListenersFromInst2 === void 0 ? radio_noop : _getListenersFromInst2,
        _getListenersFromInst3 = _getListenersFromInst.mouseleave,
        mouseleave = _getListenersFromInst3 === void 0 ? radio_noop : _getListenersFromInst3;

    var customizePrefixCls = props.prefixCls,
        restProps = __rest(props, ["prefixCls"]);

    var prefixCls = ctx.getPrefixCls('radio', customizePrefixCls);
    var radioProps = Object.assign(Object.assign(Object.assign({}, restProps), {
      prefixCls: prefixCls
    }), this.$attrs);

    if (radioGroup) {
      radioProps.name = radioGroup.name;
      radioProps.onChange = this.onChange;
      radioProps.checked = props.value === radioGroup.getValue();
      radioProps.disabled = props.disabled || radioGroup.disabled;
    } else {
      radioProps.onChange = this.handleChange;
    }

    var wrapperClassString = classnames_default()((_classNames = {}, defineProperty_default()(_classNames, "".concat(prefixCls, "-wrapper"), true), defineProperty_default()(_classNames, "".concat(prefixCls, "-wrapper-checked"), radioProps.checked), defineProperty_default()(_classNames, "".concat(prefixCls, "-wrapper-disabled"), radioProps.disabled), _classNames));
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("label", {
      "class": wrapperClassString,
      "onMouseenter": mouseenter,
      "onMouseleave": mouseleave
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_checkbox_src, radio_objectSpread({}, radioProps, {
      "ref": ctx.setCheckbox
    }), []), children !== undefined ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {}, [children]) : null]);
  }
}));
// CONCATENATED MODULE: ./src/components/radio/radio-button.tsx


function radio_button_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function radio_button_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radio_button_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radio_button_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }







/* harmony default export */ var radio_button = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ARadioButton',
  props: Object.assign({}, radio_radio.props),
  setup: function setup() {
    var radioGroup = group_useRadioGroupContext();
    return {
      radioGroup: radioGroup
    };
  },
  render: function render(ctx) {
    var _a;

    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var _b = getOptionProps(currentInstance),
        customizePrefixCls = _b.prefixCls,
        otherProps = __rest(_b, ["prefixCls"]);

    var _useConfigProvider = config_provider_useConfigProvider(),
        getPrefixCls = _useConfigProvider.getPrefixCls;

    var prefixCls = getPrefixCls('radio-button', customizePrefixCls);
    var radioProps = Object.assign(Object.assign(Object.assign({}, otherProps), {
      prefixCls: prefixCls
    }), getListenersFromInstance(currentInstance));

    if (ctx.radioGroup) {
      radioProps.onChange = ctx.radioGroup.onRadioChange;
      radioProps.checked = this.$props.value === ((_a = ctx.radioGroup.value) === null || _a === void 0 ? void 0 : _a.value);
      radioProps.disabled = this.$props.disabled || ctx.radioGroup.disabled;
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(radio_radio, radio_button_objectSpread({}, radioProps), [this.$slots["default"] && this.$slots["default"]()]);
  }
}));
// CONCATENATED MODULE: ./src/components/radio/index.ts





radio_radio.Group = radio_group;
radio_radio.Button = radio_button;
/* istanbul ignore next */

radio_radio.install = function (Vue) {
  Vue.use(base);
  Vue.component(radio_radio.name, radio_radio);
  Vue.component(radio_radio.Group.name, radio_radio.Group);
  Vue.component(radio_radio.Button.name, radio_radio.Button);
};


/* harmony default export */ var components_radio = (radio_radio);
// CONCATENATED MODULE: ./src/components/menu/utils.ts

var utils_ProvideKeys;

(function (ProvideKeys) {
  ProvideKeys["MenuContext"] = "MenuContext";
  ProvideKeys["SubMenuContext"] = "SubMenuContext";
})(utils_ProvideKeys || (utils_ProvideKeys = {}));
// CONCATENATED MODULE: ./src/components/menu/divider.tsx

/* harmony default export */ var divider = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AMenuDivider',
  props: {
    disabled: {
      type: Boolean,
      "default": true
    },
    rootPrefixCls: String
  },
  render: function render() {
    var rootPrefixCls = this.$props.rootPrefixCls;
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
      "class": "".concat(rootPrefixCls, "-item-divider")
    }, []);
  }
}));
// CONCATENATED MODULE: ./src/tools/key.ts

var key_useKey = function useKey() {
  var _a;

  return (_a = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])().vnode.key) === null || _a === void 0 ? void 0 : _a.toString();
};
// CONCATENATED MODULE: ./src/components/menu/placements.ts

var menu_placements_autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var placements_placements = {
  topLeft: {
    points: ['bl', 'tl'],
    overflow: menu_placements_autoAdjustOverflow,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: menu_placements_autoAdjustOverflow,
    offset: [0, 7]
  },
  leftTop: {
    points: ['tr', 'tl'],
    overflow: menu_placements_autoAdjustOverflow,
    offset: [-4, 0]
  },
  rightTop: {
    points: ['tl', 'tr'],
    overflow: menu_placements_autoAdjustOverflow,
    offset: [4, 0]
  }
};
/* harmony default export */ var menu_placements = (placements_placements);
// CONCATENATED MODULE: ./src/components/menu/popup-submenu.tsx

/* harmony default export */ var popup_submenu = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'PopupSubMenu',
  props: {
    prefixCls: {
      type: String
    }
  },
  render: function render() {
    return this.$slots["default"] && this.$slots["default"]({
      rootPrefixCls: this.prefixCls
    });
  }
}));
// CONCATENATED MODULE: ./src/components/menu/sub-menu.tsx



function sub_menu_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function sub_menu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { sub_menu_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { sub_menu_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }














var popupPlacementMap = {
  horizontal: 'bottomLeft',
  vertical: 'rightTop',
  'vertical-left': 'rightTop',
  'vertical-right': 'leftTop'
};
function sub_menu_noop() {}
var sub_menu_useSubMenuContext = function useSubMenuContext() {
  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(utils_ProvideKeys.SubMenuContext);
};
/* harmony default export */ var sub_menu = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ASubMenu',
  props: {
    title: vue_types.any,
    prefixCls: vue_types.string.def('ant-menu-submenu'),
    openKeys: vue_types.array.def([]),
    eventKey: vue_types.oneOfType([vue_types.string, vue_types.number]),
    multiple: vue_types.bool,
    index: vue_types.number,
    popupClassName: vue_types.string,
    disabled: vue_types.bool,
    subMenuOpenDelay: vue_types.number.def(0.1),
    subMenuCloseDelay: vue_types.number.def(0.1),
    level: vue_types.number.def(1),
    openTransitionName: vue_types.string,
    popupOffset: vue_types.array,
    builtinPlacements: vue_types.object.def(function () {
      return {};
    }),
    itemIcon: vue_types.any,
    expandIcon: vue_types.any
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;
    var menuContext = menu_useMenuContext();
    var getMode = menuContext.getMode,
        getOpenKeys = menuContext.getOpenKeys,
        getSelectedKeys = menuContext.getSelectedKeys,
        openAnimation = menuContext.openAnimation,
        openTransitionName = menuContext.openTransitionName,
        triggerSubMenuAction = menuContext.triggerSubMenuAction,
        getTheme = menuContext.getTheme,
        getInlineCollapsed = menuContext.getInlineCollapsed,
        rootPrefixCls = menuContext.rootPrefixCls,
        inlineIndent = menuContext.inlineIndent;

    var isInlineMode = function isInlineMode() {
      return getMode() === 'inline';
    };

    var visible = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);

    var _useRefs = save_ref_useRefs(),
        saveRef = _useRefs.saveRef,
        getRef = _useRefs.getRef;

    var menuInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var haveRendered = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var subMenuContext = sub_menu_useSubMenuContext();

    var getLevel = function getLevel() {
      if (subMenuContext) {
        return subMenuContext.level + props.level;
      } else {
        return props.level;
      }
    };

    var renderTitle = function renderTitle() {
      var style = {};

      if (isInlineMode() && !getInlineCollapsed()) {
        style.paddingLeft = "".concat(inlineIndent * getLevel(), "px");
      }

      var icon = null;

      if (getMode() !== 'horizontal') {
        icon = getComponentFromContext({
          $props: props,
          $slots: slots
        }, 'expandIcon', props);
      }

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "onClick": function onClick() {
          onPopupVisibleChange(!visible.value);
        },
        "ref": saveRef('subMenuTitle'),
        "style": style,
        "class": getPrefixCls() + '-title'
      }, [slots.title ? slots.title() : props.title, icon || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("i", {
        "class": "".concat(getPrefixCls(), "-arrow")
      }, [])]);
    };

    var onPopupVisibleChange = function onPopupVisibleChange(v) {
      visible.value = v;
      var realState = getRealVisible();
      emit('visibleChange', realState);
      emit('openChange', {
        key: key,
        item: instance,
        open: !realState
      });
    };

    var handleChildOpenChange = function handleChildOpenChange(e) {
      if (Array.isArray(e)) {
        emit('openChange', [{
          key: key,
          item: instance,
          open: true
        }].concat(e));
      } else {
        emit('openChange', [{
          key: key,
          item: instance,
          open: true
        }].concat([e]));
      }
    };

    var popupRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var subMenuRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var menuItemKeys = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["reactive"])([]);

    var onMenuItemClick = function onMenuItemClick(info) {
      emit('click', Object.assign(Object.assign({}, info), {
        keyPath: (info.keyPath || []).concat(props.eventKey)
      }));

      if (getMode() !== 'inline' || getInlineCollapsed()) {
        onPopupVisibleChange(false);
      }

      subMenuContext === null || subMenuContext === void 0 ? void 0 : subMenuContext.onMenuItemClick(info);
    };

    var subMenuContextValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["reactive"])({
      level: props.level,
      registerMenu: function registerMenu(key) {
        if (!menuItemKeys.includes(key)) {
          menuItemKeys.push(key);
        }

        subMenuContext === null || subMenuContext === void 0 ? void 0 : subMenuContext.registerMenu(key);
      },
      onMenuItemClick: onMenuItemClick,
      unregisterMenu: function unregisterMenu(key) {
        if (menuItemKeys.includes(key)) {
          menuItemKeys.splice(menuItemKeys.indexOf(key), 1);
        }

        subMenuContext === null || subMenuContext === void 0 ? void 0 : subMenuContext.unregisterMenu(key);
      }
    });

    if (subMenuContext) {
      subMenuContextValue.level = subMenuContext.level + 1;
    }

    var adjustWidth = function adjustWidth() {
      var subMenuTitle = getRef('subMenuTitle');
      /* istanbul ignore if */

      if (!subMenuTitle || !menuInstance.value) {
        return;
      }

      var popupMenu = menuInstance.value;

      if (popupMenu.offsetWidth >= subMenuTitle.offsetWidth) {
        return;
      }
      /* istanbul ignore next */


      popupMenu.style.minWidth = "".concat(subMenuTitle.offsetWidth, "px");
    };

    var childVisible = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var key = key_useKey();
    subMenuContext === null || subMenuContext === void 0 ? void 0 : subMenuContext.registerMenu(key);
    var minWidthTimeout = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var getPrefixCls = function getPrefixCls() {
      return rootPrefixCls ? rootPrefixCls + '-submenu' : props.prefixCls;
    };

    var handleUpdated = function handleUpdated() {
      var parentMenu = instance.parent;

      if (getMode() !== 'horizontal' || !parentMenu['ctx'].isRootMenu || !visible.value) {
        return;
      }

      minWidthTimeout.value = requestAnimationTimeout(function () {
        return adjustWidth();
      }, 0);
    };

    var isSelected = function isSelected() {
      var selectedKeys = getSelectedKeys();
      return menuItemKeys.some(function (it) {
        return selectedKeys.includes(it);
      });
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      if (minWidthTimeout.value) {
        request_animation_timeout_cancelAnimationTimeout(minWidthTimeout.value);
        minWidthTimeout.value = null;
      }

      subMenuContext === null || subMenuContext === void 0 ? void 0 : subMenuContext.unregisterMenu(key);
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      haveRendered.value = true;
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        handleUpdated();
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        handleUpdated();
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(utils_ProvideKeys.SubMenuContext, subMenuContextValue);

    var getRealVisible = function getRealVisible() {
      if (getMode() === 'inline') {
        return getOpenKeys().includes(key);
      }

      return childVisible.value || visible.value;
    };

    return {
      getInlineCollapsed: getInlineCollapsed,
      getRealVisible: getRealVisible,
      getMode: getMode,
      isSelected: isSelected,
      openTransitionName: openTransitionName,
      triggerSubMenuAction: triggerSubMenuAction,
      renderTitle: renderTitle,
      handleChildOpenChange: handleChildOpenChange,
      visible: visible,
      getPrefixCls: getPrefixCls,
      key: key,
      haveRendered: haveRendered,
      onPopupVisibleChange: onPopupVisibleChange,
      openAnimation: openAnimation,
      getOpenKeys: getOpenKeys,
      getTheme: getTheme,
      rootPrefixCls: rootPrefixCls,
      setSubMenuRef: function setSubMenuRef(el) {
        subMenuRef.value = el;
      },
      onChildVisibleChange: function onChildVisibleChange(v) {
        childVisible.value = v;
      },
      setPopupRef: function setPopupRef(el) {
        popupRef.value = el;
      },
      setMenuContent: function setMenuContent(el) {
        menuInstance.value = el;
      }
    };
  },
  render: function render() {
    var _classes,
        _menuClass,
        _this = this;

    var theme = this.getTheme();
    var visible = this.getRealVisible();
    var mode = this.getMode();
    var collapsed = this.getInlineCollapsed();
    var prefixCls = this.getPrefixCls();
    var rootPrefixCls = this.rootPrefixCls;
    var style = {};

    if (!visible) {
      style.display = 'none';
    }

    var classes = (_classes = {}, defineProperty_default()(_classes, prefixCls, true), defineProperty_default()(_classes, "".concat(prefixCls, "-active"), visible && mode !== 'inline'), defineProperty_default()(_classes, "".concat(prefixCls, "-disabled"), this.$props.disabled), defineProperty_default()(_classes, "".concat(prefixCls, "-selected"), this.isSelected()), defineProperty_default()(_classes, "".concat(prefixCls, "-open"), visible), defineProperty_default()(_classes, "".concat(prefixCls, "-").concat(mode), true), _classes);
    var menuClass = (_menuClass = {}, defineProperty_default()(_menuClass, rootPrefixCls, true), defineProperty_default()(_menuClass, rootPrefixCls + '-inline', mode === 'inline'), defineProperty_default()(_menuClass, rootPrefixCls + '-vertical', mode === 'horizontal' || mode === 'vertical'), defineProperty_default()(_menuClass, rootPrefixCls + '-sub', true), defineProperty_default()(_menuClass, rootPrefixCls + '-content', mode !== 'inline'), _menuClass);
    var children = this.$slots["default"] && this.$slots["default"]() || [];
    var menu = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("ul", {
      "class": menuClass,
      "ref": this.setMenuContent
    }, [children.map(function (vnode) {
      return cloneElement(vnode, {
        onVisibleChange: function onVisibleChange(v) {
          _this.onChildVisibleChange(v);
        },
        onOpenChange: function onOpenChange(e) {
          _this.handleChildOpenChange(e);
        }
      });
    })]);
    var innerContent = null;

    if (mode !== 'inline' || collapsed) {
      innerContent = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "ref": this.setPopupRef,
        "class": [prefixCls]
      }, [menu]);
    } else {
      innerContent = menu;
    }

    var popupPlacement = popupPlacementMap[collapsed ? 'vertical-left' : mode];
    var popupAlign = this.popupOffset ? {
      offset: this.popupOffset
    } : {};
    var wrapper = null;
    var renderTitle = true;

    if (mode === 'inline') {
      var transitionAppear = this.haveRendered || !visible || mode !== 'inline';
      var animProps = {
        appear: transitionAppear,
        css: false
      };
      var transitionProps = Object.assign({}, animProps);

      if (this.openTransitionName) {
        transitionProps = get_transition_props(this.openTransitionName, {
          appear: transitionAppear
        });
      } else if (typeof_default()(this.openAnimation) === 'object') {
        animProps = Object.assign(Object.assign({}, animProps), this.openAnimation);

        if (!transitionAppear) {
          animProps.appear = false;
        }
      } else if (typeof this.openAnimation === 'string') {
        transitionProps = get_transition_props(this.openAnimation, {
          appear: transitionAppear
        });
      }

      wrapper = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], sub_menu_objectSpread({}, transitionProps), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(popup_submenu, {
        "prefixCls": this.prefixCls
      }, [innerContent]), [[external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], visible]])]);
    } else {
      renderTitle = false;
      wrapper = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_trigger, {
        "prefixCls": prefixCls,
        "popupTransitionName": 'slide-up',
        "popupClassName": "".concat(prefixCls, "-popup ").concat(prefixCls, "-").concat(theme, " ").concat(this.popupClassName || ''),
        "builtinPlacements": Object.assign({}, placements_placements, this.builtinPlacements),
        "popupPlacement": popupPlacement,
        "popupVisible": visible,
        "popupAlign": popupAlign,
        "action": this.disabled ? [] : [this.triggerSubMenuAction],
        "mouseEnterDelay": this.subMenuOpenDelay,
        "mouseLeaveDelay": this.subMenuCloseDelay,
        "onPopupVisibleChange": this.onPopupVisibleChange
      }, {
        "popup": [innerContent],
        "default": [this.renderTitle()]
      });
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
      "class": classes,
      "ref": this.setSubMenuRef
    }, [renderTitle ? this.renderTitle() : null, wrapper]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-tooltip/tooltip.tsx


function tooltip_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tooltip_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tooltip_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tooltip_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }









function tooltip_noop() {}

/* harmony default export */ var tooltip = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  inheritAttrs: false,
  props: {
    trigger: vue_types.any.def(['hover']),
    defaultVisible: vue_types.bool,
    visible: vue_types.bool,
    placement: vue_types.string.def('right'),
    transitionName: vue_types.oneOfType([vue_types.string, vue_types.object]),
    animation: vue_types.any,
    afterVisibleChange: vue_types.func.def(function () {}),
    title: vue_types.any,
    overlay: vue_types.any,
    overlayStyle: vue_types.object,
    onVisibleChange: vue_types.func,
    overlayClassName: vue_types.string,
    prefixCls: vue_types.string.def('rc-tooltip'),
    mouseEnterDelay: vue_types.number.def(0),
    mouseLeaveDelay: vue_types.number.def(0.1),
    getTooltipContainer: vue_types.func,
    destroyTooltipOnHide: vue_types.bool.def(false),
    align: vue_types.object.def(function () {
      return {};
    }),
    target: vue_types.object,
    arrowContent: vue_types.any.def(null),
    tipId: vue_types.string,
    builtinPlacements: vue_types.object
  },
  setup: function setup(props) {
    var contentRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var targetEl = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function () {
      return props.target.el;
    });
    vc_align_useAlign(contentRef, targetEl, props.placement);

    var getPopupElement = function getPopupElement() {
      var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
      var prefixCls = props.prefixCls,
          overlay = props.overlay;
      return [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": "".concat(prefixCls, "-arrow"),
        "key": "arrow"
      }, [props_util_getComponentFromProp(instance, 'arrowContent')]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": "".concat(prefixCls, "-inner"),
        "role": "tooltip"
      }, [typeof overlay === 'function' ? overlay() : overlay])];
    };

    return {
      getPopupElement: getPopupElement,
      setContentRef: function setContentRef(el) {
        contentRef.value = el;
      }
    };
  },
  render: function render(ctx) {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var _a = getOptionProps(instance),
        overlayClassName = _a.overlayClassName,
        trigger = _a.trigger,
        mouseEnterDelay = _a.mouseEnterDelay,
        mouseLeaveDelay = _a.mouseLeaveDelay,
        overlayStyle = _a.overlayStyle,
        prefixCls = _a.prefixCls,
        afterVisibleChange = _a.afterVisibleChange,
        transitionName = _a.transitionName,
        animation = _a.animation,
        placement = _a.placement,
        visible = _a.visible,
        align = _a.align,
        destroyTooltipOnHide = _a.destroyTooltipOnHide,
        defaultVisible = _a.defaultVisible,
        getTooltipContainer = _a.getTooltipContainer,
        restProps = __rest(_a, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "afterVisibleChange", "transitionName", "animation", "placement", "visible", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer"]);

    var extraProps = Object.assign({}, restProps);

    if (hasProp(instance, 'visible')) {
      extraProps.popupVisible = this.$props.visible;
    }

    var listeners = getListenersFromInstance(instance);
    var triggerProps = Object.assign(Object.assign(Object.assign({}, extraProps), listeners), {
      popupClassName: overlayClassName,
      prefixCls: prefixCls,
      action: trigger,
      builtinPlacements: placements,
      popupPlacement: placement,
      popupAlign: align,
      getPopupContainer: getTooltipContainer,
      afterPopupVisibleChange: afterVisibleChange,
      popupTransitionName: transitionName,
      popupAnimation: animation,
      defaultPopupVisible: defaultVisible,
      destroyPopupOnHide: destroyTooltipOnHide,
      mouseLeaveDelay: mouseLeaveDelay,
      popupStyle: overlayStyle,
      mouseEnterDelay: mouseEnterDelay,
      onPopupVisibleChange: listeners.onVisibleChange || tooltip_noop,
      onPopupAlign: listeners.onPopupAlign || tooltip_noop,
      ref: 'trigger'
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_trigger_trigger, tooltip_objectSpread({}, triggerProps), {
      popup: this.getPopupElement(),
      "default": this.$slots["default"]
    });
  }
}));
// CONCATENATED MODULE: ./src/components/vc-tooltip/index.ts

// based on rc-tooltip 3.7.3

/* harmony default export */ var vc_tooltip = (tooltip);
// CONCATENATED MODULE: ./src/components/tooltip/abstract-tooltip-props.ts


var triggerType = vue_types.oneOf(['hover', 'focus', 'click', 'contextmenu']);
/* harmony default export */ var abstract_tooltip_props = (function () {
  return {
    trigger: vue_types.oneOfType([triggerType, vue_types.arrayOf(triggerType)]).def('hover'),
    visible: vue_types.bool,
    defaultVisible: vue_types.bool,
    placement: vue_types.oneOf(['top', 'left', 'right', 'bottom', 'topLeft', 'topRight', 'bottomLeft', 'bottomRight', 'leftTop', 'leftBottom', 'rightTop', 'rightBottom']).def('top'),
    transitionName: vue_types.string.def('zoom-big-fast'),
    // onVisibleChange: PropTypes.func,
    overlayStyle: vue_types.object.def(function () {
      return {};
    }),
    overlayClassName: vue_types.string,
    prefixCls: vue_types.string,
    mouseEnterDelay: vue_types.number.def(0.1),
    mouseLeaveDelay: vue_types.number.def(0.1),
    getPopupContainer: vue_types.func,
    arrowPointAtCenter: vue_types.bool.def(false),
    autoAdjustOverflow: vue_types.oneOfType([vue_types.bool, vue_types.object]).def(true),
    destroyTooltipOnHide: vue_types.bool.def(false),
    align: vue_types.object.def(function () {
      return {};
    }),
    builtinPlacements: vue_types.object,
    onVisibleChange: vue_types.func
  };
});
// CONCATENATED MODULE: ./src/components/tooltip/placements.ts


var autoAdjustOverflowEnabled = {
  adjustX: 1,
  adjustY: 1
};
var autoAdjustOverflowDisabled = {
  adjustX: 0,
  adjustY: 0
};
var placements_targetOffset = [0, 0];
function getOverflowOptions(autoAdjustOverflow) {
  if (typeof autoAdjustOverflow === 'boolean') {
    return autoAdjustOverflow ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
  }

  return Object.assign(Object.assign({}, autoAdjustOverflowDisabled), autoAdjustOverflow);
}
function placements_getPlacements(config) {
  var _config$arrowWidth = config.arrowWidth,
      arrowWidth = _config$arrowWidth === void 0 ? 5 : _config$arrowWidth,
      _config$horizontalArr = config.horizontalArrowShift,
      horizontalArrowShift = _config$horizontalArr === void 0 ? 16 : _config$horizontalArr,
      _config$verticalArrow = config.verticalArrowShift,
      verticalArrowShift = _config$verticalArrow === void 0 ? 12 : _config$verticalArrow,
      _config$autoAdjustOve = config.autoAdjustOverflow,
      autoAdjustOverflow = _config$autoAdjustOve === void 0 ? true : _config$autoAdjustOve;
  var placementMap = {
    left: {
      points: ['cr', 'cl'],
      offset: [-4, 0]
    },
    right: {
      points: ['cl', 'cr'],
      offset: [4, 0]
    },
    top: {
      points: ['bc', 'tc'],
      offset: [0, -4]
    },
    bottom: {
      points: ['tc', 'bc'],
      offset: [0, 4]
    },
    topLeft: {
      points: ['bl', 'tc'],
      offset: [-(horizontalArrowShift + arrowWidth), -4]
    },
    leftTop: {
      points: ['tr', 'cl'],
      offset: [-4, -(verticalArrowShift + arrowWidth)]
    },
    topRight: {
      points: ['br', 'tc'],
      offset: [horizontalArrowShift + arrowWidth, -4]
    },
    rightTop: {
      points: ['tl', 'cr'],
      offset: [4, -(verticalArrowShift + arrowWidth)]
    },
    bottomRight: {
      points: ['tr', 'bc'],
      offset: [horizontalArrowShift + arrowWidth, 4]
    },
    rightBottom: {
      points: ['bl', 'cr'],
      offset: [4, verticalArrowShift + arrowWidth]
    },
    bottomLeft: {
      points: ['tl', 'bc'],
      offset: [-(horizontalArrowShift + arrowWidth), 4]
    },
    leftBottom: {
      points: ['br', 'cl'],
      offset: [-4, verticalArrowShift + arrowWidth]
    }
  };
  Object.keys(placementMap).forEach(function (key) {
    placementMap[key] = config.arrowPointAtCenter ? Object.assign(Object.assign({}, placementMap[key]), {
      overflow: getOverflowOptions(autoAdjustOverflow),
      targetOffset: placements_targetOffset
    }) : Object.assign(Object.assign({}, placements[key]), {
      overflow: getOverflowOptions(autoAdjustOverflow)
    });
    placementMap[key].ignoreShake = true;
  });
  return placementMap;
}
// CONCATENATED MODULE: ./src/components/tooltip/tooltip.tsx


function tooltip_tooltip_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tooltip_tooltip_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tooltip_tooltip_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tooltip_tooltip_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }











var splitObject = function splitObject(obj, keys) {
  var picked = {};
  var omitted = Object.assign({}, obj);
  keys.forEach(function (key) {
    if (obj && key in obj) {
      picked[key] = obj[key];
      delete omitted[key];
    }
  });
  return {
    picked: picked,
    omitted: omitted
  };
};

var tooltip_props = abstract_tooltip_props();
/* harmony default export */ var tooltip_tooltip = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ATooltip',
  props: Object.assign(Object.assign({}, tooltip_props), {
    title: vue_types.any
  }),
  setup: function setup($props, _ref) {
    var emit = _ref.emit,
        $slots = _ref.slots;
    var configProvider = config_provider_useConfigProvider();

    var _useLocalValue = value_useLocalValue(!!$props.defaultVisible, 'visible'),
        sVisible = _useLocalValue.value,
        setLocalVisible = _useLocalValue.setValue;

    var onVisibleChange = function onVisibleChange(visible) {
      setLocalVisible(isNoTitle() ? false : visible);

      if (!isNoTitle()) {
        emit('visibleChange', visible);
      }
    };

    var getPlacements = function getPlacements() {
      var builtinPlacements = $props.builtinPlacements,
          arrowPointAtCenter = $props.arrowPointAtCenter,
          autoAdjustOverflow = $props.autoAdjustOverflow;
      return builtinPlacements || placements_getPlacements({
        arrowPointAtCenter: arrowPointAtCenter,
        verticalArrowShift: 8,
        autoAdjustOverflow: autoAdjustOverflow
      });
    };

    var getDisabledCompatibleChildren = function getDisabledCompatibleChildren(ele) {
      var options = ele.componentOptions && ele.componentOptions.Ctor.options || {};

      if ((options.__ANT_BUTTON === true || options.__ANT_SWITCH === true || options.__ANT_CHECKBOX === true) && (ele.componentOptions.propsData.disabled || ele.componentOptions.propsData.disabled === '') || ele.tag === 'button' && ele.data && ele.data.attrs && ele.data.attrs.disabled !== undefined) {
        // Pick some layout related style properties up to span
        // Prevent layout bugs like https://github.com/ant-design/ant-design/issues/5254
        var _splitObject = splitObject(getStyleFromInstance(ele), ['position', 'left', 'right', 'top', 'bottom', 'float', 'display', 'zIndex']),
            picked = _splitObject.picked,
            omitted = _splitObject.omitted;

        var spanStyle = Object.assign(Object.assign({
          display: 'inline-block'
        }, picked), {
          cursor: 'not-allowed',
          width: ele.componentOptions.propsData.block ? '100%' : null
        });
        var buttonStyle = Object.assign(Object.assign({}, omitted), {
          pointerEvents: 'none'
        });
        var spanCls = getClassFromVNode(ele);
        var child = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(ele, {
          style: buttonStyle,
          "class": null
        });
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
          "style": spanStyle,
          "class": spanCls
        }, [child]);
      }

      return ele;
    };

    var isNoTitle = function isNoTitle() {
      var title = getComponentFromContext({
        $props: $props,
        $slots: $slots
      }, 'title');
      return !title && title !== 0;
    };

    var getOverlay = function getOverlay() {
      var title = getComponentFromContext({
        $props: $props,
        $slots: $slots
      }, 'title');

      if (title === 0) {
        return title;
      }

      return title || '';
    }; // 动态设置动画点


    var onPopupAlign = function onPopupAlign(domNode, align) {
      var placements = getPlacements(); // 当前返回的位置

      var placement = Object.keys(placements).filter(function (key) {
        return placements[key].points[0] === align.points[0] && placements[key].points[1] === align.points[1];
      })[0];

      if (!placement) {
        return;
      } // 根据当前坐标设置动画点


      var rect = domNode.getBoundingClientRect();
      var transformOrigin = {
        top: '50%',
        left: '50%'
      };

      if (placement.indexOf('top') >= 0 || placement.indexOf('Bottom') >= 0) {
        transformOrigin.top = "".concat(rect.height - align.offset[1], "px");
      } else if (placement.indexOf('Top') >= 0 || placement.indexOf('bottom') >= 0) {
        transformOrigin.top = "".concat(-align.offset[1], "px");
      }

      if (placement.indexOf('left') >= 0 || placement.indexOf('Right') >= 0) {
        transformOrigin.left = "".concat(rect.width - align.offset[0], "px");
      } else if (placement.indexOf('right') >= 0 || placement.indexOf('Left') >= 0) {
        transformOrigin.left = "".concat(-align.offset[0], "px");
      }

      domNode.style.transformOrigin = "".concat(transformOrigin.left, " ").concat(transformOrigin.top);
    };

    return {
      sVisible: sVisible,
      configProvider: configProvider,
      getOverlay: getOverlay,
      onPopupAlign: onPopupAlign,
      onVisibleChange: onVisibleChange,
      getPlacements: getPlacements,
      isNoTitle: isNoTitle,
      getDisabledCompatibleChildren: getDisabledCompatibleChildren
    };
  },
  render: function render(ctx) {
    var componentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var $props = this.$props,
        $slots = this.$slots;

    if (!$slots["default"]) {
      return null;
    }

    var customizePrefixCls = $props.prefixCls,
        getPopupContainer = $props.getPopupContainer;
    var getContextPopupContainer = this.configProvider.getPopupContainer;
    var getPrefixCls = ctx.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('tooltip', customizePrefixCls);
    var children = ($slots["default"]() || []).filter(function (c) {
      return typeof c.children !== 'string' || c.children.trim() !== '';
    });
    children = children.length === 1 ? children[0] : children;
    var sVisible = ctx.sVisible; // Hide tooltip when there is no title

    if (!hasProp(componentInstance, 'visible') && this.isNoTitle()) {
      sVisible = false;
    }

    if (!children) {
      return null;
    }

    var child = ctx.getDisabledCompatibleChildren(isValidElement(children) ? children : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {}, [children]));

    var childCls = defineProperty_default()({}, "".concat(prefixCls, "-open"), true);

    var tooltipProps = Object.assign(Object.assign({}, $props), {
      prefixCls: prefixCls,
      getTooltipContainer: getPopupContainer || getContextPopupContainer,
      builtinPlacements: ctx.getPlacements(),
      overlay: ctx.getOverlay(),
      visible: sVisible,
      ref: 'tooltip',
      onVisibleChange: this.onVisibleChange,
      onPopupAlign: this.onPopupAlign
    });

    if (sVisible) {
      if (child["class"]) {
        child["class"] = classnames_default()(child["class"], 'ant-menu-item-selected', childCls);
      } else {
        child["class"] = classnames_default()(childCls);
      }
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_tooltip, tooltip_tooltip_objectSpread({
      "target": child
    }, tooltipProps), [child]);
  }
}));
// CONCATENATED MODULE: ./src/components/tooltip/index.ts



/* istanbul ignore next */

tooltip_tooltip.install = function (Vue) {
  Vue.use(base);
  Vue.component(tooltip_tooltip.name, tooltip_tooltip);
};

/* harmony default export */ var components_tooltip = (tooltip_tooltip);
// CONCATENATED MODULE: ./src/components/menu/menu-item.tsx


function menu_item_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function menu_item_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { menu_item_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { menu_item_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }








var itemProps = {
  attribute: vue_types.object,
  active: vue_types.bool,
  disabled: vue_types.bool,
  title: vue_types.any,
  index: vue_types.number,
  inlineIndent: vue_types.number.def(24),
  level: vue_types.number.def(1),
  parentMenu: vue_types.object,
  multiple: vue_types.bool,
  value: vue_types.any,
  role: vue_types.any,
  subMenuKey: vue_types.string,
  itemIcon: vue_types.any,
  rootPrefixCls: vue_types.string // clearSubMenuTimers: PropTypes.func.def(noop),

};
/* harmony default export */ var menu_item = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AMenuItem',
  inheritAttrs: false,
  props: itemProps,
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var subMenuContext = sub_menu_useSubMenuContext();
    var menuContext = menu_useMenuContext();
    var onMenuClick = menuContext.onMenuClick;
    var key = key_useKey();

    if (subMenuContext) {
      subMenuContext.registerMenu(key);
    }

    var componentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var layoutSiderContext = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('layoutSiderContext');
    var menuItemRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var onKeyDown = function onKeyDown(e) {
      menuItemRef.value.onKeyDown(e);
    };

    var setMenuItem = function setMenuItem(el) {
      menuItemRef.value = el;
    };

    var active = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.active);

    var onMouseEnter = function onMouseEnter() {
      if (props.disabled !== true) {
        active.value = true;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        emit.apply(void 0, ['mouseenter'].concat(args));
        menuContext.setHoverItem(key);
      }
    };

    var onMouseLeave = function onMouseLeave() {
      if (props.disabled !== true) {
        active.value = false;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        emit.apply(void 0, ['mouseleave'].concat(args));
        menuContext.removeHoverItem(key);
      }
    };

    var isSelected = function isSelected() {
      return menuContext.getSelectedKeys().includes(key);
    };

    var onClick = function onClick(e) {
      if (props.disabled) {
        return;
      }

      var info = {
        key: key,
        keyPath: [key],
        item: componentInstance,
        domEvent: e
      };
      emit('click', info);
      subMenuContext === null || subMenuContext === void 0 ? void 0 : subMenuContext.onMenuItemClick(info);
      onMenuClick(info);

      if (menuContext.multiple) {
        if (isSelected()) {
          menuContext.deactiveMenu(info);
        } else {
          menuContext.activeMenu(info);
        }
      } else {
        menuContext.activeMenu(info);
      }
    };

    var level = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function () {
      return subMenuContext ? subMenuContext.level + 1 : props.level;
    });

    var renderItemIcon = function renderItemIcon() {
      return props_util_getComponentFromProp(componentInstance, 'itemIcon', props) || menuContext.itemIcon;
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      if (subMenuContext) {
        subMenuContext.unregisterMenu(key);
      }
    });
    return {
      renderItemIcon: renderItemIcon,
      onMouseEnter: onMouseEnter,
      level: level,
      onClick: onClick,
      isSelected: isSelected,
      onMouseLeave: onMouseLeave,
      active: active,
      menuContext: menuContext,
      onKeyDown: onKeyDown,
      layoutSiderContext: layoutSiderContext,
      setMenuItem: setMenuItem
    };
  },
  render: function render(ctx) {
    var _className;

    var _a;

    var props = this.$props;
    var menuContext = this.menuContext;
    var getInlineCollapsed = menuContext.getInlineCollapsed,
        getMode = menuContext.getMode;
    var collapsed = getInlineCollapsed();
    var rootPrefixCls = props.rootPrefixCls || menuContext.rootPrefixCls;
    var level = this.level,
        title = this.title;
    var tooltipProps = {
      title: title || (level === 1 ? this.$slots["default"] && this.$slots["default"]() : '')
    };
    var siderCollapsed = (_a = ctx.layoutSiderContext) === null || _a === void 0 ? void 0 : _a.collapse;

    if (!siderCollapsed && !collapsed) {
      tooltipProps.title = null; // Reset `visible` to fix control mode tooltip display not correct
      // ref: https://github.com/ant-design/ant-design/issues/16742

      tooltipProps.visible = false;
    }

    var toolTipProps = Object.assign(Object.assign({}, tooltipProps), {
      placement: 'right',
      overlayClassName: "".concat(rootPrefixCls, "-inline-collapsed-tooltip")
    });
    var getPrefixCls = "".concat(rootPrefixCls, "-item");
    var className = (_className = {}, defineProperty_default()(_className, getPrefixCls, true), defineProperty_default()(_className, "".concat(getPrefixCls, "-active"), !props.disabled && ctx.active), defineProperty_default()(_className, "".concat(getPrefixCls, "-selected"), this.isSelected()), defineProperty_default()(_className, "".concat(getPrefixCls, "-disabled"), props.disabled), _className);
    var liProps = Object.assign(Object.assign({}, props.attribute), {
      title: props.title,
      role: props.role || 'menuitem',
      'aria-disabled': props.disabled
    });

    if (props.role === 'option') {
      liProps.role = 'option';
      liProps['aria-selected'] = this.isSelected();
    } else if (props.role === null || props.role === 'none') {
      liProps.role = 'none';
    } // In case that onClick/onMouseLeave/onMouseEnter is passed down from owner


    Object.assign(liProps, {
      onClick: this.onClick,
      onMouseenter: ctx.onMouseEnter,
      onMouseleave: ctx.onMouseLeave
    });
    var style = {};

    if (getMode() === 'inline' && !collapsed) {
      style.paddingLeft = "".concat(props.inlineIndent * level, "px");
    }

    var menuItem = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", menu_item_objectSpread({
      "ref": ctx.setMenuItem
    }, liProps, {
      "style": style,
      "class": className
    }), [this.$slots["default"] && this.$slots["default"](), ctx.renderItemIcon()]);

    if (collapsed) {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_tooltip, menu_item_objectSpread({}, toolTipProps), [menuItem]);
    }

    return menuItem;
  }
}));
// CONCATENATED MODULE: ./src/components/menu/menu-item-group.tsx


function menu_item_group_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function menu_item_group_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { menu_item_group_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { menu_item_group_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




 // import { menuAllProps } from './util'

var MenuItemGroup = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AMenuItemGroup',
  props: {
    index: vue_types.number,
    subMenuKey: vue_types.string,
    disabled: vue_types.bool.def(true),
    title: vue_types.any
  },
  setup: function setup() {
    return {};
  },
  render: function render() {
    var props = Object.assign({}, this.$props);
    var title = props.title;

    var _useMenuContext = menu_useMenuContext(),
        rootPrefixCls = _useMenuContext.rootPrefixCls;

    var componentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var titleClassName = "".concat(rootPrefixCls, "-item-group-title");
    var listClassName = "".concat(rootPrefixCls, "-item-group-list");
    var listeners = Object.assign({}, getListenersFromInstance(componentInstance));
    delete listeners.onClick;
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", menu_item_group_objectSpread({
      "class": "".concat(rootPrefixCls, "-item-group")
    }, listeners), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": titleClassName,
      "title": typeof title === 'string' ? title : undefined
    }, [props_util_getComponentFromProp(componentInstance, 'title')]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("ul", {
      "class": listClassName
    }, [this.$slots["default"] && this.$slots["default"]()])]);
  }
});
/* harmony default export */ var menu_item_group = (MenuItemGroup);
// EXTERNAL MODULE: ./src/components/style/index.less
var components_style = __webpack_require__("0c75");

// EXTERNAL MODULE: ./src/components/menu/style/index.less
var menu_style = __webpack_require__("7244");

// EXTERNAL MODULE: ./src/components/tooltip/style/index.less
var tooltip_style = __webpack_require__("34b2");

// CONCATENATED MODULE: ./src/components/tooltip/style/index.js



// CONCATENATED MODULE: ./src/components/menu/style/index.js


 // style dependencies
// deps-lint-skip: layout


// CONCATENATED MODULE: ./src/components/menu/index.tsx















var menu_useMenuContext = function useMenuContext() {
  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(utils_ProvideKeys.MenuContext) || {
    multiple: false,
    openAnimation: null,
    setHoverItem: function setHoverItem(key) {},
    getMode: function getMode() {
      return 'inline';
    },
    removeHoverItem: function removeHoverItem(key) {},
    getHoverKey: function getHoverKey() {
      return undefined;
    },
    getSelectedKeys: function getSelectedKeys() {
      return [];
    },
    rootPrefixCls: 'ant-menu',
    openTransitionName: 'slide-up',
    triggerSubMenuAction: 'click',
    itemIcon: null,
    activeMenu: function activeMenu(info) {},
    deactiveMenu: function deactiveMenu(info) {},
    inlineIndent: 24,
    onMenuClick: function onMenuClick(info) {},
    getTheme: function getTheme() {
      return 'light';
    }
  };
};
var MenuMode = vue_types.oneOf(['vertical', 'vertical-left', 'vertical-right', 'horizontal', 'inline']);
var menu_menuProps = {
  prefixCls: vue_types.string.def('ant-menu'),
  focusable: vue_types.bool.def(true),
  multiple: vue_types.bool,
  defaultActiveFirst: vue_types.bool,
  visible: vue_types.bool.def(true),
  activeKey: vue_types.oneOfType([vue_types.string, vue_types.number]),
  selectedKeys: vue_types.arrayOf(vue_types.oneOfType([vue_types.string, vue_types.number])),
  defaultSelectedKeys: vue_types.arrayOf(vue_types.oneOfType([vue_types.string, vue_types.number])).def([]),
  defaultOpenKeys: vue_types.arrayOf(vue_types.oneOfType([vue_types.string, vue_types.number])).def([]),
  openKeys: vue_types.arrayOf(vue_types.oneOfType([vue_types.string, vue_types.number])),
  openAnimation: vue_types.oneOfType([vue_types.string, vue_types.object]),
  mode: vue_types.oneOf(['horizontal', 'vertical', 'vertical-left', 'vertical-right', 'inline']).def('vertical'),
  triggerSubMenuAction: vue_types.string.def('hover'),
  subMenuOpenDelay: vue_types.number.def(0.1),
  subMenuCloseDelay: vue_types.number.def(0.1),
  level: vue_types.number.def(1),
  inlineIndent: vue_types.number.def(24),
  theme: vue_types.oneOf(['light', 'dark']).def('light'),
  getPopupContainer: vue_types.func,
  openTransitionName: vue_types.string.def('slide-up'),
  uniqueOpen: vue_types.bool.def(false),
  forceSubMenuRender: vue_types.bool,
  isRootMenu: vue_types.bool.def(true),
  builtinPlacements: vue_types.object.def(function () {
    return {};
  }),
  itemIcon: vue_types.any,
  expandIcon: vue_types.any,
  overflowedIndicator: vue_types.any,
  selectable: vue_types.bool.def(true),
  inlineCollapsed: vue_types.bool
};
var Menu = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AMenu',
  props: menu_menuProps,
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var layoutSiderContext = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('layoutSiderContext') || {};

    var getInlineCollapsed = function getInlineCollapsed() {
      var inlineCollapsed = props.inlineCollapsed;

      if (layoutSiderContext.sCollapsed !== undefined) {
        return layoutSiderContext.sCollapsed;
      }

      return inlineCollapsed;
    };

    var propsUpdating = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      propsUpdating.value = false;
    });
    var switchingModeFromInline = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.mode;
    }, function (val, oldVal) {
      if (oldVal === 'inline' && val !== 'inline') {
        switchingModeFromInline.value = true;
      }
    });

    var _useLocalValue = value_useLocalValue(props.defaultOpenKeys, 'openKeys'),
        openKeys = _useLocalValue.value,
        getOpenKeys = _useLocalValue.getValue,
        setOpenKeys = _useLocalValue.setValue;

    var inlineOpenKeys = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])([]);

    var collapsedChange = function collapsedChange(val) {
      if (propsUpdating.value) {
        return;
      }

      propsUpdating.value = true;

      if (props.openKeys === undefined) {
        if (val) {
          switchingModeFromInline.value = true;
          inlineOpenKeys.value = openKeys.value;
          openKeys.value = [];
        } else {
          openKeys.value = inlineOpenKeys.value;
          inlineOpenKeys.value = [];
        }
      } else if (val) {
        // 缩起时，openKeys置为空的动画会闪动，react可以通过是否传递openKeys避免闪动，vue不是很方便动态传递openKeys
        switchingModeFromInline.value = true;
      }
    };

    var restoreModeVerticalFromInline = function restoreModeVerticalFromInline() {
      if (switchingModeFromInline.value) {
        switchingModeFromInline.value = false;
      }
    };

    var handleMouseEnter = function handleMouseEnter(e) {
      restoreModeVerticalFromInline();
      emit('mouseenter', e);
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.inlineCollapsed;
    }, function (val) {
      collapsedChange(val);
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return layoutSiderContext.sCollapsed;
    }, function (val) {
      collapsedChange(val);
    });

    var handleTransitionEnd = function handleTransitionEnd(e) {
      // when inlineCollapsed menu width animation finished
      // https://github.com/ant-design/ant-design/issues/12864
      var widthCollapsed = e.propertyName === 'width' && e.target === e.currentTarget; // Fix SVGElement e.target.className.indexOf is not a function
      // https://github.com/ant-design/ant-design/issues/15699

      var className = e.target.className; // SVGAnimatedString.animVal should be identical to SVGAnimatedString.baseVal, unless during an animation.

      var classNameValue = Object.prototype.toString.call(className) === '[object SVGAnimatedString]' ? className.animVal : className; // Fix for <Menu style={{ width: '100%' }} />, the width transition won't trigger when menu is collapsed
      // https://github.com/ant-design/ant-design-pro/issues/2783

      var iconScaled = e.propertyName === 'font-size' && classNameValue.indexOf('anticon') >= 0;

      if (widthCollapsed || iconScaled) {
        restoreModeVerticalFromInline();
      }
    };

    var handleClick = function handleClick(e) {
      handleOpenChange([]);
      emit('click', e);
    };

    var handleSelect = function handleSelect(info) {
      emit('select', info);
      emit('selectChange', info.selectedKeys);
    };

    var handleDeselect = function handleDeselect(info) {
      emit('deselect', info);
      emit('selectChange', info.selectedKeys);
    };

    var handleOpenChange = function handleOpenChange(event) {
      var tmpOpenKeys = [].concat(getOpenKeys());
      var openedKeys = [];
      var removedKey = null;

      if (Array.isArray(event)) {
        if (event[event.length - 1].open) {
          openedKeys = event.map(function (it) {
            return it.key;
          });
        } else {
          openedKeys = event.filter(function (it) {
            return it.open;
          }).map(function (it) {
            return it.key;
          });
        }

        removedKey = event[event.length - 1].open ? null : event[event.length - 1].key;
      } else {
        openedKeys = event.open ? [event.key] : [];
        removedKey = event.open ? null : event.key;
      }

      if (props.uniqueOpen) {
        tmpOpenKeys = openedKeys;
      } else {
        openedKeys.forEach(function (key) {
          if (!tmpOpenKeys.includes(key)) {
            tmpOpenKeys.push(key);
          }
        });

        if (tmpOpenKeys.includes(removedKey)) {
          tmpOpenKeys.splice(tmpOpenKeys.indexOf(removedKey), 1);
        }
      }

      setOpenKeys(tmpOpenKeys);
      emit('openChange', tmpOpenKeys);
    };

    var getRealMenuMode = function getRealMenuMode() {
      var inlineCollapsed = getInlineCollapsed();
      var mode = props.mode;
      return inlineCollapsed ? 'vertical' : mode;
    };

    var getMenuOpenAnimation = function getMenuOpenAnimation(menuMode) {
      var openAnimation = props.openAnimation,
          openTransitionName = props.openTransitionName;
      var menuOpenAnimation = openAnimation || openTransitionName;

      if (openAnimation === undefined && openTransitionName === undefined) {
        if (menuMode === 'horizontal') {
          menuOpenAnimation = 'slide-up';
        } else if (menuMode === 'inline') {
          menuOpenAnimation = {
            on: _util_openAnimation
          };
        } else {
          // When mode switch from inline
          // submenu should hide without animation
          if (switchingModeFromInline) {
            menuOpenAnimation = '';
            switchingModeFromInline.value = false;
          } else {
            menuOpenAnimation = 'zoom-big';
          }
        }
      }

      return menuOpenAnimation;
    };

    var _useLocalValue2 = value_useLocalValue(props.defaultSelectedKeys, 'selectedKeys'),
        selectedKeys = _useLocalValue2.value,
        setSelectedKeys = _useLocalValue2.setValue;

    var onSelect = function onSelect(info) {
      if (props.selectable) {
        // root menu
        var tmpSelectedKeys = selectedKeys.value;
        var selectedKey = info.key;

        if (props.multiple) {
          tmpSelectedKeys = tmpSelectedKeys.concat([selectedKey]);
        } else {
          tmpSelectedKeys = [selectedKey];
        }

        setSelectedKeys(tmpSelectedKeys);
        emit('select', Object.assign(Object.assign({}, info), {
          selectedKeys: tmpSelectedKeys
        }));
      }
    };

    var onDeselect = function onDeselect(info) {
      if (props.selectable) {
        var tmpSelectedKeys = selectedKeys.value;
        var selectedKey = info.key;
        var index = tmpSelectedKeys.indexOf(selectedKey);

        if (index !== -1) {
          tmpSelectedKeys.splice(index, 1);
        }

        if (props.selectedKeys === undefined) {
          setSelectedKeys(tmpSelectedKeys);
        }

        emit('deselect', Object.assign(Object.assign({}, info), {
          selectedKeys: tmpSelectedKeys
        }));
      }
    };

    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var hoverKey = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var menuContext = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["reactive"])({
      openAnimation: props.openAnimation,
      instance: instance,
      getHoverKey: function getHoverKey() {
        return hoverKey.value;
      },
      getOpenKeys: getOpenKeys,
      multiple: props.multiple,
      getMode: getRealMenuMode,
      getTheme: function getTheme() {
        return props.theme;
      },
      itemIcon: props.itemIcon,
      rootPrefixCls: props.prefixCls,
      getInlineCollapsed: function getInlineCollapsed() {
        return props.inlineCollapsed;
      },
      inlineIndent: props.inlineIndent,
      openTransitionName: props.openTransitionName,
      triggerSubMenuAction: props.triggerSubMenuAction,
      setHoverItem: function setHoverItem(key) {
        hoverKey.value = key;
      },
      removeHoverItem: function removeHoverItem(key) {
        if (hoverKey.value === key) {
          hoverKey.value = null;
        }
      },
      activeMenu: function activeMenu(menu) {
        onSelect(menu);
      },
      deactiveMenu: function deactiveMenu(menu) {
        onDeselect(menu);
      },
      getSelectedKeys: function getSelectedKeys() {
        return selectedKeys.value;
      },
      onMenuClick: function onMenuClick(info) {
        emit('click', info);
      }
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props;
    }, function (value) {
      menuContext.multiple = value.multiple;
      menuContext.openAnimation = props.openAnimation;
      menuContext.inlineIndent = props.inlineIndent;
      menuContext.rootPrefixCls = props.prefixCls;
      menuContext.openTransitionName = props.openTransitionName;
      menuContext.triggerSubMenuAction = props.triggerSubMenuAction;
      menuContext.itemIcon = props.itemIcon;
    }, {
      deep: true
    });

    if (!Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])(utils_ProvideKeys.MenuContext)) {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])(utils_ProvideKeys.MenuContext, menuContext);
    }

    var configProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('configProvider') || ConfigConsumerProps;
    return {
      handleSelect: handleSelect,
      handleClick: handleClick,
      handleOpenChange: handleOpenChange,
      handleMouseEnter: handleMouseEnter,
      handleDeselect: handleDeselect,
      handleTransitionEnd: handleTransitionEnd,
      layoutSiderContext: layoutSiderContext,
      openKeys: openKeys,
      getInlineCollapsed: getInlineCollapsed,
      getMenuOpenAnimation: getMenuOpenAnimation,
      getRealMenuMode: getRealMenuMode,
      configProvider: configProvider,
      onKeyDown: function onKeyDown(e, callback) {// this.$refs.innerMenu.getWrappedInstance().onKeyDown(e, callback);
      }
    };
  },
  render: function render(ctx) {
    var _this = this,
        _menuClasses;

    var slots = this.$slots,
        props = this.$props;
    var collapsedWidth = ctx.layoutSiderContext.collapsedWidth;
    var getContextPopupContainer = this.configProvider.getPopupContainer;
    var _this$$props = this.$props,
        customizePrefixCls = _this$$props.prefixCls,
        getPopupContainer = _this$$props.getPopupContainer;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('menu', customizePrefixCls);
    var menuMode = this.getRealMenuMode();
    var menuOpenAnimation = this.getMenuOpenAnimation(menuMode);
    var menuProps = Object.assign(Object.assign({}, es(this.$props, ['inlineCollapsed'])), {
      getPopupContainer: getPopupContainer || getContextPopupContainer,
      openKeys: this.openKeys,
      mode: menuMode,
      prefixCls: prefixCls,
      selectedKeys: props.selectedKeys,
      openAnimation: props.openAnimation,
      openTransitionName: props.openTransitionName,
      onClick: props['onClick'],
      onSelect: this.handleSelect,
      onDeselect: this.handleDeselect,
      onOpenChange: this.handleOpenChange,
      onMouseenter: this.handleMouseEnter,
      onTransitionend: this.handleTransitionEnd
    });

    if (props.selectedKeys === undefined) {
      delete menuProps.selectedKeys;
    }

    if (menuMode === 'inline') {
      menuProps.onClick = function (e) {
        _this.$emit('click', e);
      };

      menuProps.openAnimation = menuOpenAnimation;
    } else {
      // closing vertical popup submenu after click it
      menuProps.onClick = this.handleClick;
      menuProps.openTransitionName = menuOpenAnimation;
    } // https://github.com/ant-design/ant-design/issues/8587


    var hideMenu = this.getInlineCollapsed() && (collapsedWidth === 0 || collapsedWidth === '0' || collapsedWidth === '0px');

    if (hideMenu) {
      menuProps.openKeys = [];
    }

    var menuClasses = (_menuClasses = {}, defineProperty_default()(_menuClasses, prefixCls, true), defineProperty_default()(_menuClasses, "".concat(prefixCls, "-").concat(this.getRealMenuMode()), true), defineProperty_default()(_menuClasses, "".concat(prefixCls, "-inline-collapsed"), this.getInlineCollapsed()), defineProperty_default()(_menuClasses, "".concat(prefixCls, "-root"), this.isRootMenu), defineProperty_default()(_menuClasses, "".concat(prefixCls, "-").concat(this.$props.theme), true), _menuClasses);
    var childProps = {
      rootPrefixCls: this.prefixCls,
      onOpenChange: this.handleOpenChange
    };
    var expandIcon = getComponentFromContext(this, 'expandIcon', props);

    if (expandIcon) {// todo
      // childProps.expandIcon = expandIcon;
    }

    var children = (slots["default"] && slots["default"]() || []).map(function (child) {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(child, childProps);
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("ul", {
      "role": "menu",
      "class": menuClasses
    }, [children]);
  }
});
Menu.Divider = divider;
Menu.ItemGroup = menu_item_group;
Menu.Item = menu_item;
Menu.SubMenu = sub_menu;
/* istanbul ignore next */

Menu.install = function (app) {
  app.use(base);
  app.component(Menu.name, Menu);
  app.component(Menu.Item.name, Menu.Item);
  app.component(Menu.SubMenu.name, Menu.SubMenu);
  app.component(Menu.Divider.name, Menu.Divider);
  app.component(Menu.ItemGroup.name, Menu.ItemGroup);
};

/* harmony default export */ var components_menu = (Menu);
// CONCATENATED MODULE: ./src/components/_util/env.ts


/* eslint-disable no-undef */
// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);
// CONCATENATED MODULE: ./src/components/select/opt-group.tsx


/* harmony default export */ var opt_group = ({
  props: {
    value: vue_types.oneOfType([vue_types.string, vue_types.number]),
    label: vue_types.oneOfType([vue_types.string, vue_types.number])
  },
  isSelectOptGroup: true
});
// CONCATENATED MODULE: ./src/components/select/option.tsx


/* harmony default export */ var select_option = ({
  props: {
    value: vue_types.oneOfType([vue_types.string, vue_types.number]),
    label: vue_types.oneOfType([vue_types.string, vue_types.number]),
    disabled: vue_types.bool,
    title: vue_types.oneOfType([vue_types.string, vue_types.number])
  },
  isSelectOption: true
});
// CONCATENATED MODULE: ./src/components/select/index.tsx


function select_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function select_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { select_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { select_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

























var select_BUILT_IN_PLACEMENTS = {
  bottomLeft: {
    points: ['tl', 'bl'],
    offset: [0, 4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topLeft: {
    points: ['bl', 'tl'],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
var SELECT_EMPTY_VALUE_KEY = 'RC_SELECT_EMPTY_VALUE_KEY';
var Value = vue_types.shape({
  key: vue_types.oneOfType([vue_types.string, vue_types.number])
}).loose;
var SelectValue = vue_types.oneOfType([vue_types.string, vue_types.number, vue_types.arrayOf(vue_types.oneOfType([Value, vue_types.string, vue_types.number])), Value]);
var SelectProps = {
  allowClear: vue_types.bool.def(false),
  autoFocus: vue_types.bool,
  autoClearSearchValue: vue_types.bool.def(true),
  backfill: vue_types.bool.def(false),
  choiceTransitionName: vue_types.string,
  disabled: vue_types.bool,
  defaultActiveFirstOption: vue_types.bool,
  dropdownClassName: vue_types.string,
  dropdownStyle: vue_types.any,
  dropdownMenuStyle: vue_types.any,
  dropdownMatchSelectWidth: vue_types.bool.def(true),
  defaultValue: SelectValue,
  defaultOpen: vue_types.bool.def(false),
  dropdownRender: vue_types.func.def(function () {
    return function (menu) {
      return menu;
    };
  }),
  // onSearch: (value: string) => any,
  filterOption: vue_types.oneOfType([vue_types.bool, vue_types.func]),
  notFoundContent: vue_types.any.def('暂无数据'),
  placeholder: vue_types.any.def(''),
  prefixCls: vue_types.string.def('ant-select'),
  size: vue_types.oneOf(['small', 'large', 'default']),
  showAction: vue_types.oneOfType([vue_types.string, vue_types.arrayOf(String)]).def(function () {
    return ['click'];
  }),
  showSearch: vue_types.bool.def(true),
  transitionName: vue_types.string,
  tabIndex: vue_types.number,
  showArrow: vue_types.bool,
  getPopupContainer: vue_types.func,
  open: vue_types.bool,
  loading: vue_types.bool,
  value: SelectValue,
  // mode: PropTypes.oneOf(['default', 'multiple', 'tags', 'combobox']),
  mode: vue_types.string,
  optionLabelProp: vue_types.string,
  firstActiveValue: vue_types.oneOfType([String, vue_types.arrayOf(String)]),
  maxTagCount: vue_types.number,
  maxTagPlaceholder: vue_types.any,
  maxTagTextLength: vue_types.number,
  optionFilterProp: vue_types.string.def('value'),
  labelInValue: vue_types.bool,
  tokenSeparators: vue_types.arrayOf(vue_types.string).def(function () {
    return [];
  }),
  getInputElement: vue_types.func,
  options: vue_types.array,
  suffixIcon: vue_types.any,
  removeIcon: vue_types.any,
  clearIcon: vue_types.any,
  menuItemSelectedIcon: vue_types.any
};
var SelectPropTypes = {
  prefixCls: vue_types.string,
  size: vue_types.oneOf(['default', 'large', 'small']),
  // combobox: PropTypes.bool,
  notFoundContent: vue_types.any,
  showSearch: vue_types.bool,
  transitionName: vue_types.string,
  choiceTransitionName: vue_types.string
};

var SECRET_COMBOBOX_MODE_DO_NOT_USE = 'SECRET_COMBOBOX_MODE_DO_NOT_USE';
var select_Select = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  SECRET_COMBOBOX_MODE_DO_NOT_USE: SECRET_COMBOBOX_MODE_DO_NOT_USE,
  Option: Object.assign(Object.assign({}, select_option), {
    name: 'ASelectOption'
  }),
  OptGroup: Object.assign(Object.assign({}, opt_group), {
    name: 'ASelectOptGroup'
  }),
  name: 'ASelect',
  props: Object.assign(Object.assign({}, SelectProps), {
    showSearch: vue_types.bool.def(false),
    transitionName: vue_types.string.def('slide-up'),
    choiceTransitionName: vue_types.string.def('zoom')
  }),
  setup: function setup($props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots,
        attrs = _ref.attrs;

    var _useBaseInput = base_input_useBaseInput(),
        _emit = _useBaseInput._emit;

    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var firstActiveItem = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var _mouseDown = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    /**
     * 获取选项值对应的选项信息
     * @param value
     * @param optionsInfo
     * @return {any}
     */


    var getOptionInfoBySingleValue = function getOptionInfoBySingleValue(value, optionsInfo) {
      var copyOptionsInfo = optionsInfo || _optionsInfo.value;

      if (copyOptionsInfo[getMapKey(value)]) {
        return copyOptionsInfo[getMapKey(value)];
      }

      var defaultLabel = value;

      if ($props.labelInValue) {
        var valueLabel = getLabelFromPropsValue($props.value, value);
        var defaultValueLabel = getLabelFromPropsValue($props.defaultValue, value);

        if (valueLabel !== undefined) {
          defaultLabel = valueLabel;
        } else if (defaultValueLabel !== undefined) {
          defaultLabel = defaultValueLabel;
        }
      }

      return {
        option: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(select_option, {
          "value": value,
          "key": value
        }, [value]),
        value: value,
        label: defaultLabel
      };
    };

    var getInputValueForCombobox = function getInputValueForCombobox(props, optionsInfo, useDefaultValue) {
      var value = [];

      if ('value' in props && !useDefaultValue) {
        value = toArray(props.value);
      }

      if ('defaultValue' in props && useDefaultValue) {
        value = toArray(props.defaultValue);
      }

      var first = null;

      if (value.length) {
        first = value[0];
      } else {
        return '';
      }

      var label = first;

      if (props.labelInValue) {
        label = first.label;
      } else if (optionsInfo[getMapKey(first)]) {
        label = optionsInfo[getMapKey(first)].label;
      }

      if (label === undefined) {
        label = '';
      }

      return label;
    };

    var getOptionsFromChildren = function getOptionsFromChildren() {
      var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      if (children.length === 1 && children[0].__v_skip) {
        var deepChildren = children[0].children;

        if (Array.isArray(deepChildren)) {
          return getOptionsFromChildren(deepChildren, options);
        } else {
          return getOptionsFromChildren(deepChildren["default"] && deepChildren["default"](), options);
        }
      }

      children.forEach(function (child) {
        if (Array.isArray(child.children)) {
          options.push(child);
          return;
        }

        if (!child.children["default"]) {
          return;
        }

        if (getSlotOptions(child).isSelectOptGroup) {
          getOptionsFromChildren(child.componentOptions.children, options);
        } else {
          options.push(child);
        }
      });
      return options;
    };

    var getOptionLabelProp = function getOptionLabelProp() {
      var optionLabelProp = $props.optionLabelProp;

      if (isCombobox($props)) {
        // children 带 dom 结构时，无法填入输入框
        optionLabelProp = optionLabelProp || 'value';
      }

      return optionLabelProp || 'children';
    };

    var getLabelFromOption = function getLabelFromOption(props, option) {
      return getPropValue(option, getOptionLabelProp());
    };

    var getOptionsInfoFromProps = function getOptionsInfoFromProps(props) {
      var preState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var children = slots["default"] && slots["default"]() || [];
      var options = getOptionsFromChildren(children);
      var optionsInfo = {};
      options.forEach(function (option) {
        var singleValue = getValuePropValue(option);
        optionsInfo[getMapKey(singleValue)] = {
          option: option,
          value: singleValue,
          label: getLabelFromOption(props, option),
          title: getValueByProp(option, 'title'),
          disabled: getValueByProp(option, 'disabled')
        };
      });

      if (preState) {
        // keep option info in pre state value.
        var oldOptionsInfo = _optionsInfo.value;
        var value = _value.value;

        if (value) {
          value.forEach(function (v) {
            var key = getMapKey(v);

            if (!optionsInfo[key] && oldOptionsInfo[key] !== undefined) {
              optionsInfo[key] = oldOptionsInfo[key];
            }
          });
        }
      }

      return optionsInfo;
    };

    var optionsInfo = getOptionsInfoFromProps($props);

    var _inputValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])($props.mode === 'combobox' ? getInputValueForCombobox($props, optionsInfo, true // use default value
    ) : '');

    var _mirrorInputValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(_inputValue.value);

    var _open = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])($props.defaultOpen);

    var _options = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])([]);

    var getValueFromProps = function getValueFromProps() {
      var value = [];

      if ($props.defaultValue !== undefined) {
        value = toArray($props.defaultValue);
      }

      if ($props.value !== undefined) {
        value = toArray($props.value);
      }

      if ($props.labelInValue) {
        value = value.map(function (v) {
          return v.key;
        });
      }

      return value;
    };

    var _optionsInfo = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(optionsInfo);

    var _focused = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);

    var inputClick = function inputClick(e) {
      if (_open.value) {
        clearBlurTime();
        e.stopPropagation();
      } else {
        _focused.value = false;
      }
    };

    var _value = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(getValueFromProps());

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $props.value;
    }, function () {
      _value.value = getValueFromProps();
    });
    var inputRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var getVLBySingleValue = function getVLBySingleValue(value) {
      if ($props.labelInValue) {
        return {
          key: value,
          label: getLabelBySingleValue(value)
        };
      }

      return value;
    };

    var fireSelect = function fireSelect(value) {
      emit('select', getVLBySingleValue(value), getOptionBySingleValue(value));
    };

    var getValueByLabel = function getValueByLabel(label) {
      if (label === undefined) {
        return null;
      }

      var value = null;
      Object.keys(_optionsInfo.value).forEach(function (key) {
        var info = _optionsInfo.value[key];
        var disabled = info.disabled;

        if (disabled) {
          return;
        }

        var oldLable = toArray(info.label);

        if (oldLable && oldLable.join('') === label) {
          value = info.value;
        }
      });
      return value;
    };

    var getValueByInput = function getValueByInput(str) {
      var tokenSeparators = $props.tokenSeparators;
      var multiple = $props.mode === 'multiple';
      var nextValue = _value.value;
      var hasNewValue = false;
      splitBySeparators(str, tokenSeparators).forEach(function (label) {
        var selectedValue = [label];

        if (multiple) {
          var value = getValueByLabel(label);

          if (value && findIndexInValueBySingleValue(nextValue, value) === -1) {
            nextValue = nextValue.concat(value);
            hasNewValue = true;
            fireSelect(value);
          }
        } else if (findIndexInValueBySingleValue(nextValue, label) === -1) {
          nextValue = nextValue.concat(selectedValue);
          hasNewValue = true;
          fireSelect(label);
        }
      });
      return hasNewValue ? nextValue : undefined;
    };

    var inputBlur = function inputBlur(e) {
      var target = e.relatedTarget || document.activeElement; // https://github.com/vueComponent/ant-design-vue/issues/999
      // https://github.com/vueComponent/ant-design-vue/issues/1223

      if ((isIE || isEdge) && (e.relatedTarget === arrowRef.value || target && menuRef.value === target || contains(e.target, target))) {
        e.target.focus();
        e.preventDefault();
        return;
      }

      clearBlurTime();

      if ($props.disabled) {
        e.preventDefault();
        return;
      }

      blurTimer.value = setTimeout(function () {
        _focused.value = false;
        updateFocusClassName();

        if (isSingleMode($props) && $props.showSearch && _inputValue.value && $props.defaultActiveFirstOption) {
          var options = _options.value || [];

          if (options.length) {
            var firstOption = findFirstMenuItem(options);

            if (firstOption) {
              _value.value = [getValuePropValue(firstOption)];
              fireChange(_value.value);
            }
          }
        } else if (isMultipleOrTags($props) && _inputValue.value) {
          if (_mouseDown.value) {
            // need update dropmenu when not blur
            setInputValue('');
          } else {
            // why not use setState?
            _inputValue.value = '';

            if (getInputDOMNode && getInputDOMNode()) {
              getInputDOMNode().value = '';
            }
          }

          var tmpValue = getValueByInput(_inputValue.value);

          if (tmpValue !== undefined) {
            _value.value = tmpValue;
            fireChange(_value.value);
          }
        } // if click the rest space of Select in multiple mode


        if (isMultipleOrTags($props) && _mouseDown.value) {
          maybeFocus(true, true);
          _mouseDown.value = false;
          return;
        }

        setOpenState(false);

        _emit('blur', getVLForOnChange(_value.value));
      }, 200);
    };

    var onInputChange = function onInputChange(e) {
      var _e$target = e.target,
          val = _e$target.value,
          composing = _e$target.composing;

      if (e.isComposing || composing || _inputValue.value === val) {
        _mirrorInputValue.value = val;
        return;
      }

      var tokenSeparators = $props.tokenSeparators;

      if (isMultipleOrTags($props) && tokenSeparators.length && includesSeparators(val, tokenSeparators)) {
        var nextValue = getValueByInput(val);

        if (nextValue !== undefined) {
          fireChange(nextValue);
        }

        setOpenState(false, {
          needFocus: true
        });
        setInputValue('', false);
        return;
      }

      setInputValue(val);
      _open.value = true;

      if (isCombobox($props)) {
        fireChange([val]);
      }
    };

    var topCtrlRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var rootRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var getInputDOMNode = function getInputDOMNode() {
      return topCtrlRef.value ? topCtrlRef.value.querySelector('input,textarea,div[contentEditable]') : inputRef.value;
    };

    var updateFocusClassName = function updateFocusClassName() {
      // avoid setState and its side effect
      if (_focused.value) {
        component_classes_default()(rootRef.value).add("".concat($props.prefixCls, "-focused"));
      } else {
        component_classes_default()(rootRef.value).remove("".concat($props.prefixCls, "-focused"));
      }
    };

    var inputMirrorRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var focusTimer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var clearFocusTime = function clearFocusTime() {
      if (focusTimer.value) {
        clearTimeout(focusTimer.value);
        focusTimer.value = null;
      }
    };

    var timeoutFocus = function timeoutFocus() {
      if (focusTimer.value) {
        clearFocusTime();
      }

      focusTimer.value = window.setTimeout(function () {
        emit('focus');
        setOpenState(true);
      }, 10);
    };

    var inputFocus = function inputFocus(e) {
      if ($props.disabled) {
        e.preventDefault();
        return;
      }

      clearBlurTime(); // In IE11, onOuterFocus will be trigger twice when focus input
      // First one: e.target is div
      // Second one: e.target is input
      // other browser only trigger second one
      // https://github.com/ant-design/ant-design/issues/15942
      // Here we ignore the first one when e.target is div

      var inputNode = getInputDOMNode();

      if (inputNode && e.target === rootRef.value) {
        return;
      }

      if (!isMultipleOrTagsOrCombobox($props) && e.target === inputNode) {
        return;
      }

      if (_focused.value) {
        return;
      }

      _focused.value = true;
      updateFocusClassName(); // only effect multiple or tag mode

      if (!isMultipleOrTags($props) || !_mouseDown.value) {
        timeoutFocus();
      }
    };

    var _getInputElement = function _getInputElement() {
      var defaultInput = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", {
        "id": attrs.id,
        "autocomplete": "off"
      }, []);
      var inputElement = $props.getInputElement ? $props.getInputElement() : defaultInput;
      var inputCls = classnames_default()(getClassFromVNode(inputElement), defineProperty_default()({}, "".concat($props.prefixCls, "-search__field"), true));
      var inputEvents = getListenersFromVNode(inputElement); // https://github.com/ant-design/ant-design/issues/4992#issuecomment-281542159
      // Add space to the end of the inputValue as the width measurement tolerance

      inputElement.data = inputElement.data || {};
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": "".concat($props.prefixCls, "-search__field__wrap"),
        "onClick": inputClick
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(inputElement, Object.assign(Object.assign({}, inputElement.props || {}), {
        disabled: $props.disabled,
        value: _inputValue.value,
        "class": inputCls,
        ref: function ref(el) {
          return inputRef.value = el;
        },
        onInput: onInputChange,
        onKeydown: chaining(onInputKeydown, inputEvents.onKeydown, attrs.onInputKeydown),
        onFocus: chaining(inputFocus, inputEvents.onFocus),
        onBlur: chaining(inputBlur, inputEvents.onBlur)
      })), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "ref": function ref(el) {
          return inputMirrorRef.value = el;
        },
        "class": "".concat($props.prefixCls, "-search__field__mirror")
      }, [_mirrorInputValue.value, "\xA0"])]);
    };

    var children = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function () {
      return $props.options ? $props.options.map(function (option) {
        var key = option.key,
            _option$label = option.label,
            label = _option$label === void 0 ? option.title : _option$label,
            on = option.on,
            cls = option["class"],
            style = option.style,
            restOption = __rest(option, ["key", "label", "on", "class", "style"]);

        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(select_option, select_objectSpread({
          "key": key
        }, {
          props: restOption,
          on: on,
          "class": cls,
          style: style
        }), [label]);
      }) : filterEmpty(slots["default"]);
    });

    var openIfHasChildren = function openIfHasChildren() {
      if (children.value && children.value.length || isSingleMode($props)) {
        setOpenState(true);
      }
    };

    var isChildDisabled = function isChildDisabled(key) {
      return (children.value || []).some(function (child) {
        var childValue = getValuePropValue(child);
        return childValue === key && getValueByProp(child, 'disabled');
      });
    };

    var getLabelBySingleValue = function getLabelBySingleValue(value, optionsInfo) {
      var _getOptionInfoBySingl = getOptionInfoBySingleValue(value, optionsInfo),
          label = _getOptionInfoBySingl.label;

      return label;
    };

    var getOptionBySingleValue = function getOptionBySingleValue(value) {
      var _getOptionInfoBySingl2 = getOptionInfoBySingleValue(value),
          option = _getOptionInfoBySingl2.option;

      return option;
    };

    var removeSelected = function removeSelected(selectedKey, e) {
      if ($props.disabled || isChildDisabled(selectedKey)) {
        return;
      } // Do not trigger Trigger popup


      if (e && e.stopPropagation) {
        e.stopPropagation();
      }

      var oldValue = _value.value;
      var value = oldValue.filter(function (singleValue) {
        return singleValue !== selectedKey;
      });
      var canMultiple = isMultipleOrTags($props);

      if (canMultiple) {
        var event = selectedKey;

        if ($props.labelInValue) {
          event = {
            key: selectedKey,
            label: getLabelBySingleValue(selectedKey)
          };
        }

        emit('deselect', event, getOptionBySingleValue(selectedKey));
      }

      fireChange(value);
    };

    var _backfillValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])('');

    var handleBackfill = function handleBackfill(item) {
      if (!$props.backfill || !(isSingleMode($props) || isCombobox($props))) {
        return;
      }

      var key = getValuePropValue(item);

      if (isCombobox($props)) {
        setInputValue(key, false);
      }

      _value.value = [key];
      _backfillValue.value = key;
    };

    var rafInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var cancelRafInstance = function cancelRafInstance() {
      if (rafInstance.value) {
        raf_default.a.cancel(rafInstance.value);
      }
    };

    var dropdownWidth = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);

    var setDropdownWidth = function setDropdownWidth() {
      cancelRafInstance();
      rafInstance.value = raf_default()(function () {
        if (selectionRef.value) {
          var width = selectionRef.value.offsetWidth;

          if (width !== dropdownWidth.value) {
            dropdownWidth.value = width;
          }
        }
      });
    };

    var onPlaceholderClick = function onPlaceholderClick() {
      if (getInputDOMNode()) {
        getInputDOMNode().focus();
        setOpenState(true);
      }
    };

    var getPlaceholderElement = function getPlaceholderElement() {
      var hidden = false;

      if (_mirrorInputValue.value) {
        hidden = true;
      }

      var value = _value.value;

      if (value.length) {
        hidden = true;
      }

      if (!_mirrorInputValue.value && isCombobox($props) && value.length === 1 && _value.value && !_value.value[0]) {
        hidden = false;
      }

      var placeholder = $props.placeholder;

      if (placeholder) {
        var p = {
          onMousedown: preventDefaultEvent,
          onClick: onPlaceholderClick,
          style: {
            display: hidden ? 'none' : 'block'
          },
          "class": "".concat($props.prefixCls, "-selection__placeholder")
        };
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", select_objectSpread({}, p), [placeholder]);
      }

      return null;
    };

    var selectTriggerRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var comboboxTimer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var onInputKeydown = function onInputKeydown(event) {
      var disabled = $props.disabled,
          defaultActiveFirstOption = $props.defaultActiveFirstOption;
      var combobox = isCombobox($props);

      if (disabled) {
        return;
      }

      var isRealOpen = getRealOpenState();
      var keyCode = event.keyCode;

      if (isMultipleOrTags($props) && !event.target.value && keyCode === keycode.BACKSPACE) {
        event.preventDefault();
        var value = _value.value;

        if (value.length) {
          removeSelected(value[value.length - 1]);
        }

        return;
      }

      if (keyCode === keycode.DOWN) {
        if (!_open.value) {
          openIfHasChildren();
          event.preventDefault();
          event.stopPropagation();
          return;
        }
      } else if (keyCode === keycode.ENTER && _open.value) {
        // Aviod trigger form submit when select item
        // https://github.com/ant-design/ant-design/issues/10861
        // https://github.com/ant-design/ant-design/issues/14544
        if (isRealOpen || !combobox) {
          event.preventDefault();
        } // Hard close popup to avoid lock of non option in combobox mode


        if (isRealOpen && combobox && defaultActiveFirstOption === false) {
          comboboxTimer.value = setTimeout(function () {
            setOpenState(false);
          });
        }
      } else if (keyCode === keycode.ESC) {
        if (_open.value) {
          setOpenState(false);
          event.preventDefault();
          event.stopPropagation();
        }

        return;
      }

      if (isRealOpen && selectTriggerRef.value) {
        var menu = menuRef.value;

        if (menu && menu.onKeyDown(event, handleBackfill)) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
    };

    var getVLForOnChange = function getVLForOnChange(vlsS) {
      var vls = vlsS;

      if (vls !== undefined) {
        if (!$props.labelInValue) {
          vls = vls.map(function (v) {
            return v;
          });
        } else {
          vls = vls.map(function (vl) {
            return {
              key: vl,
              label: getLabelBySingleValue(vl)
            };
          });
        }

        return isMultipleOrTags($props) ? vls : vls[0];
      }

      return vls;
    };

    var topCtrlContainerClick = function topCtrlContainerClick(e) {
      if (_open.value && !isSingleMode($props)) {
        e.stopPropagation();
      }
    };

    var renderTopControlNode = function renderTopControlNode() {
      var choiceTransitionName = $props.choiceTransitionName,
          prefixCls = $props.prefixCls,
          maxTagTextLength = $props.maxTagTextLength,
          maxTagCount = $props.maxTagCount,
          maxTagPlaceholder = $props.maxTagPlaceholder,
          showSearch = $props.showSearch;
      var removeIcon = props_util_getComponentFromProp(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])(), 'removeIcon');
      var className = "".concat(prefixCls, "-selection__rendered"); // search input is inside topControlNode in single, multiple & combobox. 2016/04/13

      var innerNode;

      if (isSingleMode($props)) {
        var selectedValue = null;

        if (_value.value.length) {
          var showSelectedValue;
          var opacity = 1;

          if (!showSearch) {
            showSelectedValue = true;
          } else if (_open) {
            showSelectedValue = !_inputValue;

            if (showSelectedValue) {
              opacity = 0.4;
            }
          } else {
            showSelectedValue = true;
          }

          var singleValue = _value.value[0];

          var _getOptionInfoBySingl3 = getOptionInfoBySingleValue(singleValue),
              label = _getOptionInfoBySingl3.label,
              title = _getOptionInfoBySingl3.title;

          selectedValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
            "key": "value",
            "class": "".concat(prefixCls, "-selection-selected-value"),
            "title": toTitle(title || label),
            "style": {
              display: showSelectedValue ? 'block' : 'none',
              opacity: opacity
            }
          }, [label]);
        }

        if (!showSearch) {
          innerNode = [selectedValue];
        } else {
          innerNode = [selectedValue, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
            "class": "".concat(prefixCls, "-search ").concat(prefixCls, "-search--inline"),
            "key": "input",
            "style": {
              display: _open ? 'block' : 'none'
            }
          }, [_getInputElement()])];
        }
      } else {
        var selectedValueNodes = [];
        var limitedCountValue = _value.value;
        var maxTagPlaceholderEl;

        if (maxTagCount !== undefined && _value.value.length > maxTagCount) {
          limitedCountValue = limitedCountValue.slice(0, maxTagCount);
          var omittedValues = getVLForOnChange(_value.value.slice(maxTagCount, _value.value.length));
          var content = "+ ".concat(_value.value.length - maxTagCount, " ...");

          if (maxTagPlaceholder) {
            content = typeof maxTagPlaceholder === 'function' ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
          }

          var _attrs = {
            // ...UNSELECTABLE_ATTRIBUTE,
            role: 'presentation',
            title: toTitle(content)
          };
          maxTagPlaceholderEl = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", select_objectSpread({}, _attrs, {
            "onMousedown": preventDefaultEvent,
            "class": "".concat(prefixCls, "-selection__choice ").concat(prefixCls, "-selection__choice__disabled"),
            "key": "maxTagPlaceholder"
          }), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
            "class": "".concat(prefixCls, "-selection__choice__content")
          }, [content])]);
        }

        if (isMultipleOrTags($props)) {
          selectedValueNodes = limitedCountValue.map(function (singleValue) {
            var info = getOptionInfoBySingleValue(singleValue);
            var content = info.label;
            var title = info.title || content;

            if (maxTagTextLength && typeof content === 'string' && content.length > maxTagTextLength) {
              content = "".concat(content.slice(0, maxTagTextLength), "...");
            }

            var disabled = isChildDisabled(singleValue);
            var choiceClassName = disabled ? "".concat(prefixCls, "-selection__choice ").concat(prefixCls, "-selection__choice__disabled") : "".concat(prefixCls, "-selection__choice"); // attrs 放在一起，避免动态title混乱问题，很奇怪的问题 https://github.com/vueComponent/ant-design-vue/issues/588

            var attrs = {
              // ...UNSELECTABLE_ATTRIBUTE,
              role: 'presentation',
              title: toTitle(title)
            };
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", select_objectSpread({}, attrs, {
              "onMousedown": preventDefaultEvent,
              "class": choiceClassName,
              "key": singleValue || SELECT_EMPTY_VALUE_KEY
            }), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
              "class": "".concat(prefixCls, "-selection__choice__content")
            }, [content]), disabled ? null : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
              "onClick": function onClick(event) {
                removeSelected(singleValue, event);
              },
              "class": "".concat(prefixCls, "-selection__choice__remove")
            }, [removeIcon || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("i", {
              "class": "".concat(prefixCls, "-selection__choice__remove-icon")
            }, ["\xD7"])])]);
          });
        }

        if (maxTagPlaceholderEl) {
          selectedValueNodes.push(maxTagPlaceholderEl);
        }

        selectedValueNodes.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
          "class": "".concat(prefixCls, "-search ").concat(prefixCls, "-search--inline"),
          "key": "__input"
        }, [_getInputElement()]));

        if (isMultipleOrTags($props) && choiceTransitionName) {
          var transitionProps = get_transition_props(choiceTransitionName, {
            tag: 'ul'
          });
          innerNode = // @ts-ignore
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["TransitionGroup"], select_objectSpread({}, transitionProps), [selectedValueNodes]);
        } else {
          innerNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("ul", {}, [selectedValueNodes]);
        }
      }

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": className,
        "ref": function ref(el) {
          return topCtrlRef.value = el;
        },
        "onClick": topCtrlContainerClick
      }, [getPlaceholderElement(), innerNode]);
    };

    var getRealOpenState = function getRealOpenState() {
      if (typeof $props.open === 'boolean') {
        return $props.open;
      }

      var open = _open.value;
      var options = _options.value || [];

      if (isMultipleOrTagsOrCombobox($props) || !$props.showSearch) {
        if (open && !options.length) {
          open = false;
        }
      }

      return open;
    };

    var getOptionsBySingleValue = function getOptionsBySingleValue(values) {
      return values.map(function (value) {
        return getOptionBySingleValue(value);
      });
    };

    var fireChange = function fireChange(value) {
      if ($props.value === undefined) {
        _value.value = value;
      }

      var vls = getVLForOnChange(value);
      var options = getOptionsBySingleValue(value);

      _emit('change', vls, isMultipleOrTags($props) ? options : options[0]);

      _emit('update:value', vls);
    };

    var onClearSelection = function onClearSelection(event) {
      if ($props.disabled) {
        return;
      }

      event.stopPropagation();

      if (_inputValue.value || _value.value.length) {
        if (_value.value.length) {
          fireChange([]);
        }

        setOpenState(false, {
          needFocus: true
        });

        if (_inputValue.value) {
          setInputValue('');
        }
      }
    };

    var setInputValue = function setInputValue(inputValue) {
      var fireSearch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (inputValue !== _inputValue.value) {
        _inputValue.value = inputValue;

        if (fireSearch) {
          emit('search', inputValue);
        }
      }
    };

    var selectionRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var maybeFocus = function maybeFocus(open, needFocus) {
      if (needFocus || open) {
        var input = getInputDOMNode();
        var _document = document,
            activeElement = _document.activeElement;

        if (input && (open || isMultipleOrTagsOrCombobox($props))) {
          if (activeElement !== input) {
            input.focus();
            _focused.value = true;
          }
        } else if (activeElement !== selectionRef.value && selectionRef.value) {
          selectionRef.value.focus();
          _focused.value = true;
        }
      }
    };

    var setOpenState = function setOpenState(open) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var needFocus = config.needFocus,
          fireSearch = config.fireSearch;

      if (_open.value === open) {
        maybeFocus(open, !!needFocus);
        return;
      }

      emit('dropdownVisibleChange', open); // clear search input value when open is false in singleMode.

      if (!open && isSingleMode($props) && $props.showSearch) {
        setInputValue('', fireSearch);
      }

      if (!open) {
        maybeFocus(open, !!needFocus);
      }

      _open.value = open;
      _backfillValue.value = '';

      if (open) {
        maybeFocus(open, !!needFocus);
      }
    };

    var renderClear = function renderClear() {
      var prefixCls = $props.prefixCls,
          allowClear = $props.allowClear;
      var clearIcon = props_util_getComponentFromProp(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])(), 'clearIcon');
      var clear = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", select_objectSpread({
        "key": "clear",
        "class": "".concat(prefixCls, "-selection__clear"),
        "onMousedown": preventDefaultEvent
      }, {
        attrs: UNSELECTABLE_ATTRIBUTE
      }, {
        "onClick": onClearSelection
      }), [clearIcon || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("i", {
        "class": "".concat(prefixCls, "-selection__clear-icon")
      }, ["\xD7"])]);

      if (!allowClear) {
        return null;
      }

      if (isCombobox($props)) {
        if (_inputValue.value) {
          return clear;
        }

        return null;
      }

      if (_inputValue.value || _value.value.length) {
        return clear;
      }

      return null;
    };

    var defaultFilterFn = function defaultFilterFn(input, child) {
      var props = getPropsData(child);

      if (props.disabled) {
        return false;
      }

      var value = getPropValue(child, props.optionFilterProp);

      if (value.length && value[0].text) {
        value = value[0].text;
      } else {
        value = String(value);
      }

      return value.toLowerCase().indexOf(input.toLowerCase()) > -1;
    };

    var _filterOption = function _filterOption(input, child) {
      var defaultFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultFilterFn;
      var lastValue = _value.value[_value.value.length - 1];

      if (!input || lastValue && lastValue === _backfillValue.value) {
        return true;
      }

      var filterFn = $props.filterOption;

      if (filterFn !== undefined) {
        if (filterFn === true) {
          filterFn = defaultFilter.bind(currentInstance);
        }
      } else {
        filterFn = defaultFilter.bind(currentInstance);
      }

      if (!filterFn) {
        return true;
      } else if (typeof filterFn === 'function') {
        return filterFn.call(currentInstance, input, child);
      } else if (getValueByProp(child, 'disabled')) {
        return false;
      }

      return true;
    };

    var renderFilterOptionsFromChildren = function renderFilterOptionsFromChildren() {
      var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var childrenKeys = arguments.length > 1 ? arguments[1] : undefined;
      var menuItems = arguments.length > 2 ? arguments[2] : undefined;
      var sel = [];
      var tags = $props.mode === 'tags';
      children.forEach(function (child) {
        if (!Array.isArray(child.children) && !child.children["default"]) {
          return;
        }

        if (getSlotOptions(child).isSelectOptGroup) {
          var label = props_util_getComponentFromProp(child, 'label');
          var key = child.key;

          if (!key && typeof label === 'string') {
            key = label;
          } else if (!label && key) {
            label = key;
          }

          var childChildren = getSlots(child)["default"]();
          childChildren = typeof childChildren === 'function' ? childChildren() : childChildren; // Match option group label

          if (_inputValue.value && _filterOption(_inputValue, child)) {
            var innerItems = childChildren.map(function (subChild) {
              var childValueSub = getValuePropValue(subChild) || subChild.key;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(menu_item, select_objectSpread({
                "key": childValueSub,
                "value": childValueSub
              }, subChild.props), [subChild.children]);
            });
            sel.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(menu_item_group, {
              "key": key,
              "title": label,
              "class": getClassFromVNode(child)
            }, [innerItems])); // Not match
          } else {
            var _innerItems = renderFilterOptionsFromChildren(childChildren, childrenKeys, menuItems);

            if (_innerItems.length) {
              sel.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(menu_item_group, select_objectSpread({
                "key": key,
                "title": label
              }, child.data), [_innerItems]));
            }
          }

          return;
        }

        var childValue = getValuePropValue(child);
        validateOptionValue(childValue, $props);

        if (_filterOption(_inputValue.value, child)) {
          var p = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, UNSELECTABLE_ATTRIBUTE), getAttrs(child)), {
            key: childValue,
            value: childValue
          }), getPropsData(child)), {
            role: 'option',
            style: UNSELECTABLE_STYLE
          }), getListenersFromVNode(child)), {
            rootPrefixCls: dropdownClassPrefix.value + '-menu',
            "class": getClassFromVNode(child)
          });
          var menuItem = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(menu_item, select_objectSpread({}, p), [Array.isArray(child.children) ? child.children : child.children["default"] && child.children["default"]()]);
          sel.push(menuItem);
          menuItems.push(menuItem);
        }

        if (tags) {
          childrenKeys.push(childValue);
        }
      });
      return sel;
    };

    var tags = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function () {
      return $props.mode === 'tags';
    });

    var renderFilterOptions = function renderFilterOptions() {
      var notFoundContent = $props.notFoundContent;
      var menuItems = [];
      var childrenKeys = [];
      var empty = false;
      var options = renderFilterOptionsFromChildren(children.value, childrenKeys, menuItems);

      if (tags.value) {
        // tags value must be string
        var value = _value.value;
        value = value.filter(function (singleValue) {
          return childrenKeys.indexOf(singleValue) === -1 && (!_inputValue.value || String(singleValue).indexOf(String(_inputValue)) > -1);
        }); // sort by length

        value.sort(function (val1, val2) {
          return val1.length - val2.length;
        });
        value.forEach(function (singleValue) {
          var key = singleValue;
          var attrs = Object.assign(Object.assign({}, UNSELECTABLE_ATTRIBUTE), {
            role: 'option'
          });
          var menuItem = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(menu_item, select_objectSpread({
            "style": UNSELECTABLE_STYLE
          }, attrs, {
            "value": key,
            "key": key
          }), [key]);
          options.push(menuItem);
          menuItems.push(menuItem);
        }); // ref: https://github.com/ant-design/ant-design/issues/14090

        if (_inputValue.value && menuItems.every(function (option) {
          return getValuePropValue(option) !== _inputValue;
        })) {
          var p = Object.assign(Object.assign({}, UNSELECTABLE_ATTRIBUTE), {
            key: _inputValue.value,
            value: _inputValue.value,
            role: 'option',
            style: UNSELECTABLE_STYLE
          });
          options.unshift(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(menu_item, select_objectSpread({}, p), [_inputValue.value]));
        }
      }

      if (!options.length && notFoundContent) {
        empty = true;
        var _p = {
          attrs: UNSELECTABLE_ATTRIBUTE,
          key: 'NOT_FOUND',
          value: 'NOT_FOUND',
          disabled: true,
          role: 'option',
          style: UNSELECTABLE_STYLE
        };
        options = [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(menu_item, select_objectSpread({}, _p), [notFoundContent])];
      }

      return {
        empty: empty,
        options: options
      };
    };

    var getMenuItemSelectedIcon = function getMenuItemSelectedIcon() {
      var menuItemSelectedIcon = props_util_getComponentFromProp(currentInstance, 'menuItemSelectedIcon');
      return menuItemSelectedIcon && (isValidElement(menuItemSelectedIcon) ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(menuItemSelectedIcon, {
        "class": "".concat($props.prefixCls, "-selected-icon")
      }) : menuItemSelectedIcon) || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "check",
        "class": "".concat($props.prefixCls, "-selected-icon")
      }, []);
    };

    var menuRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var onMenuDeselect = function onMenuDeselect(_ref2) {
      var item = _ref2.item,
          domEvent = _ref2.domEvent;

      if (domEvent.type === 'keydown' && domEvent.keyCode === keycode.ENTER) {
        var menuItemDomNode = item.$el; // https://github.com/ant-design/ant-design/issues/20465#issuecomment-569033796

        if (!utils_isHidden(menuItemDomNode)) {
          removeSelected(getValuePropValue(item));
        }

        return;
      }

      if (domEvent.type === 'click') {
        removeSelected(getValuePropValue(item));
      }

      if ($props.autoClearSearchValue) {
        setInputValue('');
      }
    };

    var renderMenu = function renderMenu() {
      var menuItems = _options.value;
      var defaultActiveFirstOption = $props.defaultActiveFirstOption,
          value = $props.value,
          firstActiveValue = $props.firstActiveValue,
          dropdownMenuStyle = $props.dropdownMenuStyle;

      var _getListenersFromInst = getListenersFromInstance(currentInstance),
          popupScroll = _getListenersFromInst.popupScroll;

      if (menuItems && menuItems.length) {
        var selectedKeys = getSelectKeys(menuItems, _value.value);
        var menuItemSelectedIcon = getMenuItemSelectedIcon();
        var menuProps = {
          multiple: !isSingleMode($props),
          itemIcon: !isSingleMode($props) ? menuItemSelectedIcon : null,
          selectedKeys: selectedKeys,
          prefixCls: "".concat(dropdownClassPrefix.value, "-menu"),
          style: dropdownMenuStyle,
          ref: function ref(el) {
            return menuRef.value = el;
          },
          role: 'listbox'
        };

        if (popupScroll) {
          menuProps.onScroll = popupScroll;
        }

        if (!isSingleMode($props)) {
          menuProps.onDeselect = onMenuDeselect;
          menuProps.onSelect = onMenuSelect;
        } else {
          menuProps.onClick = onMenuSelect;
        }

        var activeKeyProps = {};
        var defaultActiveFirst = defaultActiveFirstOption;
        var clonedMenuItems = menuItems;

        if (selectedKeys.length || firstActiveValue) {
          if (_open.value) {
            activeKeyProps.activeKey = selectedKeys[0] || firstActiveValue;
          } else if (!_open.value) {
            // Do not trigger auto active since we already have selectedKeys
            if (selectedKeys[0]) {
              defaultActiveFirst = false;
            }

            activeKeyProps.activeKey = undefined;
          }

          var foundFirst = false; // set firstActiveItem via cloning menus
          // for scroll into view

          var clone = function clone(item) {
            if (!foundFirst && selectedKeys.indexOf(item.key) !== -1 || !foundFirst && !selectedKeys.length && firstActiveValue.indexOf(item.key) !== -1) {
              foundFirst = true;
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(item, {
                ref: function ref(_ref3) {
                  firstActiveItem.value = _ref3;
                }
              });
            }

            return item;
          };

          clonedMenuItems = menuItems.map(function (item) {
            if (getSlotOptions(item).isMenuItemGroup) {
              return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(item, {
                children: item.componentOptions.children.map(clone)
              });
            }

            return clone(item);
          });
        } else {
          // Clear firstActiveItem when dropdown menu items was empty
          // Avoid `Unable to find node on an unmounted component`
          // https://github.com/ant-design/ant-design/issues/10774
          firstActiveItem.value = null;
        } // clear activeKey when inputValue change


        var lastValue = value && value[value.length - 1];

        if (!lastValue || lastValue !== _backfillValue.value) {
          activeKeyProps.activeKey = '';
        }

        Object.assign(menuProps, activeKeyProps, {
          defaultActiveFirst: defaultActiveFirst
        });
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_menu, select_objectSpread({}, menuProps), [clonedMenuItems]);
      }

      return null;
    };

    var arrowRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var blurTimer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var onArrowClick = function onArrowClick(e) {
      e.stopPropagation();
      e.preventDefault();
      clearBlurTime();

      if (!$props.disabled) {
        setOpenState(!_open.value, {
          needFocus: !_open.value
        });
      }
    };

    var clearBlurTime = function clearBlurTime() {
      if (blurTimer.value) {
        clearTimeout(blurTimer.value);
        blurTimer.value = null;
      }
    };

    var renderArrow = function renderArrow(multiple) {
      // showArrow : Set to true if not multiple by default but keep set value.
      var _$props$showArrow = $props.showArrow,
          showArrow = _$props$showArrow === void 0 ? !multiple : _$props$showArrow,
          loading = $props.loading,
          prefixCls = $props.prefixCls;
      var inputIcon = props_util_getComponentFromProp(currentInstance, 'inputIcon');

      if (!showArrow && !loading) {
        return null;
      } // if loading  have loading icon


      var defaultIcon = loading ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "loading",
        "class": "".concat(prefixCls, "-arrow-loading")
      }, []) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "down",
        "class": "".concat(prefixCls, "-arrow-icon")
      }, []);
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "key": "arrow",
        "class": "".concat(prefixCls, "-arrow"),
        "onClick": onArrowClick,
        "ref": function ref(el) {
          return arrowRef.value = el;
        }
      }, [inputIcon || defaultIcon]);
    };

    var onMenuSelect = function onMenuSelect(_ref4) {
      var item = _ref4.item;

      if (!item) {
        return;
      }

      var selectedValue = getValuePropValue(item);
      var lastValue = _value[_value.value.length - 1];
      var skipTrigger = false;

      if (isMultipleOrTags($props)) {
        if (findIndexInValueBySingleValue(_value, selectedValue) !== -1) {
          skipTrigger = true;
        } else {
          _value.value = _value.value.concat([selectedValue]);
        }
      } else {
        if (!isCombobox($props) && lastValue !== undefined && lastValue === selectedValue && selectedValue !== _backfillValue.value) {
          setOpenState(false, {
            needFocus: true,
            fireSearch: false
          });
          skipTrigger = true;
        } else {
          _value.value = [selectedValue];
          setOpenState(false, {
            needFocus: true,
            fireSearch: false
          });
        }
      }

      if (!skipTrigger) {
        fireChange(_value.value);
      }

      if (!skipTrigger) {
        fireSelect(selectedValue);
        var inputValue = isCombobox($props) ? getPropValue(item, getOptionLabelProp()) : '';

        if ($props.autoClearSearchValue) {
          setInputValue(inputValue, false);
        }
      }
    };

    var dropdownClassPrefix = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function () {
      return $props.prefixCls + '-dropdown';
    });

    var onPopupFocus = function onPopupFocus() {
      // fix ie scrollbar, focus element again
      maybeFocus(true, true);
    };

    var getPopupAlign = function getPopupAlign() {
      return getAlignFromPlacement(select_BUILT_IN_PLACEMENTS, 'bottomLeft');
    };

    var getDropdownClass = function getDropdownClass() {
      var _ref5;

      return _ref5 = {}, defineProperty_default()(_ref5, dropdownClassPrefix.value, true), defineProperty_default()(_ref5, dropdownClassPrefix.value + '--single', isSingleMode($props)), defineProperty_default()(_ref5, dropdownClassPrefix.value + '--multiple', !isSingleMode($props)), defineProperty_default()(_ref5, dropdownClassPrefix.value + '--placement-' + 'bottomLeft', true), _ref5;
    };

    var selectionRefClick = function selectionRefClick() {
      if (!$props.disabled) {
        var input = getInputDOMNode();

        if (_focused.value && _open.value) {
          setOpenState(false, false);
          input && input.blur();
        } else {
          clearBlurTime();
          setOpenState(true, true);
          input && input.focus();
        }
      }
    };

    var onDropdownVisibleChange = function onDropdownVisibleChange(open, e) {
      if (contains(rootRef.value, e.target)) {
        return;
      }

      if (open && !_focused.value) {
        clearBlurTime();
        timeoutFocus();
        _focused.value = true;
        updateFocusClassName();
      }

      setOpenState(open);
    };

    var hideAction = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function () {
      var hide;

      if ($props.disabled) {
        hide = [];
      } else if (isSingleMode($props) && !$props.showSearch) {
        hide = ['click'];
      } else {
        hide = ['blur'];
      }

      return hide;
    });
    var menuContainerRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var getInputMirrorDOMNode = function getInputMirrorDOMNode() {
      return inputMirrorRef.value;
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      setDropdownWidth();
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        if (isMultipleOrTags($props)) {
          var inputNode = getInputDOMNode();
          var mirrorNode = getInputMirrorDOMNode();

          if (inputNode && inputNode.value && mirrorNode) {
            inputNode.style.width = '';
            inputNode.style.width = "".concat(mirrorNode.clientWidth + 10, "px");
          } else if (inputNode) {
            inputNode.style.width = '';
          }
        }

        if (selectTriggerRef.value) {
          selectTriggerRef.value.forcePopupAlign();
        }
      });
      setDropdownWidth();
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return _inputValue.value;
    }, function (val) {
      _mirrorInputValue.value = val;
    });
    return {
      _open: _open,
      _focused: _focused,
      dropdownWidth: dropdownWidth,
      getRealOpenState: getRealOpenState,
      onDropdownVisibleChange: onDropdownVisibleChange,
      renderClear: renderClear,
      renderArrow: renderArrow,
      renderTopControlNode: renderTopControlNode,
      selectionRefClick: selectionRefClick,
      getPopupAlign: getPopupAlign,
      rootRef: rootRef,
      renderMenu: renderMenu,
      onPopupFocus: onPopupFocus,
      renderFilterOptions: renderFilterOptions,
      getDropdownClass: getDropdownClass,
      dropdownClassPrefix: dropdownClassPrefix,
      hideAction: hideAction,
      saveRootRef: function saveRootRef(el) {
        rootRef.value = el;
      },
      saveSelectionRef: function saveSelectionRef(el) {
        selectionRef.value = el;
      },
      onPopupScroll: function onPopupScroll() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        emit.apply(void 0, ['popupScroll'].concat(args));
      },
      setOptions: function setOptions(options) {
        _options.value = options;
      },
      saveMenuContainer: function saveMenuContainer(el) {
        menuContainerRef.value = el;
      },
      setTriggerRef: function setTriggerRef(el) {
        selectTriggerRef.value = el;
      }
    };
  },
  render: function render(ctx) {
    var _rootCls;

    var prefixCls = ctx.prefixCls,
        _ctx$showArrow = ctx.showArrow,
        showArrow = _ctx$showArrow === void 0 ? true : _ctx$showArrow,
        tabIndex = ctx.tabIndex,
        getRealOpenState = ctx.getRealOpenState,
        combobox = ctx.combobox,
        _ctx$loading = ctx.loading,
        loading = _ctx$loading === void 0 ? false : _ctx$loading,
        disabled = ctx.disabled,
        allowClear = ctx.allowClear,
        _focused = ctx._focused;
    var filterOptions = ctx.renderFilterOptions();
    ctx.setOptions(filterOptions.options);
    var ctrlNode = ctx.renderTopControlNode();
    var props = ctx.$props;
    var realOpen = getRealOpenState();
    var selectionProps = {
      role: 'combobox',
      key: 'selection',
      "class": "".concat(prefixCls, "-selection ").concat(prefixCls, "-selection--").concat(isSingleMode(props) ? 'single' : 'multiple')
    };

    if (realOpen) {
      ctx._empty = filterOptions.empty;
    }

    var rootCls = (_rootCls = {}, defineProperty_default()(_rootCls, prefixCls, true), defineProperty_default()(_rootCls, "".concat(prefixCls, "-open"), realOpen), defineProperty_default()(_rootCls, "".concat(prefixCls, "-focused"), realOpen || _focused.value), defineProperty_default()(_rootCls, "".concat(prefixCls, "-combobox"), combobox), defineProperty_default()(_rootCls, "".concat(prefixCls, "-disabled"), disabled), defineProperty_default()(_rootCls, "".concat(prefixCls, "-enabled"), !disabled), defineProperty_default()(_rootCls, "".concat(prefixCls, "-allow-clear"), !!allowClear), defineProperty_default()(_rootCls, "".concat(prefixCls, "-no-arrow"), !showArrow), defineProperty_default()(_rootCls, "".concat(prefixCls, "-loading"), !!loading), _rootCls);
    var transitionProps = {
      props: {
        appear: true,
        css: false
      }
    };
    var transitionName = 'slide-up';
    var transitionEvent = {
      onBeforeEnter: function onBeforeEnter() {// el.style.display = el.__vOriginalDisplay
        // this.$refs.alignInstance.forceAlign();
      },
      onEnter: function onEnter(el, done) {
        // render 后 vue 会移除通过animate动态添加的 class导致动画闪动，延迟两帧添加动画class，可以进一步定位或者重写 transition 组件
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
          if (ctx.$refs.alignInstance) {
            Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
              css_animation(el, "".concat(transitionName, "-enter"), done);
            });
          } else {
            done();
          }
        });
      },
      onLeave: function onLeave(el, done) {
        css_animation(el, "".concat(transitionName, "-leave"), done);
      }
    };
    Object.assign(transitionProps, transitionEvent);
    var dropdown = ctx.renderMenu();
    var popupStyle = Object.assign({}, props.dropdownStyle);
    var widthProp = props.dropdownMatchSelectWidth ? 'width' : 'minWidth';

    if (ctx.dropdownWidth) {
      popupStyle[widthProp] = "".concat(ctx.dropdownWidth, "px");
    }

    var triggerProps = {
      showAction: disabled ? [] : props.showAction,
      hideAction: ctx.hideAction,
      ref: ctx.setTriggerRef,
      popupPlacement: 'bottomLeft',
      builtinPlacements: select_BUILT_IN_PLACEMENTS,
      prefixCls: ctx.dropdownClassPrefix,
      popupClassName: ctx.getDropdownClass(),
      popupTransitionName: 'slide-up',
      popupAlign: ctx.getPopupAlign(),
      popupVisible: realOpen,
      popupStyle: popupStyle,
      onPopupVisibleChange: ctx.onDropdownVisibleChange
    };
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_trigger, select_objectSpread({}, triggerProps), {
      "popup": [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], select_objectSpread({}, transitionProps), [dropdown])],
      "default": [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "ref": function ref(el) {
          ctx.saveRootRef(el);
          ctx.saveSelectionRef(el);
        },
        "style": getStyleFromInstance(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])()),
        "class": classnames_default()(rootCls),
        "onMousedown": ctx.markMouseDown,
        "onMouseup": ctx.markMouseLeave,
        "onMouseout": ctx.markMouseLeave,
        "tabindex": disabled ? -1 : tabIndex,
        "onBlur": ctx.selectionRefBlur,
        "onFocus": ctx.selectionRefFocus,
        "onClick": ctx.selectionRefClick,
        "onKeydown": isMultipleOrTagsOrCombobox(ctx) ? function () {} : ctx.onKeyDown
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", select_objectSpread({}, selectionProps), [ctrlNode, ctx.renderClear(), ctx.renderArrow(!isSingleMode(props))])])]
    });
  }
});
/* istanbul ignore next */

select_Select.install = function (app) {
  app.use(base);
  app.component(select_Select.name, select_Select);
  app.component(select_Select.Option.name, select_Select.Option);
  app.component(select_Select.OptGroup.name, select_Select.OptGroup);
};

/* harmony default export */ var components_select = (select_Select);
// CONCATENATED MODULE: ./src/components/calendar/header.tsx









var Option = components_select.Option;

function getMonthsLocale(value) {
  var current = value.clone();
  var localeData = value.localeData();
  var months = [];

  for (var i = 0; i < 12; i++) {
    current.month(i);
    months.push(localeData.monthsShort(current));
  }

  return months;
}

var HeaderProps = {
  prefixCls: vue_types.string,
  locale: vue_types.any,
  fullscreen: vue_types.bool,
  yearSelectOffset: vue_types.number,
  yearSelectTotal: vue_types.number,
  type: vue_types.string,
  // onValueChange: PropTypes.(value: moment.Moment) => void,
  // onTypeChange: PropTypes.(type: string) => void,
  value: vue_types.any,
  validRange: vue_types.array,
  headerRender: vue_types.func
};
/* harmony default export */ var components_calendar_header = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: initDefaultProps(HeaderProps, {
    yearSelectOffset: 10,
    yearSelectTotal: 20
  }),
  setup: function setup($props, _ref) {
    var _arguments = arguments;
    var emit = _ref.emit;

    var getYearSelectElement = function getYearSelectElement(prefixCls, year) {
      var yearSelectOffset = $props.yearSelectOffset,
          yearSelectTotal = $props.yearSelectTotal,
          _$props$locale = $props.locale,
          locale = _$props$locale === void 0 ? {} : _$props$locale,
          fullscreen = $props.fullscreen,
          validRange = $props.validRange;
      var start = year - yearSelectOffset;
      var end = start + yearSelectTotal;

      if (validRange) {
        start = validRange[0].get('year');
        end = validRange[1].get('year') + 1;
      }

      var suffix = locale.year === '年' ? '年' : '';
      var options = [];

      for (var index = start; index < end; index++) {
        options.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Option, {
          "key": "".concat(index)
        }, [index + suffix]));
      }

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_select, {
        "size": fullscreen ? 'default' : 'small',
        "dropdownMatchSelectWidth": false,
        "class": "".concat(prefixCls, "-year-select"),
        "onChange": onYearChange,
        "value": String(year),
        "getPopupContainer": function getPopupContainer() {
          return getCalenderHeaderNode();
        }
      }, [options]);
    };

    var getMonthSelectElement = function getMonthSelectElement(prefixCls, month, months) {
      var fullscreen = $props.fullscreen,
          validRange = $props.validRange,
          value = $props.value;
      var options = [];
      var start = 0;
      var end = 12;

      if (validRange) {
        var _validRange = slicedToArray_default()(validRange, 2),
            rangeStart = _validRange[0],
            rangeEnd = _validRange[1];

        var currentYear = value.get('year');

        if (rangeEnd.get('year') === currentYear) {
          end = rangeEnd.get('month') + 1;
        }

        if (rangeStart.get('year') === currentYear) {
          start = rangeStart.get('month');
        }
      }

      for (var index = start; index < end; index++) {
        options.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Option, {
          "key": "".concat(index)
        }, [months[index]]));
      }

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_select, {
        "size": fullscreen ? 'default' : 'small',
        "dropdownMatchSelectWidth": false,
        "class": "".concat(prefixCls, "-month-select"),
        "value": String(month),
        "onChange": onMonthChange,
        "getPopupContainer": function getPopupContainer() {
          return getCalenderHeaderNode();
        }
      }, [options]);
    };

    var onYearChange = function onYearChange(year) {
      var value = $props.value,
          validRange = $props.validRange;
      var newValue = value.clone();
      newValue.year(parseInt(year, 10)); // switch the month so that it remains within range when year changes

      if (validRange) {
        var _validRange2 = slicedToArray_default()(validRange, 2),
            start = _validRange2[0],
            end = _validRange2[1];

        var newYear = newValue.get('year');
        var newMonth = newValue.get('month');

        if (newYear === end.get('year') && newMonth > end.get('month')) {
          newValue.month(end.get('month'));
        }

        if (newYear === start.get('year') && newMonth < start.get('month')) {
          newValue.month(start.get('month'));
        }
      }

      emit('valueChange', newValue);
    };

    var onMonthChange = function onMonthChange(month) {
      var newValue = $props.value.clone();
      newValue.month(parseInt(month, 10));
      emit('valueChange', newValue);
    };

    var onInternalTypeChange = function onInternalTypeChange(e) {
      onTypeChange(e.target.value);
    };

    var onTypeChange = function onTypeChange(val) {
      emit('typeChange', val);
    };

    var _useRefs = save_ref_useRefs(),
        saveRef = _useRefs.saveRef,
        getRef = _useRefs.getRef;

    var getCalenderHeaderNode = function getCalenderHeaderNode() {
      return getRef('calenderHeaderNode');
    };

    var getMonthYearSelections = function getMonthYearSelections(getPrefixCls) {
      var customizePrefixCls = $props.prefixCls,
          type = $props.type,
          value = $props.value;
      var prefixCls = getPrefixCls('fullcalendar', customizePrefixCls);
      var yearReactNode = getYearSelectElement(prefixCls, value.year());
      var monthReactNode = type === 'month' ? getMonthSelectElement(prefixCls, value.month(), getMonthsLocale(value)) : null;
      return {
        yearReactNode: yearReactNode,
        monthReactNode: monthReactNode
      };
    };

    var getTypeSwitch = function getTypeSwitch() {
      var _$props$locale2 = $props.locale,
          locale = _$props$locale2 === void 0 ? {} : _$props$locale2,
          type = $props.type,
          fullscreen = $props.fullscreen;
      var size = fullscreen ? 'default' : 'small';
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(radio_group, {
        "onChange": onInternalTypeChange,
        "value": type,
        "size": size
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(radio_button, {
        "value": "month"
      }, [locale.month]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(radio_button, {
        "value": "year"
      }, [locale.year])]);
    };

    var onValueChange = function onValueChange() {
      emit.apply(void 0, ['valueChange'].concat(toConsumableArray_default()(_arguments)));
    };

    var headerRenderCustom = function headerRenderCustom(headerRender) {
      var type = $props.type,
          value = $props.value;
      return headerRender({
        value: value,
        type: type || 'month',
        onChange: onValueChange,
        onTypeChange: onTypeChange
      });
    };

    return {
      configProvider: config_provider_useConfigProvider(),
      getYearSelectElement: getYearSelectElement,
      getMonthSelectElement: getMonthSelectElement,
      onYearChange: onYearChange,
      onMonthChange: onMonthChange,
      onInternalTypeChange: onInternalTypeChange,
      onTypeChange: onTypeChange,
      getCalenderHeaderNode: getCalenderHeaderNode,
      getMonthYearSelections: getMonthYearSelections,
      getTypeSwitch: getTypeSwitch,
      onValueChange: onValueChange,
      headerRenderCustom: headerRenderCustom,
      saveRef: saveRef
    };
  },
  render: function render(ctx) {
    var customizePrefixCls = this.prefixCls,
        headerRender = this.headerRender;
    var getPrefixCls = ctx.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('fullcalendar', customizePrefixCls);
    var typeSwitch = this.getTypeSwitch();

    var _this$getMonthYearSel = this.getMonthYearSelections(getPrefixCls),
        yearReactNode = _this$getMonthYearSel.yearReactNode,
        monthReactNode = _this$getMonthYearSel.monthReactNode;

    return headerRender ? this.headerRenderCustom(headerRender) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-header"),
      "ref": this.saveRef('calenderHeaderNode')
    }, [yearReactNode, monthReactNode, typeSwitch]);
  }
}));
// CONCATENATED MODULE: ./src/components/calendar/index.tsx



function calendar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function calendar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { calendar_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { calendar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }













function zerofixed(v) {
  if (v < 10) {
    return "0".concat(v);
  }

  return "".concat(v);
}

var calendar_MomentType = {
  type: Object,
  validator: function validator(value) {
    return moment["isMoment"](value);
  }
};

function isMomentArray(value) {
  return Array.isArray(value) && !!value.find(function (val) {
    return moment["isMoment"](val);
  });
}

var CalendarMode = vue_types.oneOf(['month', 'year']);
var calendar_CalendarProps = function CalendarProps() {
  return {
    prefixCls: vue_types.string,
    value: calendar_MomentType,
    defaultValue: calendar_MomentType,
    mode: CalendarMode,
    fullscreen: vue_types.bool,
    // dateCellRender: PropTypes.func,
    // monthCellRender: PropTypes.func,
    // dateFullCellRender: PropTypes.func,
    // monthFullCellRender: PropTypes.func,
    locale: vue_types.object,
    // onPanelChange?: (date?: moment.Moment, mode?: CalendarMode) => void;
    // onSelect?: (date?: moment.Moment) => void;
    disabledDate: vue_types.func,
    validRange: vue_types.custom(isMomentArray),
    headerRender: vue_types.func
  };
};
var Calendar = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ACalendar',
  props: initDefaultProps(calendar_CalendarProps(), {
    locale: {},
    fullscreen: true
  }),
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;
    var configProvider = config_provider_useConfigProvider();
    var sMode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.mode || 'month');

    var _useLocalValue = value_useLocalValue(props.defaultValue || interopDefault(moment)()),
        updateValue = _useLocalValue.setValue,
        getValue = _useLocalValue.getValue;

    var onPanelChange = function onPanelChange(value, mode) {
      emit('panelChange', value, mode);

      if (value !== getValue()) {
        emit('change', value);
      }
    };

    var setValue = function setValue(value, way) {
      var prevValue = getValue();
      var mode = sMode.value;

      if (way === 'select') {
        if (prevValue && prevValue.month() !== value.month()) {
          onPanelChange(value, mode);
        }

        updateValue(value, way);
      } else if (way === 'changePanel') {
        onPanelChange(value, mode);
      }
    };

    var onHeaderTypeChange = function onHeaderTypeChange(mode) {
      sMode.value = mode;
      onPanelChange(getValue(), mode);
    };

    var onHeaderValueChange = function onHeaderValueChange(value) {
      setValue(value, 'changePanel');
    };

    var onSelect = function onSelect(value) {
      setValue(value, 'select');
    };

    var getDateRange = function getDateRange(validRange, disabledDate) {
      return function (current) {
        if (!current) {
          return false;
        }

        var _validRange = slicedToArray_default()(validRange, 2),
            startDate = _validRange[0],
            endDate = _validRange[1];

        var inRange = !current.isBetween(startDate, endDate, 'days', '[]');

        if (disabledDate) {
          return disabledDate(current) || inRange;
        }

        return inRange;
      };
    };

    var getDefaultLocale = function getDefaultLocale() {
      var result = Object.assign(Object.assign({}, calendar_locale_zh_CN), props.locale);
      result.lang = Object.assign(Object.assign({}, result.lang), (props.locale || {}).lang);
      return result;
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.mode;
    }, function (val) {
      sMode.value = val;
    });
    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var renderCalendar = function renderCalendar(locale, localeCode) {
      var props = getOptionProps(currentInstance);

      if (getValue() && localeCode) {
        getValue().locale(localeCode);
      }

      var customizePrefixCls = props.prefixCls,
          fullscreen = props.fullscreen,
          dateFullCellRender = props.dateFullCellRender,
          monthFullCellRender = props.monthFullCellRender;
      var headerRender = props.headerRender || slots.headerRender && slots.headerRender();
      var getPrefixCls = configProvider.getPrefixCls;
      var prefixCls = getPrefixCls('fullcalendar', customizePrefixCls); // To support old version react.
      // Have to add prefixCls on the instance.
      // https://github.com/facebook/react/issues/12397

      var cls = '';

      if (fullscreen) {
        cls += " ".concat(prefixCls, "-fullscreen");
      }

      var monthCellRender = monthFullCellRender || slots.monthFullCellRender && slots.monthFullCellRender() || props.monthCellRender2;
      var dateCellRender = dateFullCellRender || slots.dateFullCellRender && slots.dateFullCellRender() || props.dateCellRender2;
      var disabledDate = props.disabledDate;

      if (props.validRange) {
        disabledDate = getDateRange(props.validRange, disabledDate);
      }

      var fullCalendarProps = Object.assign(Object.assign(Object.assign(Object.assign({}, props), {
        Select: {},
        locale: locale.lang,
        type: props.mode === 'year' ? 'month' : 'date',
        prefixCls: prefixCls,
        showHeader: false,
        value: getValue(),
        monthCellRender: monthCellRender,
        dateCellRender: dateCellRender,
        disabledDate: disabledDate
      }), getListenersFromInstance(currentInstance)), {
        select: onSelect
      });
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": cls
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_calendar_header, {
        "fullscreen": fullscreen,
        "type": props.mode,
        "headerRender": headerRender,
        "value": getValue(),
        "locale": locale.lang,
        "prefixCls": prefixCls,
        "onTypeChange": onHeaderTypeChange,
        "onValueChange": onHeaderValueChange,
        "validRange": props.validRange
      }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(full_calendar, calendar_objectSpread({}, fullCalendarProps), [])]);
    };

    return {
      renderCalendar: renderCalendar,
      getDefaultLocale: getDefaultLocale
    };
  },
  render: function render(ctx) {
    return ctx.renderCalendar(ctx.getDefaultLocale());
  }
});
/* istanbul ignore next */

Calendar.install = function (Vue) {
  Vue.use(base);
  Vue.component(Calendar.name, Calendar);
};


/* harmony default export */ var components_calendar = (Calendar);
// CONCATENATED MODULE: ./src/components/grid/col.tsx



function col_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function col_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { col_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { col_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




var stringOrNumber = vue_types.oneOfType([vue_types.string, vue_types.number]);
var ColSize = vue_types.shape({
  span: stringOrNumber,
  order: stringOrNumber,
  offset: stringOrNumber,
  push: stringOrNumber,
  pull: stringOrNumber
}).loose;
var objectOrNumber = vue_types.oneOfType([vue_types.string, vue_types.number, ColSize]);
var ColProps = {
  span: stringOrNumber,
  order: stringOrNumber,
  offset: stringOrNumber,
  push: stringOrNumber,
  pull: stringOrNumber,
  xs: objectOrNumber,
  sm: objectOrNumber,
  md: objectOrNumber,
  lg: objectOrNumber,
  xl: objectOrNumber,
  xxl: objectOrNumber,
  prefixCls: vue_types.string
};
/* harmony default export */ var col = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ACol',
  props: ColProps,
  setup: function setup() {
    var configProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('configProvider') || ConfigConsumerProps;

    var rowContext = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('rowContext') || function () {
      return null;
    };

    return {
      rowContext: rowContext,
      configProvider: configProvider
    };
  },
  render: function render() {
    var _this = this,
        _Object$assign2;

    var span = this.span,
        order = this.order,
        offset = this.offset,
        push = this.push,
        pull = this.pull,
        customizePrefixCls = this.prefixCls,
        $slots = this.$slots,
        rowContext = this.rowContext;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('col', customizePrefixCls);
    var sizeClassObj = {};
    ['xs', 'sm', 'md', 'lg', 'xl', 'xxl'].forEach(function (size) {
      var _Object$assign;

      var sizeProps = {};
      var propSize = _this[size];

      if (typeof propSize === 'number') {
        sizeProps.span = propSize;
      } else if (typeof_default()(propSize) === 'object') {
        sizeProps = propSize || {};
      }

      sizeClassObj = Object.assign(Object.assign({}, sizeClassObj), (_Object$assign = {}, defineProperty_default()(_Object$assign, "".concat(prefixCls, "-").concat(size, "-").concat(sizeProps.span), sizeProps.span !== undefined), defineProperty_default()(_Object$assign, "".concat(prefixCls, "-").concat(size, "-order-").concat(sizeProps.order), sizeProps.order || sizeProps.order === 0), defineProperty_default()(_Object$assign, "".concat(prefixCls, "-").concat(size, "-offset-").concat(sizeProps.offset), sizeProps.offset || sizeProps.offset === 0), defineProperty_default()(_Object$assign, "".concat(prefixCls, "-").concat(size, "-push-").concat(sizeProps.push), sizeProps.push || sizeProps.push === 0), defineProperty_default()(_Object$assign, "".concat(prefixCls, "-").concat(size, "-pull-").concat(sizeProps.pull), sizeProps.pull || sizeProps.pull === 0), _Object$assign));
    });
    var classes = Object.assign((_Object$assign2 = {}, defineProperty_default()(_Object$assign2, "".concat(prefixCls), true), defineProperty_default()(_Object$assign2, "".concat(prefixCls, "-").concat(span), span !== undefined), defineProperty_default()(_Object$assign2, "".concat(prefixCls, "-order-").concat(order), order), defineProperty_default()(_Object$assign2, "".concat(prefixCls, "-offset-").concat(offset), offset), defineProperty_default()(_Object$assign2, "".concat(prefixCls, "-push-").concat(push), push), defineProperty_default()(_Object$assign2, "".concat(prefixCls, "-pull-").concat(pull), pull), _Object$assign2), sizeClassObj);
    var divProps = {
      "class": classes,
      style: {}
    };

    if (rowContext) {
      var gutter = rowContext.getGutter();

      if (gutter) {
        divProps.style = Object.assign(Object.assign({}, gutter[0] > 0 ? {
          paddingLeft: "".concat(gutter[0] / 2, "px"),
          paddingRight: "".concat(gutter[0] / 2, "px")
        } : {}), gutter[1] > 0 ? {
          paddingTop: "".concat(gutter[1] / 2, "px"),
          paddingBottom: "".concat(gutter[1] / 2, "px")
        } : {});
      }
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", col_objectSpread({}, divProps), [$slots["default"] && $slots["default"]()]);
  }
}));
// CONCATENATED MODULE: ./src/components/_util/responsive-observe.ts

// matchMedia polyfill for
// https://github.com/WickyNilliams/enquire.js/issues/82
var responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];
var responsiveMap = {
  xs: '(max-width: 575px)',
  sm: '(min-width: 576px)',
  md: '(min-width: 768px)',
  lg: '(min-width: 992px)',
  xl: '(min-width: 1200px)',
  xxl: '(min-width: 1600px)'
};
var subscribers = [];
var subUid = -1;
var responsive_observe_screens = {};
var responsiveObserve = {
  dispatch: function dispatch(pointMap) {
    responsive_observe_screens = pointMap;

    if (subscribers.length < 1) {
      return false;
    }

    subscribers.forEach(function (item) {
      item.func(responsive_observe_screens);
    });
    return true;
  },
  subscribe: function subscribe(func) {
    var token = (++subUid).toString();
    subscribers.push({
      token: token,
      func: func
    });
    func(responsive_observe_screens);
    return token;
  },
  unsubscribe: function unsubscribe(token) {
    subscribers = subscribers.filter(function (item) {
      return item.token !== token;
    });
  }
};
/* harmony default export */ var responsive_observe = (responsiveObserve);
// CONCATENATED MODULE: ./src/components/grid/row.tsx






var RowProps = {
  gutter: vue_types.oneOfType([vue_types.object, vue_types.number, vue_types.array]).def(0),
  type: vue_types.oneOf(['flex']),
  align: vue_types.oneOf(['top', 'middle', 'bottom', 'stretch']),
  justify: vue_types.oneOf(['start', 'end', 'center', 'space-around', 'space-between']),
  prefixCls: vue_types.string
};
var row_responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];
/* harmony default export */ var grid_row = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ARow',
  props: RowProps,
  setup: function setup(props) {
    var screens = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])([]);
    var configProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('configProvider') || ConfigConsumerProps;
    var token = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(function () {
      return null;
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        token.value = responsive_observe.subscribe(function (screens) {
          var gutter = props.gutter;

          if (typeof_default()(gutter) === 'object' || Array.isArray(gutter) && (typeof_default()(gutter[0]) === 'object' || typeof_default()(gutter[1]) === 'object')) {
            screens.value = screens;
          }
        });
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      responsive_observe.unsubscribe(token.value);
    });

    var getGutter = function getGutter() {
      var results = [0, 0];
      var gutter = props.gutter;
      var normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, 0];
      normalizedGutter.forEach(function (g, index) {
        if (typeof_default()(g) === 'object') {
          for (var i = 0; i < row_responsiveArray.length; i++) {
            var breakpoint = row_responsiveArray[i];

            if (screens[breakpoint] && g[breakpoint] !== undefined) {
              results[index] = g[breakpoint];
              break;
            }
          }
        } else {
          results[index] = g || 0;
        }
      });
      return results;
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])('rowContext', {
      getGutter: getGutter
    });
    return {
      configProvider: configProvider,
      getGutter: getGutter
    };
  },
  render: function render(ctx) {
    var _classes;

    var type = this.type,
        justify = this.justify,
        align = this.align,
        customizePrefixCls = this.prefixCls,
        $slots = this.$slots;
    var getPrefixCls = ctx.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('row', customizePrefixCls);
    var gutter = this.getGutter();
    var classes = (_classes = {}, defineProperty_default()(_classes, prefixCls, !type), defineProperty_default()(_classes, "".concat(prefixCls, "-").concat(type), type), defineProperty_default()(_classes, "".concat(prefixCls, "-").concat(type, "-").concat(justify), type && justify), defineProperty_default()(_classes, "".concat(prefixCls, "-").concat(type, "-").concat(align), type && align), _classes);
    var rowStyle = Object.assign(Object.assign({}, gutter[0] > 0 ? {
      marginLeft: "".concat(gutter[0] / -2, "px"),
      marginRight: "".concat(gutter[0] / -2, "px")
    } : {}), gutter[1] > 0 ? {
      marginTop: "".concat(gutter[1] / -2, "px"),
      marginBottom: "".concat(gutter[1] / -2, "px")
    } : {});
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": classes,
      "style": rowStyle
    }, [$slots["default"] && $slots["default"]()]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-tabs/src/utils.ts


function utils_toArray(children) {
  var c = [];
  children.forEach(function (child) {
    if (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["isVNode"])(child)) {
      c.push(child);
    }
  });
  return c;
}
function getActiveIndex(children, activeKey) {
  var c = utils_toArray(children);

  for (var i = 0; i < c.length; i++) {
    if (c[i].key === activeKey) {
      return i;
    }
  }

  return -1;
}
function utils_setTransform(style, v) {
  style.transform = v;
  style.webkitTransform = v;
  style.mozTransform = v;
}
function isTransform3dSupported(style) {
  return ('transform' in style || 'webkitTransform' in style || 'MozTransform' in style) && window.atob;
}
function getTransformPropValue(v) {
  return {
    transform: v,
    WebkitTransform: v,
    MozTransform: v
  };
}
function utils_isVertical(tabBarPosition) {
  return tabBarPosition === 'left' || tabBarPosition === 'right';
}
function getTransformByIndex(index, tabBarPosition) {
  var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'ltr';
  var translate = utils_isVertical(tabBarPosition) ? 'translateY' : 'translateX';

  if (!utils_isVertical(tabBarPosition) && direction === 'rtl') {
    return "".concat(translate, "(").concat(index * 100, "%) translateZ(0)");
  }

  return "".concat(translate, "(").concat(-index * 100, "%) translateZ(0)");
}
function getMarginStyle(index, tabBarPosition) {
  var marginDirection = utils_isVertical(tabBarPosition) ? 'marginTop' : 'marginLeft';
  return defineProperty_default()({}, marginDirection, "".concat(-index * 100, "%"));
}
function getStyle(el, property) {
  return +window.getComputedStyle(el).getPropertyValue(property).replace('px', '');
}

function toNum(style, property) {
  return +style.getPropertyValue(property).replace('px', '');
}

function getTypeValue(start, current, end, tabNode, wrapperNode) {
  var total = getStyle(wrapperNode, "padding-".concat(start));

  if (!tabNode || !tabNode.parentNode) {
    return total;
  }

  var childNodes = tabNode.parentNode.childNodes;
  Array.prototype.some.call(childNodes, function (node) {
    if (node.nodeType === 3) {
      return false;
    }

    var style = window.getComputedStyle(node);

    if (node !== tabNode) {
      total += toNum(style, "margin-".concat(start));
      total += node[current];
      total += toNum(style, "margin-".concat(end));

      if (style.boxSizing === 'content-box') {
        total += toNum(style, "border-".concat(start, "-width")) + toNum(style, "border-".concat(end, "-width"));
      }

      return false;
    } // We need count current node margin
    // ref: https://github.com/react-component/tabs/pull/139#issuecomment-431005262


    total += toNum(style, "margin-".concat(start));
    return true;
  });
  return total;
}

function getLeft(tabNode, wrapperNode) {
  return getTypeValue('left', 'offsetWidth', 'right', tabNode, wrapperNode);
}
function getTop(tabNode, wrapperNode) {
  return getTypeValue('top', 'offsetHeight', 'bottom', tabNode, wrapperNode);
}
// CONCATENATED MODULE: ./src/components/vc-tabs/src/tab-content.tsx





/* harmony default export */ var tab_content = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'TabContent',
  props: {
    animated: {
      type: Boolean,
      "default": true
    },
    animatedWithMargin: {
      type: Boolean,
      "default": true
    },
    prefixCls: {
      "default": 'ant-tabs',
      type: String
    },
    activeKey: vue_types.oneOfType([vue_types.string, vue_types.number]),
    tabBarPosition: String,
    direction: vue_types.string,
    destroyInactiveTabPane: vue_types.bool
  },
  setup: function setup(props, _ref) {
    var slots = _ref.slots;

    var getClasses = function getClasses() {
      var _ref2;

      var animated = props.animated,
          prefixCls = props.prefixCls;
      return _ref2 = {}, defineProperty_default()(_ref2, "".concat(prefixCls, "-content"), true), defineProperty_default()(_ref2, animated ? "".concat(prefixCls, "-content-animated") : "".concat(prefixCls, "-content-no-animated"), true), _ref2;
    };

    var getTabPanes = function getTabPanes() {
      var activeKey = props.activeKey;
      var children = slots["default"] && slots["default"]() || [];
      var newChildren = [];
      children.forEach(function (child) {
        if (!child) {
          return;
        }

        var key = child.key;
        var active = activeKey === key;
        newChildren.push(cloneElement(child, {
          active: active,
          destroyInactiveTabPane: props.destroyInactiveTabPane,
          rootPrefixCls: props.prefixCls
        }));
      });
      return newChildren;
    };

    return {
      getTabPanes: getTabPanes,
      getClasses: getClasses
    };
  },
  render: function render() {
    var activeKey = this.activeKey,
        tabBarPosition = this.tabBarPosition,
        animated = this.animated,
        animatedWithMargin = this.animatedWithMargin,
        direction = this.direction,
        getClasses = this.getClasses;
    var style = {};

    if (animated && this.$slots["default"]) {
      var activeIndex = getActiveIndex(this.$slots["default"](), activeKey);

      if (activeIndex !== -1) {
        var animatedStyle = animatedWithMargin ? getMarginStyle(activeIndex, tabBarPosition) : getTransformPropValue(getTransformByIndex(activeIndex, tabBarPosition, direction));
        style = animatedStyle;
      } else {
        style = {
          display: 'none'
        };
      }
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": getClasses(),
      "style": style
    }, [this.getTabPanes()]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-tabs/src/sentinel.tsx


function sentinel_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function sentinel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { sentinel_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { sentinel_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/* harmony default export */ var sentinel = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'Sentinel',
  props: {
    setRef: vue_types.func,
    prevElement: vue_types.any,
    nextElement: vue_types.any
  },
  setup: function setup(props) {
    var onKeyDown = function onKeyDown(_ref) {
      var target = _ref.target,
          which = _ref.which,
          shiftKey = _ref.shiftKey;
      var nextElement = props.nextElement,
          prevElement = props.prevElement;

      if (which !== keycode.TAB || document.activeElement !== target) {
        return;
      } // Tab next


      if (!shiftKey && nextElement) {
        nextElement.focus();
      } // Tab prev


      if (shiftKey && prevElement) {
        prevElement.focus();
      }
    };

    return {
      onKeyDown: onKeyDown
    };
  },
  render: function render(ctx) {
    var setRef = ctx.$props.setRef;
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", sentinel_objectSpread({
      "tabindex": 0
    }, {
      directives: [{
        name: 'ant-ref',
        value: setRef
      }]
    }, {
      "style": {
        width: '0',
        height: '0',
        overflow: 'hidden',
        position: 'absolute'
      },
      "onKeydown": ctx.onKeyDown,
      "role": "presentation"
    }), [ctx.$slots["default"] && ctx.$slots["default"]()]);
  }
}));
// CONCATENATED MODULE: ./src/components/_util/is-valid.ts


var is_valid_isValid = function isValid(value) {
  return value !== undefined && value !== null && value !== '';
};

/* harmony default export */ var is_valid = (is_valid_isValid);
// CONCATENATED MODULE: ./src/components/vc-tabs/src/keycode.ts

/* harmony default export */ var src_keycode = ({
  /**
   * LEFT
   */
  LEFT: 37,

  /**
   * UP
   */
  UP: 38,

  /**
   * RIGHT
   */
  RIGHT: 39,

  /**
   * DOWN
   */
  DOWN: 40
});
// CONCATENATED MODULE: ./src/components/vc-tabs/src/tabs.tsx


function tabs_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tabs_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tabs_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tabs_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }











function getDefaultActiveKey(props) {
  var activeKey;
  var children = props.children;
  children.forEach(function (child) {
    if (child && !is_valid(activeKey) && !child.disabled) {
      activeKey = child.key;
    }
  });
  return activeKey;
}

function activeKeyIsValid(props, key) {
  var children = props.children;
  var keys = children.map(function (child) {
    return child && child.key;
  });
  return keys.indexOf(key) >= 0;
}

var tabs_useSentinelContext = function useSentinelContext() {
  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('sentinelContext', {});
};
/* harmony default export */ var src_tabs = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'Tabs',
  model: {
    prop: 'activeKey',
    event: 'change'
  },
  props: {
    destroyInactiveTabPane: vue_types.bool,
    renderTabBar: vue_types.func.isRequired,
    renderTabContent: vue_types.func.isRequired,
    navWrapper: vue_types.func.def(function () {
      return function (arg) {
        return arg;
      };
    }),
    children: vue_types.any.def(function () {
      return [];
    }),
    prefixCls: vue_types.string.def('ant-tabs'),
    tabBarPosition: vue_types.string.def('top'),
    activeKey: vue_types.oneOfType([vue_types.string, vue_types.number]),
    defaultActiveKey: vue_types.oneOfType([vue_types.string, vue_types.number]),
    __propsSymbol__: vue_types.any,
    direction: vue_types.string.def('ltr'),
    tabBarGutter: vue_types.number
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var tabBar = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var sentinelContext = tabs_useSentinelContext();
    var destroy = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var sentinelStart = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var sentinelId = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var sentinelEnd = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var panelSentinelStart = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var panelSentinelEnd = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var getActiveKey = function getActiveKey() {
      var activeKey;

      if (props.activeKey !== undefined) {
        activeKey = props.activeKey;
      } else if (props.defaultActiveKey !== undefined) {
        activeKey = props.defaultActiveKey;
      } else {
        activeKey = getDefaultActiveKey(props);
      }

      return activeKey;
    };

    var _activeKey = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(getActiveKey());

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      if (props.activeKey !== undefined) {
        _activeKey.value = props.activeKey;
      } else if (!activeKeyIsValid(props, _activeKey.value)) {
        // https://github.com/ant-design/ant-design/issues/7093
        _activeKey.value = getDefaultActiveKey(props);
      }
    });

    var onTabClick = function onTabClick(activeKey, e) {
      var tabClick = tabBar.value.props.onTabClick;

      if (tabClick) {
        tabClick(activeKey, e);
      }

      setActiveKey(activeKey);
    };

    var onNavKeyDown = function onNavKeyDown(e) {
      var eventKeyCode = e.keyCode;

      if (eventKeyCode === src_keycode.RIGHT || eventKeyCode === src_keycode.DOWN) {
        e.preventDefault();
        var nextKey = getNextActiveKey(true);
        onTabClick(nextKey);
      } else if (eventKeyCode === src_keycode.LEFT || eventKeyCode === src_keycode.UP) {
        e.preventDefault();
        var previousKey = getNextActiveKey(false);
        onTabClick(previousKey);
      }
    };

    var onScroll = function onScroll(_ref2) {
      var target = _ref2.target,
          currentTarget = _ref2.currentTarget;

      if (target === currentTarget && target.scrollLeft > 0) {
        target.scrollLeft = 0;
      }
    };

    var setSentinelStart = function setSentinelStart(node) {
      sentinelStart.value = node;
    };

    var setSentinelEnd = function setSentinelEnd(node) {
      sentinelEnd.value = node;
    };

    var setPanelSentinelStart = function setPanelSentinelStart(node) {
      if (node !== panelSentinelStart.value) {
        updateSentinelContext();
      }

      panelSentinelStart.value = node;
    };

    var setPanelSentinelEnd = function setPanelSentinelEnd(node) {
      if (node !== panelSentinelEnd.value) {
        updateSentinelContext();
      }

      panelSentinelEnd.value = node;
    };

    var setActiveKey = function setActiveKey(activeKey) {
      if (_activeKey.value !== activeKey) {
        _activeKey.value = activeKey;
        emit('change', activeKey);
      }
    };

    var getNextActiveKey = function getNextActiveKey(next) {
      var activeKey = _activeKey.value;
      var children = [];
      props.children.forEach(function (c) {
        if (c && !c.disabled && c.disabled !== '') {
          if (next) {
            children.push(c);
          } else {
            children.unshift(c);
          }
        }
      });
      var length = children.length;
      var ret = length && children[0].key;
      children.forEach(function (child, i) {
        if (child.key === activeKey) {
          if (i === length - 1) {
            ret = children[0].key;
          } else {
            ret = children[i + 1].key;
          }
        }
      });
      return ret;
    };

    var updateSentinelContext = function updateSentinelContext() {
      if (destroy.value) {
        return;
      }

      raf_default.a.cancel(sentinelId.value);
      sentinelId.value = raf_default()(function () {
        if (destroy.value) {
          return;
        }

        instance.update();
      });
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      destroy.value = true;
      raf_default.a.cancel(sentinelId.value);
    });

    var setTabBar = function setTabBar(el) {
      tabBar.value = el;
    };

    return {
      _activeKey: _activeKey,
      tabBar: tabBar,
      onTabClick: onTabClick,
      setTabBar: setTabBar,
      onNavKeyDown: onNavKeyDown,
      onScroll: onScroll,
      setSentinelStart: setSentinelStart,
      setSentinelEnd: setSentinelEnd,
      setPanelSentinelStart: setPanelSentinelStart,
      setPanelSentinelEnd: setPanelSentinelEnd,
      setActiveKey: setActiveKey,
      getNextActiveKey: getNextActiveKey,
      updateSentinelContext: updateSentinelContext,
      panelSentinelStart: panelSentinelStart,
      panelSentinelEnd: panelSentinelEnd,
      sentinelContext: sentinelContext
    };
  },
  render: function render(ctx) {
    var _cls;

    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var props = this.$props;
    var prefixCls = props.prefixCls,
        navWrapper = props.navWrapper,
        tabBarPosition = props.tabBarPosition,
        renderTabContent = props.renderTabContent,
        renderTabBar = props.renderTabBar,
        destroyInactiveTabPane = props.destroyInactiveTabPane,
        direction = props.direction,
        tabBarGutter = props.tabBarGutter;
    var cls = (_cls = {}, defineProperty_default()(_cls, prefixCls, 1), defineProperty_default()(_cls, "".concat(prefixCls, "-").concat(tabBarPosition), 1), defineProperty_default()(_cls, "".concat(prefixCls, "-rtl"), direction === 'rtl'), _cls);
    ctx.setTabBar(renderTabBar());
    var tabBar = cloneElement(ctx.tabBar, {
      prefixCls: prefixCls,
      navWrapper: navWrapper,
      tabBarPosition: tabBarPosition,
      panels: props.children,
      activeKey: this._activeKey,
      direction: direction,
      tabBarGutter: tabBarGutter,
      onKeydown: this.onNavKeyDown,
      onTabClick: this.onTabClick,
      key: 'tabBar'
    });
    var tabContent = cloneElement(renderTabContent(), {
      prefixCls: prefixCls,
      tabBarPosition: tabBarPosition,
      activeKey: this._activeKey,
      destroyInactiveTabPane: destroyInactiveTabPane,
      direction: direction,
      onChange: this.setActiveKey,
      children: props.children,
      key: 'tabContent'
    });
    var sentinelStart = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(sentinel, {
      "key": "sentinelStart",
      "setRef": this.setSentinelStart,
      "nextElement": this.panelSentinelStart
    }, []);
    var sentinelEnd = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(sentinel, {
      "key": "sentinelEnd",
      "setRef": this.setSentinelEnd,
      "prevElement": this.panelSentinelEnd
    }, []);
    var contents = [];

    if (tabBarPosition === 'bottom') {
      contents.push(sentinelStart, tabContent, sentinelEnd, tabBar);
    } else {
      contents.push(tabBar, sentinelStart, tabContent, sentinelEnd);
    }

    var tabsProps = Object.assign(Object.assign({}, es(getListenersFromInstance(instance), ['change'])), {
      scroll: this.onScroll,
      "class": cls
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", tabs_objectSpread({}, tabsProps), [contents]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-tabs/src/tab-pane.tsx







/* harmony default export */ var tab_pane = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'TabPane',
  props: {
    active: vue_types.bool,
    destroyInactiveTabPane: vue_types.bool,
    forceRender: vue_types.bool,
    placeholder: vue_types.any,
    rootPrefixCls: vue_types.string,
    tab: vue_types.any,
    closable: vue_types.bool,
    disabled: vue_types.bool
  },
  setup: function setup() {
    var _useLocalValue = value_useLocalValue(false, 'active'),
        active = _useLocalValue.value,
        setActive = _useLocalValue.setValue;

    return {
      active: active,
      setActive: setActive,
      sentinelContext: tabs_useSentinelContext()
    };
  },
  render: function render(ctx) {
    var _cls;

    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var _ctx$$props = ctx.$props,
        destroyInactiveTabPane = _ctx$$props.destroyInactiveTabPane,
        active = _ctx$$props.active,
        forceRender = _ctx$$props.forceRender,
        rootPrefixCls = _ctx$$props.rootPrefixCls;
    var children = ctx.$slots["default"]();
    var placeholder = props_util_getComponentFromProp(instance, 'placeholder');
    var prefixCls = "".concat(rootPrefixCls, "-tabpane");
    var cls = (_cls = {}, defineProperty_default()(_cls, prefixCls, 1), defineProperty_default()(_cls, "".concat(prefixCls, "-inactive"), !active), defineProperty_default()(_cls, "".concat(prefixCls, "-active"), active), _cls);
    var isRender = destroyInactiveTabPane ? active : this.active;
    var shouldRender = isRender || forceRender;
    var _this$sentinelContext = this.sentinelContext,
        sentinelStart = _this$sentinelContext.sentinelStart,
        sentinelEnd = _this$sentinelContext.sentinelEnd,
        setPanelSentinelStart = _this$sentinelContext.setPanelSentinelStart,
        setPanelSentinelEnd = _this$sentinelContext.setPanelSentinelEnd;
    var panelSentinelStart;
    var panelSentinelEnd;

    if (active && shouldRender) {
      panelSentinelStart = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(sentinel, {
        "setRef": setPanelSentinelStart,
        "prevElement": sentinelStart
      }, []);
      panelSentinelEnd = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(sentinel, {
        "setRef": setPanelSentinelEnd,
        "nextElement": sentinelEnd
      }, []);
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": cls,
      "role": "tabpanel",
      "aria-hidden": active ? 'false' : 'true'
    }, [panelSentinelStart, shouldRender ? children : placeholder, panelSentinelEnd]);
  }
}));
// CONCATENATED MODULE: ./src/components/_util/style-checker.ts


var isStyleSupport = function isStyleSupport(styleName) {
  if (typeof window !== 'undefined' && window.document && window.document.documentElement) {
    var styleNameList = Array.isArray(styleName) ? styleName : [styleName];
    var documentElement = window.document.documentElement;
    return styleNameList.some(function (name) {
      return name in documentElement.style;
    });
  }

  return false;
};

var isFlexSupported = isStyleSupport(['flex', 'webkitFlex', 'Flex', 'msFlex']);
/* harmony default export */ var style_checker = (isStyleSupport);
// CONCATENATED MODULE: ./src/components/vc-tabs/src/index.ts

// based on rc-tabs 9.7.0



/* harmony default export */ var vc_tabs_src = (src_tabs);

// CONCATENATED MODULE: ./src/components/vc-tabs/src/ink-tab-bar-node.tsx





function componentDidUpdate(component, init) {
  var context = component['ctx'];
  var getRef = context.getRef,
      _context$styles = context.styles,
      styles = _context$styles === void 0 ? {} : _context$styles,
      panels = context.panels,
      activeKey = context.activeKey,
      direction = context.direction;
  var rootNode = getRef('root');
  var wrapNode = getRef('nav') || rootNode;
  var inkBarNode = getRef('inkBar');
  var activeTab = getRef('activeTab');
  var inkBarNodeStyle = inkBarNode.style;
  var tabBarPosition = context.tabBarPosition;
  var activeIndex = getActiveIndex(panels, activeKey);

  if (init) {
    // prevent mount animation
    inkBarNodeStyle.display = 'none';
  }

  if (activeTab) {
    var tabNode = activeTab;
    var transformSupported = isTransform3dSupported(inkBarNodeStyle); // Reset current style

    utils_setTransform(inkBarNodeStyle, '');
    inkBarNodeStyle.width = '';
    inkBarNodeStyle.height = '';
    inkBarNodeStyle.left = '';
    inkBarNodeStyle.top = '';
    inkBarNodeStyle.bottom = '';
    inkBarNodeStyle.right = '';

    if (tabBarPosition === 'top' || tabBarPosition === 'bottom') {
      var left = getLeft(tabNode, wrapNode);
      var width = tabNode.offsetWidth; // If tabNode'width width equal to wrapNode'width when tabBarPosition is top or bottom
      // It means no css working, then ink bar should not have width until css is loaded
      // Fix https://github.com/ant-design/ant-design/issues/7564

      if (width === rootNode.offsetWidth) {
        width = 0;
      } else if (styles.inkBar && styles.inkBar.width !== undefined) {
        width = parseFloat(styles.inkBar.width);

        if (width) {
          left += (tabNode.offsetWidth - width) / 2;
        }
      }

      if (direction === 'rtl') {
        left = getStyle(tabNode, 'margin-left') - left;
      } // use 3d gpu to optimize render


      if (transformSupported) {
        utils_setTransform(inkBarNodeStyle, "translate3d(".concat(left, "px,0,0)"));
      } else {
        inkBarNodeStyle.left = "".concat(left, "px");
      }

      inkBarNodeStyle.width = "".concat(width, "px");
    } else {
      var top = getTop(tabNode, wrapNode);
      var height = tabNode.offsetHeight;

      if (styles.inkBar && styles.inkBar.height !== undefined) {
        height = parseFloat(styles.inkBar.height);

        if (height) {
          top += (tabNode.offsetHeight - height) / 2;
        }
      }

      if (transformSupported) {
        utils_setTransform(inkBarNodeStyle, "translate3d(0,".concat(top, "px,0)"));
        inkBarNodeStyle.top = '0';
      } else {
        inkBarNodeStyle.top = "".concat(top, "px");
      }

      inkBarNodeStyle.height = "".concat(height, "px");
    }
  }

  inkBarNodeStyle.display = activeIndex === -1 ? 'none' : 'block';
}

/* harmony default export */ var ink_tab_bar_node = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'InkTabBarNode',
  inheritAttrs: false,
  props: {
    inkBarAnimated: {
      type: Boolean,
      "default": true
    },
    direction: vue_types.string,
    prefixCls: String,
    styles: Object,
    tabBarPosition: String,
    saveRef: vue_types.func.def(function () {}),
    getRef: vue_types.func.def(function () {}),
    panels: vue_types.array,
    activeKey: vue_types.oneOfType([vue_types.string, vue_types.number])
  },
  setup: function setup() {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        componentDidUpdate(instance, true);
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        componentDidUpdate(instance);
      });
    });
    return {};
  },
  render: function render() {
    var _classes;

    var prefixCls = this.prefixCls,
        _this$styles = this.styles,
        styles = _this$styles === void 0 ? {} : _this$styles,
        inkBarAnimated = this.inkBarAnimated;
    var className = "".concat(prefixCls, "-ink-bar");
    var classes = (_classes = {}, defineProperty_default()(_classes, className, true), defineProperty_default()(_classes, inkBarAnimated ? "".concat(className, "-animated") : "".concat(className, "-no-animated"), true), _classes);
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "style": styles.inkBar,
      "class": classes,
      "key": "inkBar",
      "ref": this.saveRef('inkBar')
    }, []);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-tabs/src/scrollable-tab-bar-node.tsx







var DEFAULT_DEBOUNCE_TIME = 200;

function scrollable_tab_bar_node_noop() {}

/* harmony default export */ var scrollable_tab_bar_node = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ScrollableTabBarNode',
  inheritAttrs: false,
  props: {
    activeKey: vue_types.any,
    getRef: vue_types.func.def(function () {}),
    saveRef: vue_types.func.def(function () {}),
    tabBarPosition: vue_types.oneOf(['left', 'right', 'top', 'bottom']).def('left'),
    prefixCls: vue_types.string.def(''),
    scrollAnimated: vue_types.bool.def(true),
    navWrapper: vue_types.func.def(function () {
      return function (arg) {
        return arg;
      };
    }),
    prevIcon: vue_types.any,
    nextIcon: vue_types.any,
    direction: vue_types.string
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var offset = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(0);
    var prevProps = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(Object.assign({}, props));
    var next = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var lastNextPrevShown = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var prev = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.tabBarPosition;
    }, function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        setOffset(0);
      });
    });

    var updatedCal = function updatedCal(prevProps) {
      if (prevProps && prevProps.tabBarPosition !== props.tabBarPosition) {
        setOffset(0);
        return;
      } // wait next, prev show hide


      if (isNextPrevShown({
        prev: prev.value,
        next: next.value
      }) !== isNextPrevShown(setNextPrev())) {
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
          scrollToActiveTab();
        });
      } else if (!prevProps || props.activeKey !== prevProps.activeKey) {
        // can not use props.activeKey
        scrollToActiveTab();
      }
    };

    var setNextPrev = function setNextPrev() {
      var navNode = props.getRef('nav');
      var navTabsContainer = props.getRef('navTabsContainer');
      var navNodeWH = getScrollWH(navTabsContainer || navNode); // Add 1px to fix `offsetWidth` with decimal in Chrome not correct handle
      // https://github.com/ant-design/ant-design/issues/13423

      var containerWH = getOffsetWH(props.getRef('container')) + 1;
      var navWrapNodeWH = getOffsetWH(props.getRef('navWrap'));
      var localOffset = offset.value;
      var minOffset = containerWH - navNodeWH;
      var localNext = next.value;

      if (minOffset >= 0) {
        localNext = false;
        setOffset(0, false);
        localOffset = 0;
      } else if (minOffset < localOffset) {
        localNext = true;
      } else {
        localNext = false; // Fix https://github.com/ant-design/ant-design/issues/8861
        // Test with container offset which is stable
        // and set the offset of the nav wrap node

        var realOffset = navWrapNodeWH - navNodeWH;
        setOffset(realOffset, false);
        localOffset = realOffset;
      }

      var localPrev = localOffset < 0;
      setNext(localNext);
      setPrev(localPrev);
      return {
        next: localNext,
        prev: localPrev
      };
    };

    var getOffsetWH = function getOffsetWH(node) {
      var tabBarPosition = props.tabBarPosition;
      var prop = 'offsetWidth';

      if (tabBarPosition === 'left' || tabBarPosition === 'right') {
        prop = 'offsetHeight';
      }

      return node[prop];
    };

    var getScrollWH = function getScrollWH(node) {
      var tabBarPosition = props.tabBarPosition;
      var prop = 'scrollWidth';

      if (tabBarPosition === 'left' || tabBarPosition === 'right') {
        prop = 'scrollHeight';
      }

      return node[prop];
    };

    var getOffsetLT = function getOffsetLT(node) {
      var tabBarPosition = props.tabBarPosition;
      var prop = 'left';

      if (tabBarPosition === 'left' || tabBarPosition === 'right') {
        prop = 'top';
      }

      return node.getBoundingClientRect()[prop];
    };

    var setOffset = function setOffset(localOffset) {
      var checkNextPrev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var target = Math.min(0, localOffset);

      if (offset.value !== target) {
        offset.value = target;
        var navOffset;
        var tabBarPosition = props.tabBarPosition;
        var navStyle = props.getRef('nav').style;
        var transformSupported = isTransform3dSupported(navStyle);

        if (tabBarPosition === 'left' || tabBarPosition === 'right') {
          if (transformSupported) {
            navOffset = {
              value: "translate3d(0,".concat(target, "px,0)")
            };
          } else {
            navOffset = {
              name: 'top',
              value: "".concat(target, "px")
            };
          }
        } else if (transformSupported) {
          if (props.direction === 'rtl') {
            target = -target;
          }

          navOffset = {
            value: "translate3d(".concat(target, "px,0,0)")
          };
        } else {
          navOffset = {
            name: 'left',
            value: "".concat(target, "px")
          };
        }

        if (transformSupported) {
          utils_setTransform(navStyle, navOffset.value);
        } else {
          navStyle[navOffset.name] = navOffset.value;
        }

        if (checkNextPrev) {
          setNextPrev();
        }
      }
    };

    var setPrev = function setPrev(v) {
      if (prev.value !== v) {
        prev.value = v;
      }
    };

    var setNext = function setNext(v) {
      if (!v) {// debugger
      }

      if (next.value !== v) {
        next.value = v;
      }
    };

    var isNextPrevShown = function isNextPrevShown(state) {
      if (state) {
        return state.next || state.prev;
      }

      return next.value || prev.value;
    };

    var prevTransitionEnd = function prevTransitionEnd(e) {
      if (e.propertyName !== 'opacity') {
        return;
      }

      var container = props.getRef('container');
      scrollToActiveTab({
        target: container,
        currentTarget: container
      });
    };

    var scrollToActiveTab = function scrollToActiveTab(e) {
      var activeTab = props.getRef('activeTab');
      var navWrap = props.getRef('navWrap');

      if (e && e.target !== e.currentTarget || !activeTab) {
        return;
      } // when not scrollable or enter scrollable first time, don't emit scrolling


      var needToSroll = isNextPrevShown() && lastNextPrevShown.value;
      lastNextPrevShown.value = isNextPrevShown();

      if (!needToSroll) {
        return;
      }

      var activeTabWH = getScrollWH(activeTab);
      var navWrapNodeWH = getOffsetWH(navWrap);
      var wrapOffset = getOffsetLT(navWrap);
      var activeTabOffset = getOffsetLT(activeTab);

      if (wrapOffset > activeTabOffset) {
        offset.value += wrapOffset - activeTabOffset;
        setOffset(offset.value);
      } else if (wrapOffset + navWrapNodeWH < activeTabOffset + activeTabWH) {
        offset.value -= activeTabOffset + activeTabWH - (wrapOffset + navWrapNodeWH);
        setOffset(offset.value);
      }
    };

    var prevClick = function prevClick(e) {
      emit('prevClick', e);
      var navWrapNode = props.getRef('navWrap');
      var navWrapNodeWH = getOffsetWH(navWrapNode);
      setOffset(offset.value + navWrapNodeWH);
    };

    var nextClick = function nextClick(e) {
      emit('nextClick', e);
      var navWrapNode = props.getRef('navWrap');
      var navWrapNodeWH = getOffsetWH(navWrapNode);
      setOffset(offset.value - navWrapNodeWH);
    };

    var debouncedResize = null;
    var resizeObserver = null;
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        updatedCal();
        debouncedResize = debounce_default()(function () {
          setNextPrev();
          scrollToActiveTab();
        }, DEFAULT_DEBOUNCE_TIME);
        resizeObserver = new ResizeObserver_es["a" /* default */](debouncedResize);
        resizeObserver.observe(props.getRef('container'));
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        updatedCal(prevProps.value);
        prevProps.value = Object.assign({}, props);
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }

      if (debouncedResize && debouncedResize.cancel) {
        debouncedResize.cancel();
      }
    });

    var renderPrevNextBtn = function renderPrevNextBtn() {
      var _ref2, _ref3;

      var prevIcon = props_util_getComponentFromProp(instance, 'prevIcon');
      var nextIcon = props_util_getComponentFromProp(instance, 'nextIcon');
      var showNextPrev = prev.value || next.value;
      var prefixCls = props.prefixCls;
      var prevButton = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "onClick": prev.value ? prevClick : function () {},
        "unselectable": "on",
        "class": (_ref2 = {}, defineProperty_default()(_ref2, "".concat(prefixCls, "-tab-prev"), 1), defineProperty_default()(_ref2, "".concat(prefixCls, "-tab-btn-disabled"), !prev.value), defineProperty_default()(_ref2, "".concat(prefixCls, "-tab-arrow-show"), showNextPrev), _ref2),
        "onTransitionend": prevTransitionEnd
      }, [prevIcon || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-tab-prev-icon")
      }, [])]);
      var nextButton = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "onClick": next.value ? nextClick : undefined,
        "unselectable": "on",
        "class": (_ref3 = {}, defineProperty_default()(_ref3, "".concat(prefixCls, "-tab-next"), 1), defineProperty_default()(_ref3, "".concat(prefixCls, "-tab-btn-disabled"), !next.value), defineProperty_default()(_ref3, "".concat(prefixCls, "-tab-arrow-show"), showNextPrev), _ref3)
      }, [nextIcon || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-tab-next-icon")
      }, [])]); // @ts-ignore

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Fragment"], {}, [prevButton, nextButton]);
    };

    return {
      renderPrevNextBtn: renderPrevNextBtn,
      updatedCal: updatedCal,
      setNextPrev: setNextPrev,
      getOffsetWH: getOffsetWH,
      getScrollWH: getScrollWH,
      getOffsetLT: getOffsetLT,
      setOffset: setOffset,
      setPrev: setPrev,
      setNext: setNext,
      isNextPrevShown: isNextPrevShown,
      prevTransitionEnd: prevTransitionEnd,
      scrollToActiveTab: scrollToActiveTab,
      next: next,
      prev: prev
    };
  },
  render: function render(ctx) {
    var _navClasses, _ref4;

    var next = this.next,
        prev = this.prev;
    var _this$$props = this.$props,
        prefixCls = _this$$props.prefixCls,
        scrollAnimated = _this$$props.scrollAnimated,
        navWrapper = _this$$props.navWrapper;
    var showNextPrev = prev || next;
    var navClassName = "".concat(prefixCls, "-nav");
    var navClasses = (_navClasses = {}, defineProperty_default()(_navClasses, navClassName, true), defineProperty_default()(_navClasses, scrollAnimated ? "".concat(navClassName, "-animated") : "".concat(navClassName, "-no-animated"), true), _navClasses);
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": (_ref4 = {}, defineProperty_default()(_ref4, "".concat(prefixCls, "-nav-container"), 1), defineProperty_default()(_ref4, "".concat(prefixCls, "-nav-container-scrolling"), showNextPrev), _ref4),
      "key": "container",
      "ref": this.saveRef('container')
    }, [ctx.renderPrevNextBtn(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-nav-wrap"),
      "ref": this.saveRef('navWrap')
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-nav-scroll")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": navClasses,
      "ref": this.saveRef('nav')
    }, [navWrapper(this.$slots["default"]())])])])]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-tabs/src/tab-bar-root-node.tsx






function tab_bar_root_node_noop() {}

/* harmony default export */ var tab_bar_root_node = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'TabBarRootNode',
  inheritAttrs: false,
  props: {
    saveRef: vue_types.func.def(tab_bar_root_node_noop),
    getRef: vue_types.func.def(tab_bar_root_node_noop),
    prefixCls: vue_types.string.def(''),
    tabBarPosition: vue_types.string.def('top'),
    extraContent: vue_types.any
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var onKeyDown = function onKeyDown(e) {
      emit('keydown', e);
    };

    return {
      onKeyDown: onKeyDown
    };
  },
  render: function render(ctx) {
    var prefixCls = ctx.prefixCls,
        onKeyDown = ctx.onKeyDown,
        tabBarPosition = ctx.tabBarPosition,
        extraContent = ctx.extraContent;
    var cls = classnames_default()(defineProperty_default()({}, "".concat(prefixCls, "-bar"), true), ctx.$attrs["class"]);
    var topOrBottom = tabBarPosition === 'top' || tabBarPosition === 'bottom';
    var tabBarExtraContentStyle = topOrBottom ? {
      "float": 'right'
    } : {};
    var children = this.$slots["default"]();
    var newChildren = children;

    if (extraContent) {
      newChildren = [cloneElement(extraContent, {
        key: 'extra',
        style: Object.assign({}, tabBarExtraContentStyle)
      }), cloneElement(children, {
        key: 'content'
      })];
      newChildren = topOrBottom ? newChildren : newChildren.reverse();
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "role": "tablist",
      "class": cls,
      "tabindex": 0,
      "ref": this.saveRef('root'),
      "onKeydown": onKeyDown
    }, [newChildren]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-tabs/src/tab-bar-tabs-node.tsx


function tab_bar_tabs_node_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tab_bar_tabs_node_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tab_bar_tabs_node_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tab_bar_tabs_node_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






function tab_bar_tabs_node_noop() {}

/* harmony default export */ var tab_bar_tabs_node = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'TabBarTabsNode',
  inheritAttrs: false,
  props: {
    activeKey: vue_types.oneOfType([vue_types.string, vue_types.number]),
    panels: vue_types.any.def([]),
    prefixCls: vue_types.string.def(''),
    tabBarGutter: vue_types.any.def(null),
    onTabClick: vue_types.func,
    saveRef: vue_types.func.def(tab_bar_tabs_node_noop),
    getRef: vue_types.func.def(tab_bar_tabs_node_noop),
    renderTabBarNode: vue_types.func,
    tabBarPosition: vue_types.string,
    direction: vue_types.string
  },
  render: function render(ctx) {
    var _ctx$$props = ctx.$props,
        children = _ctx$$props.panels,
        activeKey = _ctx$$props.activeKey,
        prefixCls = _ctx$$props.prefixCls,
        tabBarGutter = _ctx$$props.tabBarGutter,
        saveRef = _ctx$$props.saveRef,
        tabBarPosition = _ctx$$props.tabBarPosition,
        direction = _ctx$$props.direction;
    var rst = [];
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var renderTabBarNode = props_util_getComponentFromProp(instance, 'renderTabBarNode');
    children.forEach(function (child, index) {
      if (!child) {
        return;
      }

      var props = getOptionProps(child);
      var key = child.key;
      var cls = activeKey === key ? "".concat(prefixCls, "-tab-active") : '';
      cls += " ".concat(prefixCls, "-tab");
      var events = {};
      var disabled = props.disabled || props.disabled === '';

      if (disabled) {
        cls += " ".concat(prefixCls, "-tab-disabled");
      } else {
        events.onClick = function () {
          ctx.$emit('tabClick', key);
        };
      }

      var tab = props_util_getComponentFromProp(child, 'tab');
      var gutter = tabBarGutter && index === children.length - 1 ? 0 : tabBarGutter;
      gutter = typeof gutter === 'number' ? "".concat(gutter, "px") : gutter;
      var marginProperty = direction === 'rtl' ? 'marginLeft' : 'marginRight';

      var style = defineProperty_default()({}, utils_isVertical(tabBarPosition) ? 'marginBottom' : marginProperty, gutter); // warning(tab !== undefined, 'There must be `tab` property or slot on children of Tabs.');


      var node = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", tab_bar_tabs_node_objectSpread({
        "role": "tab",
        "aria-disabled": disabled ? 'true' : 'false',
        "aria-selected": activeKey === key ? 'true' : 'false'
      }, events, {
        "class": cls,
        "key": key,
        "style": style,
        "ref": activeKey === key ? saveRef('activeTab') : null
      }), [tab]);

      if (renderTabBarNode && Array.isArray(renderTabBarNode) && renderTabBarNode.length > 0) {
        node = renderTabBarNode;
      }

      rst.push(node);
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "ref": ctx.saveRef('navTabsContainer')
    }, [rst]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-tabs/src/scrollable-ink-tab-bar.tsx


function scrollable_ink_tab_bar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function scrollable_ink_tab_bar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { scrollable_ink_tab_bar_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { scrollable_ink_tab_bar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }








/* harmony default export */ var scrollable_ink_tab_bar = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ScrollableInkTabBar',
  inheritAttrs: false,
  props: ['extraContent', 'inkBarAnimated', 'tabBarGutter', 'prefixCls', 'navWrapper', 'tabBarPosition', 'panels', 'activeKey', 'prevIcon', 'nextIcon'],
  setup: function setup() {
    var _useRefs = save_ref_useRefs(),
        getRef = _useRefs.getRef,
        saveRef = _useRefs.saveRef;

    return {
      getRef: getRef,
      saveRef: saveRef
    };
  },
  render: function render(ctx) {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var props = Object.assign({}, this.$props);
    var listeners = getListenersFromInstance(instance);
    var renderTabBarNode = this.$slots["default"];
    var getRef = ctx.getRef,
        saveRef = ctx.saveRef;
    var rootProps = Object.assign(Object.assign({}, props), listeners);
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(tab_bar_root_node, scrollable_ink_tab_bar_objectSpread({
      "style": ctx.$attrs.style,
      "class": ctx.$attrs["class"],
      "saveRef": saveRef
    }, rootProps), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(scrollable_tab_bar_node, scrollable_ink_tab_bar_objectSpread({
      "saveRef": saveRef,
      "getRef": getRef
    }, Object.assign(Object.assign({}, props), listeners)), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(tab_bar_tabs_node, scrollable_ink_tab_bar_objectSpread({
      "saveRef": saveRef
    }, Object.assign(Object.assign(Object.assign({}, props), {
      renderTabBarNode: renderTabBarNode()
    }), listeners)), []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(ink_tab_bar_node, scrollable_ink_tab_bar_objectSpread({
      "saveRef": saveRef,
      "getRef": getRef
    }, Object.assign(Object.assign({}, props), listeners)), [])])]);
  }
}));
// CONCATENATED MODULE: ./src/components/tabs/tab-bar.tsx



function tab_bar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tab_bar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tab_bar_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tab_bar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }







var TabBar = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'TabBar',
  inheritAttrs: false,
  props: {
    prefixCls: vue_types.string,
    tabBarStyle: vue_types.object,
    tabBarExtraContent: vue_types.any,
    type: vue_types.oneOf(['line', 'card', 'editable-card']),
    tabPosition: vue_types.oneOf(['top', 'right', 'bottom', 'left']).def('top'),
    tabBarPosition: vue_types.oneOf(['top', 'right', 'bottom', 'left']),
    size: vue_types.oneOf(['default', 'small', 'large']),
    animated: vue_types.oneOfType([vue_types.bool, vue_types.object]),
    renderTabBar: vue_types.func,
    panels: vue_types.array.def(function () {
      return [];
    }),
    activeKey: vue_types.oneOfType([vue_types.string, vue_types.number]),
    tabBarGutter: vue_types.number
  },
  render: function render() {
    var _cls;

    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var _this$$props = this.$props,
        tabBarStyle = _this$$props.tabBarStyle,
        _this$$props$animated = _this$$props.animated,
        animated = _this$$props$animated === void 0 ? true : _this$$props$animated,
        renderTabBar = _this$$props.renderTabBar,
        tabBarExtraContent = _this$$props.tabBarExtraContent,
        tabPosition = _this$$props.tabPosition,
        prefixCls = _this$$props.prefixCls,
        _this$$props$type = _this$$props.type,
        type = _this$$props$type === void 0 ? 'line' : _this$$props$type,
        size = _this$$props.size;
    var inkBarAnimated = typeof_default()(animated) === 'object' ? animated.inkBar : animated;
    var isVertical = tabPosition === 'left' || tabPosition === 'right';
    var prevIconType = isVertical ? 'up' : 'left';
    var nextIconType = isVertical ? 'down' : 'right';
    var prevIcon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-tab-prev-icon")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
      "type": prevIconType,
      "class": "".concat(prefixCls, "-tab-prev-icon-target")
    }, [])]);
    var nextIcon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-tab-next-icon")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
      "type": nextIconType,
      "class": "".concat(prefixCls, "-tab-next-icon-target")
    }, [])]); // Additional className for style usage

    var cls = (_cls = {}, defineProperty_default()(_cls, "".concat(prefixCls, "-").concat(tabPosition, "-bar"), true), defineProperty_default()(_cls, "".concat(prefixCls, "-").concat(size, "-bar"), !!size), defineProperty_default()(_cls, "".concat(prefixCls, "-card-bar"), type && type.indexOf('card') >= 0), _cls);
    var renderProps = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.$props), this.$attrs), {
      inkBarAnimated: inkBarAnimated,
      extraContent: tabBarExtraContent,
      prevIcon: prevIcon,
      nextIcon: nextIcon,
      style: tabBarStyle
    }), getListenersFromInstance(instance)), {
      "class": cls
    });
    var RenderTabBar;

    if (renderTabBar) {
      RenderTabBar = renderTabBar(renderProps, scrollable_ink_tab_bar); // https://github.com/vueComponent/ant-design-vue/issues/2157

      return cloneElement(RenderTabBar, renderProps);
    } else {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(scrollable_ink_tab_bar, tab_bar_objectSpread({}, renderProps), []);
    }
  }
});
/* harmony default export */ var tab_bar = (TabBar);
// CONCATENATED MODULE: ./src/components/tabs/tabs.tsx



function tabs_tabs_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tabs_tabs_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tabs_tabs_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tabs_tabs_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }











/* harmony default export */ var tabs_tabs = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  TabPane: tab_pane,
  name: 'ATabs',
  model: {
    prop: 'activeKey',
    event: 'change'
  },
  props: {
    prefixCls: vue_types.string,
    activeKey: vue_types.oneOfType([vue_types.string, vue_types.number]),
    defaultActiveKey: vue_types.oneOfType([vue_types.string, vue_types.number]),
    hideAdd: vue_types.bool.def(false),
    tabBarStyle: vue_types.object,
    tabBarExtraContent: vue_types.any,
    destroyInactiveTabPane: vue_types.bool.def(false),
    type: vue_types.oneOf(['line', 'card', 'editable-card']),
    tabPosition: vue_types.oneOf(['top', 'right', 'bottom', 'left']).def('top'),
    size: vue_types.oneOf(['default', 'small', 'large']),
    animated: vue_types.oneOfType([vue_types.bool, vue_types.object]),
    tabBarGutter: vue_types.number,
    renderTabBar: vue_types.func
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var removeTab = function removeTab(targetKey, e) {
      e.stopPropagation();

      if (!targetKey) {
        return;
      }

      emit('edit', targetKey, 'remove');
    };

    var createNewTab = function createNewTab(targetKey) {
      emit('edit', targetKey, 'add');
    };

    var onTabClick = function onTabClick(val) {
      emit('tabClick', val);
    };

    var onPrevClick = function onPrevClick(val) {
      emit('prevClick', val);
    };

    var onNextClick = function onNextClick(val) {
      emit('nextClick', val);
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      var NO_FLEX = ' no-flex';
      var tabNode = instance.vnode.el;

      if (tabNode && !isFlexSupported && tabNode.className.indexOf(NO_FLEX) === -1) {
        tabNode.className += NO_FLEX;
      }
    });
    return {
      removeTab: removeTab,
      createNewTab: createNewTab,
      onTabClick: onTabClick,
      onPrevClick: onPrevClick,
      onNextClick: onNextClick,
      configProvider: config_provider_useConfigProvider()
    };
  },
  render: function render(ctx) {
    var _cls,
        _this = this,
        _contentCls;

    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var props = getOptionProps(instance);
    var customizePrefixCls = props.prefixCls,
        size = props.size,
        _props$type = props.type,
        type = _props$type === void 0 ? 'line' : _props$type,
        tabPosition = props.tabPosition,
        _props$animated = props.animated,
        animated = _props$animated === void 0 ? true : _props$animated,
        hideAdd = props.hideAdd;
    var getPrefixCls = ctx.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('tabs', customizePrefixCls);
    var children = filterEmpty(this.$slots["default"]);
    var tabBarExtraContent = props_util_getComponentFromProp(instance, 'tabBarExtraContent');
    var tabPaneAnimated = typeof_default()(animated) === 'object' ? animated.tabPane : animated; // card tabs should not have animation

    if (type !== 'line') {
      tabPaneAnimated = 'animated' in props ? tabPaneAnimated : false;
    }

    var cls = (_cls = {}, defineProperty_default()(_cls, "".concat(prefixCls, "-vertical"), tabPosition === 'left' || tabPosition === 'right'), defineProperty_default()(_cls, "".concat(prefixCls, "-").concat(size), !!size), defineProperty_default()(_cls, "".concat(prefixCls, "-card"), type.indexOf('card') >= 0), defineProperty_default()(_cls, "".concat(prefixCls, "-").concat(type), true), defineProperty_default()(_cls, "".concat(prefixCls, "-no-animation"), !tabPaneAnimated), _cls); // only card type tabs can be added and closed

    var childrenWithClose = [];

    if (type === 'editable-card') {
      childrenWithClose = [];
      children.forEach(function (child, index) {
        var props = getOptionProps(child);
        var closable = props.closable;
        closable = typeof closable === 'undefined' ? true : closable;
        var closeIcon = closable ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
          "type": "close",
          "class": "".concat(prefixCls, "-close-x"),
          "onClick": function onClick(e) {
            return _this.removeTab(child.key, e);
          }
        }, []) : null;
        childrenWithClose.push(cloneElement(child, {
          tab: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
            "class": closable ? undefined : "".concat(prefixCls, "-tab-unclosable")
          }, [props_util_getComponentFromProp(child, 'tab'), closeIcon]),
          key: child.key || index
        }));
      }); // Add new tab handler

      if (!hideAdd) {
        tabBarExtraContent = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {}, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
          "type": "plus",
          "class": "".concat(prefixCls, "-new-tab"),
          "onClick": this.createNewTab
        }, []), tabBarExtraContent]);
      }
    }

    tabBarExtraContent = tabBarExtraContent ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-extra-content")
    }, [tabBarExtraContent]) : null;
    var renderTabBar = props_util_getComponentFromProp(instance, 'renderTabBar');
    var listeners = getListenersFromInstance(instance);
    var tabBarProps = Object.assign(Object.assign(Object.assign({}, this.$props), {
      prefixCls: prefixCls,
      tabBarExtraContent: tabBarExtraContent,
      renderTabBar: renderTabBar
    }), listeners);
    var contentCls = (_contentCls = {}, defineProperty_default()(_contentCls, "".concat(prefixCls, "-").concat(tabPosition, "-content"), true), defineProperty_default()(_contentCls, "".concat(prefixCls, "-card-content"), type.indexOf('card') >= 0), _contentCls);
    var tabsProps = Object.assign(Object.assign(Object.assign(Object.assign({}, getOptionProps(instance)), {
      prefixCls: prefixCls,
      tabBarPosition: tabPosition,
      // https://github.com/vueComponent/ant-design-vue/issues/2030
      // 如仅传递 tabBarProps 会导致，第二次执行 renderTabBar 时，丢失 on 属性，
      // 添加key之后，会在babel jsx 插件中做一次merge，最终TabBar接收的是一个新的对象，而不是 tabBarProps
      renderTabBar: function renderTabBar() {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(tab_bar, tabs_tabs_objectSpread({
          "key": "tabBar"
        }, tabBarProps), []);
      },
      renderTabContent: function renderTabContent() {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(tab_content, {
          "class": contentCls,
          "animated": tabPaneAnimated,
          "animatedWithMargin": true
        }, []);
      },
      children: childrenWithClose.length > 0 ? childrenWithClose : children,
      __propsSymbol__: Symbol()
    }), listeners), {
      "class": cls
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_tabs_src, tabs_tabs_objectSpread({}, tabsProps), []);
  }
}));
// CONCATENATED MODULE: ./src/components/tabs/index.ts





tabs_tabs.TabPane = Object.assign(Object.assign({}, tab_pane), {
  name: 'ATabPane',
  __ANT_TAB_PANE: true
});
tabs_tabs.TabContent = Object.assign(Object.assign({}, tab_content), {
  name: 'ATabContent'
});
/* istanbul ignore next */

tabs_tabs.install = function (Vue) {
  Vue.use(base);
  Vue.component(tabs_tabs.name, tabs_tabs);
  Vue.component(tabs_tabs.TabPane.name, tabs_tabs.TabPane);
  Vue.component(tabs_tabs.TabContent.name, tabs_tabs.TabContent);
};

/* harmony default export */ var components_tabs = (tabs_tabs);

// CONCATENATED MODULE: ./src/components/card/card.tsx


function card_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function card_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { card_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { card_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }









var TabPane = components_tabs.TabPane;
/* harmony default export */ var card = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ACard',
  props: {
    prefixCls: vue_types.string,
    title: vue_types.any,
    extra: vue_types.any,
    bordered: vue_types.bool.def(true),
    bodyStyle: vue_types.object,
    headStyle: vue_types.object,
    loading: vue_types.bool.def(false),
    hoverable: vue_types.bool.def(false),
    type: vue_types.string,
    size: vue_types.oneOf(['default', 'small']),
    actions: vue_types.any,
    tabList: vue_types.array,
    tabBarExtraContent: vue_types.any,
    activeTabKey: vue_types.string,
    defaultActiveTabKey: vue_types.string
  },
  data: function data() {
    return {
      widerPadding: false
    };
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var getAction = function getAction(actions) {
      var actionList = actions.map(function (action, index) {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
          "style": {
            width: "".concat(100 / actions.length, "%")
          },
          "key": "action-".concat(index)
        }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {}, [action])]);
      });
      return actionList;
    };

    var onTabChange = function onTabChange(key) {
      emit('tabChange', key);
    };

    var isContainGrid = function isContainGrid() {
      var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var containGrid;
      obj.forEach(function (element) {
        if (element && getSlotOptions(element).__ANT_CARD_GRID) {
          containGrid = true;
        }
      });
      return containGrid;
    };

    return {
      getAction: getAction,
      onTabChange: onTabChange,
      isContainGrid: isContainGrid,
      configProvider: config_provider_useConfigProvider()
    };
  },
  render: function render(ctx) {
    var _classString, _tabsProps;

    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var _ctx$$props = ctx.$props,
        customizePrefixCls = _ctx$$props.prefixCls,
        _ctx$$props$headStyle = _ctx$$props.headStyle,
        headStyle = _ctx$$props$headStyle === void 0 ? {} : _ctx$$props$headStyle,
        _ctx$$props$bodyStyle = _ctx$$props.bodyStyle,
        bodyStyle = _ctx$$props$bodyStyle === void 0 ? {} : _ctx$$props$bodyStyle,
        loading = _ctx$$props.loading,
        _ctx$$props$bordered = _ctx$$props.bordered,
        bordered = _ctx$$props$bordered === void 0 ? true : _ctx$$props$bordered,
        _ctx$$props$size = _ctx$$props.size,
        size = _ctx$$props$size === void 0 ? 'default' : _ctx$$props$size,
        type = _ctx$$props.type,
        tabList = _ctx$$props.tabList,
        hoverable = _ctx$$props.hoverable,
        activeTabKey = _ctx$$props.activeTabKey,
        defaultActiveTabKey = _ctx$$props.defaultActiveTabKey;
    var getPrefixCls = ctx.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('card', customizePrefixCls);
    var tabBarExtraContent = props_util_getComponentFromProp(instance, 'tabBarExtraContent');
    var classString = (_classString = {}, defineProperty_default()(_classString, "".concat(prefixCls), true), defineProperty_default()(_classString, "".concat(prefixCls, "-loading"), loading), defineProperty_default()(_classString, "".concat(prefixCls, "-bordered"), bordered), defineProperty_default()(_classString, "".concat(prefixCls, "-hoverable"), !!hoverable), defineProperty_default()(_classString, "".concat(prefixCls, "-contain-grid"), ctx.isContainGrid(this.$slots["default"]())), defineProperty_default()(_classString, "".concat(prefixCls, "-contain-tabs"), tabList && tabList.length), defineProperty_default()(_classString, "".concat(prefixCls, "-").concat(size), size !== 'default'), defineProperty_default()(_classString, "".concat(prefixCls, "-type-").concat(type), !!type), _classString);
    var loadingBlockStyle = bodyStyle.padding === 0 || bodyStyle.padding === '0px' ? {
      padding: 24
    } : undefined;
    var loadingBlock = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-loading-content"),
      "style": loadingBlockStyle
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(grid_row, {
      "gutter": 8
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(col, {
      "span": 22
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-loading-block")
    }, [])])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(grid_row, {
      "gutter": 8
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(col, {
      "span": 8
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-loading-block")
    }, [])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(col, {
      "span": 15
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-loading-block")
    }, [])])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(grid_row, {
      "gutter": 8
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(col, {
      "span": 6
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-loading-block")
    }, [])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(col, {
      "span": 18
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-loading-block")
    }, [])])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(grid_row, {
      "gutter": 8
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(col, {
      "span": 13
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-loading-block")
    }, [])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(col, {
      "span": 9
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-loading-block")
    }, [])])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(grid_row, {
      "gutter": 8
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(col, {
      "span": 4
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-loading-block")
    }, [])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(col, {
      "span": 3
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-loading-block")
    }, [])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(col, {
      "span": 16
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-loading-block")
    }, [])])])]);
    var hasActiveTabKey = activeTabKey !== undefined;
    var tabsProps = (_tabsProps = {
      size: 'large'
    }, defineProperty_default()(_tabsProps, hasActiveTabKey ? 'activeKey' : 'defaultActiveKey', hasActiveTabKey ? activeTabKey : defaultActiveTabKey), defineProperty_default()(_tabsProps, "tabBarExtraContent", tabBarExtraContent), defineProperty_default()(_tabsProps, "onChange", ctx.onTabChange), defineProperty_default()(_tabsProps, "class", "".concat(prefixCls, "-head-tabs")), _tabsProps);
    var head;
    var tabs = tabList && tabList.length ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_tabs, card_objectSpread({}, tabsProps), [tabList.map(function (item) {
      var temp = item.tab,
          _item$slots = item.slots,
          slots = _item$slots === void 0 ? {} : _item$slots;
      var name = slots.tab;
      var tab = temp !== undefined ? temp : ctx.$slots[name] ? ctx.$slots[name](item) : null;
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(TabPane, {
        "tab": tab,
        "key": item.key,
        "disabled": item.disabled
      }, []);
    })]) : null;
    var titleDom = props_util_getComponentFromProp(instance, 'title');
    var extraDom = props_util_getComponentFromProp(instance, 'extra');

    if (titleDom || extraDom || tabs) {
      head = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": "".concat(prefixCls, "-head"),
        "style": headStyle
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": "".concat(prefixCls, "-head-wrapper")
      }, [titleDom && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": "".concat(prefixCls, "-head-title")
      }, [titleDom]), extraDom && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": "".concat(prefixCls, "-extra")
      }, [extraDom])]), tabs]);
    }

    var children = ctx.$slots["default"]();
    var cover = props_util_getComponentFromProp(instance, 'cover');
    var coverDom = cover ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-cover")
    }, [cover]) : null;
    var body = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-body"),
      "style": bodyStyle
    }, [loading ? loadingBlock : children]);
    var actions = filterEmpty(ctx.$slots.actions);
    var actionDom = actions && actions.length ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("ul", {
      "class": "".concat(prefixCls, "-actions")
    }, [ctx.getAction(actions)]) : null;
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", card_objectSpread({
      "class": classString,
      "ref": "cardContainerRef"
    }, es(getListenersFromInstance(instance), ['tabChange', 'tab-change'])), [head, coverDom, children ? body : null, actionDom]);
  }
}));
// CONCATENATED MODULE: ./src/components/card/meta.tsx


function meta_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function meta_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { meta_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { meta_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }





/* harmony default export */ var meta = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ACardMeta',
  props: {
    prefixCls: vue_types.string,
    title: vue_types.any,
    description: vue_types.any
  },
  setup: function setup() {
    return {
      configProvider: config_provider_useConfigProvider()
    };
  },
  render: function render(ctx) {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var customizePrefixCls = ctx.$props.prefixCls;
    var getPrefixCls = ctx.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('card', customizePrefixCls);

    var classString = defineProperty_default()({}, "".concat(prefixCls, "-meta"), true);

    var avatar = props_util_getComponentFromProp(instance, 'avatar');
    var title = props_util_getComponentFromProp(instance, 'title');
    var description = props_util_getComponentFromProp(instance, 'description');
    var avatarDom = avatar ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-meta-avatar")
    }, [avatar]) : null;
    var titleDom = title ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-meta-title")
    }, [title]) : null;
    var descriptionDom = description ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-meta-description")
    }, [description]) : null;
    var MetaDetail = titleDom || descriptionDom ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-meta-detail")
    }, [titleDom, descriptionDom]) : null;
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", meta_objectSpread({}, getListenersFromInstance(instance), {
      "class": classString
    }), [avatarDom, MetaDetail]);
  }
}));
// CONCATENATED MODULE: ./src/components/card/grid.tsx


function grid_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function grid_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { grid_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { grid_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }





/* harmony default export */ var grid = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ACardGrid',
  __ANT_CARD_GRID: true,
  props: {
    prefixCls: vue_types.string,
    hoverable: vue_types.bool
  },
  setup: function setup() {
    return {
      configProvider: config_provider_useConfigProvider()
    };
  },
  render: function render(ctx) {
    var _classString;

    var _ctx$$props = ctx.$props,
        customizePrefixCls = _ctx$$props.prefixCls,
        _ctx$$props$hoverable = _ctx$$props.hoverable,
        hoverable = _ctx$$props$hoverable === void 0 ? true : _ctx$$props$hoverable;
    var getPrefixCls = ctx.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('card', customizePrefixCls);
    var classString = (_classString = {}, defineProperty_default()(_classString, "".concat(prefixCls, "-grid"), true), defineProperty_default()(_classString, "".concat(prefixCls, "-grid-hoverable"), hoverable), _classString);
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", grid_objectSpread({}, getListenersFromInstance(instance), {
      "class": classString
    }), [ctx.$slots["default"] && ctx.$slots["default"]()]);
  }
}));
// CONCATENATED MODULE: ./src/components/card/index.ts





card.Meta = meta;
card.Grid = grid;
/* istanbul ignore next */

card.install = function (Vue) {
  Vue.use(base);
  Vue.component(card.name, card);
  Vue.component(meta.name, meta);
  Vue.component(grid.name, grid);
};

/* harmony default export */ var components_card = (card);
// CONCATENATED MODULE: ./src/components/vc-dropdown/src/placements.ts

var src_placements_autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var src_placements_targetOffset = [0, 0];
var src_placements_placements = {
  topLeft: {
    points: ['bl', 'tl'],
    overflow: src_placements_autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: src_placements_targetOffset
  },
  topCenter: {
    points: ['bc', 'tc'],
    overflow: src_placements_autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: src_placements_targetOffset
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: src_placements_autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: src_placements_targetOffset
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: src_placements_autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: src_placements_targetOffset
  },
  bottomCenter: {
    points: ['tc', 'bc'],
    overflow: src_placements_autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: src_placements_targetOffset
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: src_placements_autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: src_placements_targetOffset
  }
};
/* harmony default export */ var src_placements = (src_placements_placements);
// CONCATENATED MODULE: ./src/components/vc-dropdown/src/dropdown.tsx


function dropdown_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function dropdown_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { dropdown_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { dropdown_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }











/* harmony default export */ var src_dropdown = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: {
    minOverlayWidthMatchTrigger: vue_types.bool,
    prefixCls: vue_types.string.def('rc-dropdown'),
    transitionName: vue_types.string,
    overlayClassName: vue_types.string.def(''),
    openClassName: vue_types.string,
    animation: vue_types.any,
    align: vue_types.object,
    overlayStyle: vue_types.object.def(function () {
      return {};
    }),
    placement: vue_types.string.def('bottomLeft'),
    overlay: vue_types.any,
    trigger: vue_types.array.def(['hover']),
    alignPoint: vue_types.bool,
    showAction: vue_types.array.def([]),
    hideAction: vue_types.array.def([]),
    getPopupContainer: vue_types.func,
    visible: vue_types.bool,
    defaultVisible: vue_types.bool.def(false),
    mouseEnterDelay: vue_types.number.def(0.15),
    mouseLeaveDelay: vue_types.number.def(0.1)
  },
  setup: function setup($props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;

    var _useLocalValue = value_useLocalValue($props.defaultVisible, 'visible'),
        sVisible = _useLocalValue.value,
        setVisible = _useLocalValue.setValue;

    var _useRefs = save_ref_useRefs(),
        getRef = _useRefs.getRef,
        saveRef = _useRefs.saveRef;

    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var childOriginEvents = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var overlayRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var onClick = function onClick(e) {
      // do no call onVisibleChange, if you need click to hide, use onClick and control visible
      if (contains(e.target, overlayRef.value.el)) {
        return;
      }

      setVisible(false);
      emit('overlayClick', e);

      if (childOriginEvents.value.click) {
        childOriginEvents.value.click(e);
      }
    };

    var onVisibleChange = function onVisibleChange(visible) {
      setVisible(visible);
      emit('visibleChange', visible);
    };

    var getMinOverlayWidthMatchTrigger = function getMinOverlayWidthMatchTrigger() {
      var minOverlayWidthMatchTrigger = $props.minOverlayWidthMatchTrigger,
          alignPoint = $props.alignPoint;

      if ('minOverlayWidthMatchTrigger' in $props) {
        return minOverlayWidthMatchTrigger;
      }

      return !alignPoint;
    };

    var getOverlayElement = function getOverlayElement() {
      var overlay = $props.overlay || slots.overlay();
      var overlayElement;

      if (typeof overlay === 'function') {
        overlayElement = overlay();
      } else {
        overlayElement = overlay;
      }

      return overlayElement;
    };

    var getMenuElement = function getMenuElement() {
      var prefixCls = $props.prefixCls;
      childOriginEvents.value = getListenersFromVNode(slots.overlay()[0]);
      var overlayElement = getOverlayElement();
      var extraOverlayProps = {
        prefixCls: "".concat(prefixCls, "-menu"),
        getPopupContainer: function getPopupContainer() {
          return getPopupDomNode();
        },
        onClick: onClick
      };

      if (typeof overlayElement.type === 'string') {
        delete extraOverlayProps.prefixCls;
      }

      return cloneElement(slots.overlay()[0], extraOverlayProps);
    };

    var getMenuElementOrLambda = function getMenuElementOrLambda() {
      var overlay = $props.overlay || slots.overlay();

      if (typeof overlay === 'function') {
        return getMenuElement;
      }

      return getMenuElement();
    };

    var getPopupDomNode = function getPopupDomNode() {
      return getRef('trigger').getPopupDomNode();
    };

    var getOpenClassName = function getOpenClassName() {
      var openClassName = $props.openClassName,
          prefixCls = $props.prefixCls;

      if (openClassName !== undefined) {
        return openClassName;
      }

      return "".concat(prefixCls, "-open");
    };

    var afterVisibleChange = function afterVisibleChange(visible) {
      if (visible && getMinOverlayWidthMatchTrigger()) {
        var overlayNode = getPopupDomNode();
        var rootNode = instance.vnode.el;

        if (rootNode && overlayNode && rootNode.offsetWidth > overlayNode.offsetWidth) {
          overlayNode.style.minWidth = "".concat(rootNode.offsetWidth, "px");

          if (getRef('trigger') && getRef('trigger')._component && getRef('trigger')._component.alignInstance) {
            getRef('trigger')._component.alignInstance.forceAlign();
          }
        }
      }
    };

    var renderChildren = function renderChildren() {
      var children = slots["default"] && slots["default"]()[0];
      return sVisible.value && children ? cloneElement(children, {
        "class": getOpenClassName()
      }) : children;
    };

    return {
      onClick: onClick,
      onVisibleChange: onVisibleChange,
      getMinOverlayWidthMatchTrigger: getMinOverlayWidthMatchTrigger,
      getOverlayElement: getOverlayElement,
      getMenuElement: getMenuElement,
      getMenuElementOrLambda: getMenuElementOrLambda,
      getPopupDomNode: getPopupDomNode,
      getOpenClassName: getOpenClassName,
      afterVisibleChange: afterVisibleChange,
      renderChildren: renderChildren,
      sVisible: sVisible,
      getRef: getRef,
      saveRef: saveRef,
      setOverlay: function setOverlay(el) {
        overlayRef.value = el;
      }
    };
  },
  render: function render() {
    var _a = this.$props,
        prefixCls = _a.prefixCls,
        transitionName = _a.transitionName,
        animation = _a.animation,
        align = _a.align,
        placement = _a.placement,
        getPopupContainer = _a.getPopupContainer,
        showAction = _a.showAction,
        hideAction = _a.hideAction,
        overlayClassName = _a.overlayClassName,
        overlayStyle = _a.overlayStyle,
        trigger = _a.trigger,
        otherProps = __rest(_a, ["prefixCls", "transitionName", "animation", "align", "placement", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "trigger"]);

    var triggerHideAction = hideAction;

    if (!triggerHideAction && trigger.indexOf('contextmenu') !== -1) {
      triggerHideAction = ['click'];
    }

    var triggerProps = Object.assign(Object.assign({}, otherProps), {
      prefixCls: prefixCls,
      popupClassName: overlayClassName,
      popupStyle: overlayStyle,
      builtinPlacements: src_placements,
      action: trigger,
      showAction: showAction,
      hideAction: triggerHideAction || [],
      popupPlacement: placement,
      popupAlign: align,
      popupTransitionName: transitionName,
      popupAnimation: animation,
      popupVisible: this.sVisible,
      afterPopupVisibleChange: this.afterVisibleChange,
      getPopupContainer: getPopupContainer,
      onPopupVisibleChange: this.onVisibleChange,
      ref: this.saveRef('trigger')
    });
    var popupContent = this.$slots.overlay && this.getMenuElement();
    this.setOverlay(popupContent);
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_trigger, dropdown_objectSpread({}, triggerProps), {
      "popup": [popupContent],
      "default": [this.renderChildren()]
    });
  }
}));
// CONCATENATED MODULE: ./src/components/vc-dropdown/src/index.ts

// base in 2.4.1

/* harmony default export */ var vc_dropdown_src = (src_dropdown);
// CONCATENATED MODULE: ./src/components/dropdown/get-dropdown-props.ts


/* harmony default export */ var get_dropdown_props = (function () {
  return {
    trigger: vue_types.array.def(['hover']),
    overlay: vue_types.any,
    visible: vue_types.bool,
    disabled: vue_types.bool,
    align: vue_types.object,
    getPopupContainer: vue_types.func,
    prefixCls: vue_types.string,
    transitionName: vue_types.string,
    placement: vue_types.oneOf(['topLeft', 'topCenter', 'topRight', 'bottomLeft', 'bottomCenter', 'bottomRight']),
    overlayClassName: vue_types.string,
    overlayStyle: vue_types.object,
    forceRender: vue_types.bool,
    mouseEnterDelay: vue_types.number,
    mouseLeaveDelay: vue_types.number,
    openClassName: vue_types.string,
    minOverlayWidthMatchTrigger: vue_types.bool
  };
});
// CONCATENATED MODULE: ./src/components/dropdown/dropdown-button.tsx


function dropdown_button_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function dropdown_button_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { dropdown_button_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { dropdown_button_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }












var ButtonTypesProps = buttonTypes();
var DropdownProps = get_dropdown_props();
var ButtonGroup = components_button.Group;
var DropdownButtonProps = Object.assign(Object.assign(Object.assign({}, ButtonGroupProps), DropdownProps), {
  type: vue_types.oneOf(['primary', 'ghost', 'dashed', 'danger', 'default']).def('default'),
  size: vue_types.oneOf(['small', 'large', 'default']).def('default'),
  htmlType: ButtonTypesProps.htmlType,
  href: vue_types.string,
  disabled: vue_types.bool,
  prefixCls: vue_types.string,
  placement: DropdownProps.placement.def('bottomRight'),
  icon: vue_types.any,
  title: vue_types.string
});

/* harmony default export */ var dropdown_button = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ADropdownButton',
  model: {
    prop: 'visible',
    event: 'visibleChange'
  },
  props: DropdownButtonProps,
  setup: function setup($props, _ref) {
    var emit = _ref.emit;

    var onClick = function onClick(e) {
      emit('click', e);
    };

    var onVisibleChange = function onVisibleChange(val) {
      emit('visibleChange', val);
    };

    return {
      onClick: onClick,
      onVisibleChange: onVisibleChange,
      configProvider: config_provider_useConfigProvider()
    };
  },
  render: function render() {
    var _a = this.$props,
        type = _a.type,
        disabled = _a.disabled,
        htmlType = _a.htmlType,
        customizePrefixCls = _a.prefixCls,
        trigger = _a.trigger,
        align = _a.align,
        visible = _a.visible,
        placement = _a.placement,
        getPopupContainer = _a.getPopupContainer,
        href = _a.href,
        title = _a.title,
        restProps = __rest(_a, ["type", "disabled", "htmlType", "prefixCls", "trigger", "align", "visible", "placement", "getPopupContainer", "href", "title"]);

    var icon = getComponentFromContext(this, 'icon') || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
      "type": "ellipsis"
    }, []);
    var getContextPopupContainer = this.configProvider.getPopupContainer;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('dropdown-button', customizePrefixCls);
    var dropdownProps = {
      align: align,
      disabled: disabled,
      trigger: disabled ? [] : trigger,
      placement: placement,
      getPopupContainer: getPopupContainer || getContextPopupContainer,
      onVisibleChange: this.onVisibleChange
    };

    if (this.visible === undefined) {
      dropdownProps.visible = visible;
    }

    var buttonGroupProps = Object.assign(Object.assign({}, restProps), {
      "class": prefixCls
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(ButtonGroup, dropdown_button_objectSpread({}, buttonGroupProps), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_button, {
      "type": type,
      "disabled": disabled,
      "onClick": this.onClick,
      "htmlType": htmlType,
      "href": href,
      "title": title
    }, [this.$slots["default"] && this.$slots["default"]()]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(dropdown_dropdown, dropdown_button_objectSpread({}, dropdownProps), {
      "overlay": [getComponentFromContext(this, 'overlay')],
      "default": [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_button, {
        "disabled": disabled,
        "type": type
      }, [icon])]
    })]);
  }
}));
// CONCATENATED MODULE: ./src/components/dropdown/dropdown.tsx



function dropdown_dropdown_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function dropdown_dropdown_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { dropdown_dropdown_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { dropdown_dropdown_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }










var dropdown_DropdownProps = get_dropdown_props();
var Dropdown = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ADropdown',
  props: Object.assign(Object.assign({}, dropdown_DropdownProps), {
    prefixCls: vue_types.string,
    mouseEnterDelay: vue_types.number.def(0.15),
    mouseLeaveDelay: vue_types.number.def(0.1),
    placement: dropdown_DropdownProps.placement.def('bottomLeft')
  }),
  setup: function setup($props) {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var getTransitionName = function getTransitionName() {
      var _$props$placement = $props.placement,
          placement = _$props$placement === void 0 ? '' : _$props$placement,
          transitionName = $props.transitionName;

      if (transitionName !== undefined) {
        return transitionName;
      }

      if (placement.indexOf('top') >= 0) {
        return 'slide-down';
      }

      return 'slide-up';
    };

    var handleOverlayNode = function handleOverlayNode(node, prefixCls) {
      if (!node) {
        return undefined;
      } // menu cannot be selectable in dropdown defaultly
      // menu should be focusable in dropdown defaultly


      var overlayProps = getPropsData(node);

      if (!(typeof_default()(node.type) === 'object' && node.type['name'] === 'AMenu')) {
        return cloneElement(node);
      }

      var _ref = overlayProps || {},
          _ref$selectable = _ref.selectable,
          selectable = _ref$selectable === void 0 ? false : _ref$selectable,
          _ref$focusable = _ref.focusable,
          focusable = _ref$focusable === void 0 ? true : _ref$focusable;

      var expandIcon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-menu-submenu-arrow")
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "right",
        "class": "".concat(prefixCls, "-menu-submenu-arrow-icon")
      }, [])]);
      return node && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["isVNode"])(node) ? cloneElement(node, {
        mode: 'vertical',
        selectable: selectable,
        focusable: focusable,
        expandIcon: expandIcon
      }) : node;
    };

    var renderOverlay = function renderOverlay(prefixCls) {
      var overlay = props_util_getComponentFromProp(instance, 'overlay');

      if (Array.isArray(overlay)) {
        return handleOverlayNode(overlay[0], prefixCls);
      } else {
        return overlay === null || overlay === void 0 ? void 0 : overlay.map(function (node) {
          return handleOverlayNode(node, prefixCls);
        });
      }
    };

    return {
      getTransitionName: getTransitionName,
      renderOverlay: renderOverlay,
      configProvider: config_provider_useConfigProvider()
    };
  },
  render: function render(ctx) {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var $slots = ctx.$slots;
    var props = this.$props;
    var customizePrefixCls = props.prefixCls,
        trigger = props.trigger,
        disabled = props.disabled,
        getPopupContainer = props.getPopupContainer;
    var getContextPopupContainer = this.configProvider.getPopupContainer;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('dropdown', customizePrefixCls);
    var dropdownTrigger = $slots["default"]({
      "class": "".concat(prefixCls, "-trigger"),
      disabled: disabled
    });
    var triggerActions = disabled ? [] : trigger;
    var alignPoint;

    if (triggerActions && triggerActions.indexOf('contextmenu') !== -1) {
      alignPoint = true;
    }

    var dropdownProps = Object.assign(Object.assign(Object.assign({
      alignPoint: alignPoint
    }, props), {
      prefixCls: prefixCls,
      getPopupContainer: getPopupContainer || getContextPopupContainer,
      transitionName: this.getTransitionName(),
      trigger: triggerActions
    }), getListenersFromInstance(instance));
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_dropdown_src, dropdown_dropdown_objectSpread({}, dropdownProps), {
      "overlay": [this.renderOverlay(prefixCls)],
      "default": [dropdownTrigger]
    });
  }
});
Dropdown.Button = dropdown_button;
/* harmony default export */ var dropdown_dropdown = (Dropdown);

// CONCATENATED MODULE: ./src/components/dropdown/index.ts






dropdown_dropdown.Button = dropdown_button;
/* istanbul ignore next */

dropdown_dropdown.install = function (Vue) {
  Vue.use(base);
  Vue.component(dropdown_dropdown.name, dropdown_dropdown);
  Vue.component(dropdown_button.name, dropdown_button);
};

/* harmony default export */ var components_dropdown = (dropdown_dropdown);
// CONCATENATED MODULE: ./src/components/breadcrumb/breadcrumb-item.tsx






/* harmony default export */ var breadcrumb_item = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ABreadcrumbItem',
  props: {
    prefixCls: vue_types.string,
    href: vue_types.string,
    separator: vue_types.any.def('/'),
    overlay: vue_types.any
  },
  setup: function setup($props, _ref) {
    var slots = _ref.slots;

    var renderBreadcrumbNode = function renderBreadcrumbNode(breadcrumbItem, prefixCls) {
      var overlay = getComponentFromContext({
        $props: $props,
        $slots: slots
      }, 'overlay');

      if (overlay) {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(dropdown_dropdown, {
          "overlay": overlay,
          "placement": "bottomCenter"
        }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
          "class": "".concat(prefixCls, "-overlay-link")
        }, [breadcrumbItem, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
          "type": "down"
        }, [])])]);
      }

      return breadcrumbItem;
    };

    return {
      renderBreadcrumbNode: renderBreadcrumbNode,
      configProvider: config_provider_useConfigProvider()
    };
  },
  render: function render() {
    var customizePrefixCls = this.prefixCls,
        $slots = this.$slots;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('breadcrumb', customizePrefixCls);
    var separator = getComponentFromContext(this, 'separator');
    var children = $slots["default"];
    var link;

    if (this.href !== undefined) {
      link = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
        "class": "".concat(prefixCls, "-link")
      }, [children]);
    } else {
      link = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-link")
      }, [children]);
    } // wrap to dropDown


    link = this.renderBreadcrumbNode(link, prefixCls);

    if (children) {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {}, [link, separator && separator !== '' && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-separator")
      }, [separator])]);
    }

    return null;
  }
}));
// CONCATENATED MODULE: ./src/components/breadcrumb/breadcrumb.tsx








var MenuItem = components_menu.Item;
var Route = vue_types.shape({
  path: vue_types.string,
  breadcrumbName: vue_types.string,
  children: vue_types.array
}).loose;
var BreadcrumbProps = {
  prefixCls: vue_types.string,
  routes: vue_types.arrayOf(Route),
  params: vue_types.any,
  separator: vue_types.any,
  itemRender: vue_types.func
};

function getBreadcrumbName(route, params) {
  if (!route.breadcrumbName) {
    return null;
  }

  var paramsKeys = Object.keys(params).join('|');
  var name = route.breadcrumbName.replace(new RegExp(":(".concat(paramsKeys, ")"), 'g'), function (replacement, key) {
    return params[key] || replacement;
  });
  return name;
}

/* harmony default export */ var breadcrumb = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ABreadcrumb',
  props: BreadcrumbProps,
  setup: function setup($props, _ref) {
    var emit = _ref.emit;

    var defaultItemRender = function defaultItemRender(_ref2) {
      var route = _ref2.route,
          params = _ref2.params,
          routes = _ref2.routes,
          paths = _ref2.paths;
      var isLastItem = routes.indexOf(route) === routes.length - 1;
      var name = getBreadcrumbName(route, params);
      return isLastItem ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {}, [name]) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
        "href": "#/".concat(paths.join('/'))
      }, [name]);
    };

    var getPath = function getPath(path, params) {
      var copyPath = path;
      copyPath = (copyPath || '').replace(/^\//, '');
      Object.keys(params).forEach(function (key) {
        copyPath = copyPath.replace(":".concat(key), params[key]);
      });
      return copyPath;
    };

    var addChildPath = function addChildPath(paths, childPath, params) {
      var originalPaths = toConsumableArray_default()(paths);

      var path = getPath(childPath, params);

      if (path) {
        originalPaths.push(path);
      }

      return originalPaths;
    };

    var genForRoutes = function genForRoutes(_ref3) {
      var _ref3$routes = _ref3.routes,
          routes = _ref3$routes === void 0 ? [] : _ref3$routes,
          _ref3$params = _ref3.params,
          params = _ref3$params === void 0 ? {} : _ref3$params,
          separator = _ref3.separator,
          _ref3$itemRender = _ref3.itemRender,
          itemRender = _ref3$itemRender === void 0 ? defaultItemRender : _ref3$itemRender;
      var paths = [];
      return routes.map(function (route) {
        var path = getPath(route.path, params);

        if (path) {
          paths.push(path);
        } // generated overlay by route.children


        var overlay = null;

        if (route.children && route.children.length) {
          overlay = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_menu, {}, [route.children.map(function (child) {
            return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(MenuItem, {
              "key": child.breadcrumbName || child.path
            }, [itemRender({
              route: child,
              params: params,
              routes: routes,
              paths: addChildPath(paths, child.path, params)
            })]);
          })]);
        }

        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(breadcrumb_item, {
          "overlay": overlay,
          "separator": separator,
          "key": route.breadcrumbName || path
        }, [itemRender({
          route: route,
          params: params,
          routes: routes,
          paths: paths
        })]);
      });
    };

    return {
      defaultItemRender: defaultItemRender,
      getPath: getPath,
      addChildPath: addChildPath,
      genForRoutes: genForRoutes,
      configProvider: config_provider_useConfigProvider()
    };
  },
  render: function render() {
    var crumbs;
    var customizePrefixCls = this.prefixCls,
        routes = this.routes,
        _this$params = this.params,
        params = _this$params === void 0 ? {} : _this$params,
        $slots = this.$slots;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('breadcrumb', customizePrefixCls);
    var children = filterEmpty($slots["default"]);
    var separator = getComponentFromContext(this, 'separator');
    var itemRender = this.itemRender || this.defaultItemRender;

    if (routes && routes.length > 0) {
      // generated by route
      crumbs = this.genForRoutes({
        routes: routes,
        params: params,
        separator: separator,
        itemRender: itemRender
      });
    } else if (children.length) {
      crumbs = children.map(function (element, index) {
        return cloneElement(element, {
          props: {
            separator: separator
          },
          key: index
        });
      });
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": prefixCls
    }, [crumbs]);
  }
}));
// CONCATENATED MODULE: ./src/components/breadcrumb/breadcrumb-separator.tsx



/* harmony default export */ var breadcrumb_separator = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ABreadcrumbSeparator',
  props: {
    prefixCls: vue_types.string
  },
  setup: function setup() {
    return {
      configProvider: config_provider_useConfigProvider()
    };
  },
  render: function render() {
    var customizePrefixCls = this.prefixCls,
        $slots = this.$slots;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('breadcrumb', customizePrefixCls);
    var children = $slots["default"] && $slots["default"]();
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-separator")
    }, [children || '/']);
  }
}));
// CONCATENATED MODULE: ./src/components/breadcrumb/index.ts





breadcrumb.Item = breadcrumb_item;
breadcrumb.Separator = breadcrumb_separator;
/* istanbul ignore next */

breadcrumb.install = function (Vue) {
  Vue.use(base);
  Vue.component(breadcrumb.name, breadcrumb);
  Vue.component(breadcrumb_item.name, breadcrumb_item);
  Vue.component(breadcrumb_separator.name, breadcrumb_separator);
};

/* harmony default export */ var components_breadcrumb = (breadcrumb);
// CONCATENATED MODULE: ./src/components/checkbox/checkbox.tsx


function checkbox_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function checkbox_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { checkbox_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { checkbox_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }












function checkbox_noop() {}

/* harmony default export */ var checkbox_checkbox = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ACheckbox',
  inheritAttrs: false,
  __ANT_CHECKBOX: true,
  props: {
    prefixCls: vue_types.string,
    defaultChecked: vue_types.bool,
    checked: vue_types.bool,
    disabled: vue_types.bool,
    isGroup: vue_types.bool,
    value: vue_types.any,
    name: vue_types.string,
    id: vue_types.string,
    indeterminate: vue_types.bool,
    type: vue_types.string.def('checkbox'),
    autoFocus: vue_types.bool
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    form_useForm().registerControl();
    var checkboxGroupContext = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('checkboxGroupContext');
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.value;
    }, function (value, prevValue) {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        if (checkboxGroupContext.registerValue && checkboxGroupContext.cancelValue) {
          checkboxGroupContext.cancelValue(prevValue);
          checkboxGroupContext.registerValue(value);
        }
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      if (checkboxGroupContext === null || checkboxGroupContext === void 0 ? void 0 : checkboxGroupContext.registerValue) {
        checkboxGroupContext.registerValue(props.value);
      }

      _util_warning(props.checked !== undefined || checkboxGroupContext || props.value === undefined, 'Checkbox', '`value` is not validate prop, do you mean `checked`?');
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      if (checkboxGroupContext === null || checkboxGroupContext === void 0 ? void 0 : checkboxGroupContext.cancelValue) {
        checkboxGroupContext.cancelValue(props.value);
      }
    });

    var handleChange = function handleChange(event) {
      var targetChecked = event.target.checked;
      emit('update:value', targetChecked);
      emit('change', event);
    };

    var configProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('configProvider') || ConfigConsumerProps;

    var _DataEntryFocus = data_entry_focus(),
        getEl = _DataEntryFocus.getEl,
        blur = _DataEntryFocus.blur,
        focus = _DataEntryFocus.focus,
        setEl = _DataEntryFocus.setEl;

    return {
      getEl: getEl,
      handleChange: handleChange,
      setEl: setEl,
      checkboxGroupContext: checkboxGroupContext,
      blur: blur,
      focus: focus,
      configProvider: configProvider
    };
  },
  render: function render(ctx) {
    var _this = this,
        _classNames;

    var componentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var props = getOptionProps(componentInstance);
    var children = this.$slots["default"] && this.$slots["default"]();
    var _componentInstance$at = componentInstance.attrs,
        _componentInstance$at2 = _componentInstance$at.mouseenter,
        mouseenter = _componentInstance$at2 === void 0 ? checkbox_noop : _componentInstance$at2,
        _componentInstance$at3 = _componentInstance$at.mouseleave,
        mouseleave = _componentInstance$at3 === void 0 ? checkbox_noop : _componentInstance$at3;

    var customizePrefixCls = props.prefixCls,
        indeterminate = props.indeterminate,
        restProps = __rest(props, ["prefixCls", "indeterminate"]);

    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('checkbox', customizePrefixCls);
    var checkboxProps = Object.assign(Object.assign(Object.assign({}, restProps), ctx.$attrs), {
      prefixCls: prefixCls
    });

    if (ctx.checkboxGroupContext) {
      checkboxProps.onChange = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this.$emit.apply(_this, ['change'].concat(args));

        ctx.checkboxGroupContext.toggleOption({
          label: children,
          value: props.value
        });
      };

      checkboxProps.name = ctx.checkboxGroupContext.name;
      checkboxProps.checked = ctx.checkboxGroupContext.sValue.indexOf(props.value) !== -1;
      checkboxProps.disabled = props.disabled || ctx.checkboxGroupContext.disabled;
      checkboxProps.indeterminate = indeterminate;
    } else {
      checkboxProps.onChange = this.handleChange;
    }

    var classString = classnames_default()((_classNames = {}, defineProperty_default()(_classNames, "".concat(prefixCls, "-wrapper"), true), defineProperty_default()(_classNames, "".concat(prefixCls, "-wrapper-checked"), checkboxProps.checked), defineProperty_default()(_classNames, "".concat(prefixCls, "-wrapper-disabled"), checkboxProps.disabled), _classNames));
    var checkboxClass = classnames_default()(defineProperty_default()({}, "".concat(prefixCls, "-indeterminate"), indeterminate));
    return (// @ts-ignore
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("label", {
        "class": classString,
        "onMouseenter": mouseenter,
        "onMouseleave": mouseleave
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_checkbox_src, checkbox_objectSpread({}, checkboxProps, {
        "class": checkboxClass,
        "ref": "vcCheckbox"
      }), []), children !== undefined && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {}, [children])])
    );
  }
}));
// CONCATENATED MODULE: ./src/components/checkbox/group.tsx






function checkbox_group_noop() {}

/* harmony default export */ var checkbox_group = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ACheckboxGroup',
  model: {
    prop: 'value'
  },
  props: {
    name: vue_types.string,
    prefixCls: vue_types.string,
    defaultValue: vue_types.array,
    value: vue_types.array,
    options: vue_types.array.def([]),
    disabled: vue_types.bool
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;
    var sValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.value || props.defaultValue || []);
    var registeredValues = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])([]);
    var configProvider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('configProvider') || ConfigConsumerProps;
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.value;
    }, function (val) {
      sValue.value = val || [];
    });

    var getOptions = function getOptions() {
      var options = props.options;
      return options.map(function (option) {
        if (typeof option === 'string') {
          return {
            label: option,
            value: option
          };
        }

        var label = option.label;

        if (label === undefined && slots.label) {
          label = slots.label(option);
        }

        return Object.assign(Object.assign({}, option), {
          label: label
        });
      });
    };

    var cancelValue = function cancelValue(value) {
      registeredValues.value = registeredValues.value.filter(function (val) {
        return val !== value;
      });
    };

    var registerValue = function registerValue(value) {
      registeredValues.value = [].concat(toConsumableArray_default()(registeredValues.value), [value]);
    };

    var toggleOption = function toggleOption(option) {
      var optionIndex = sValue.value.indexOf(option.value);

      var value = toConsumableArray_default()(sValue.value);

      if (optionIndex === -1) {
        value.push(option.value);
      } else {
        value.splice(optionIndex, 1);
      }

      if (props.value === undefined) {
        sValue.value = value;
      }

      var options = getOptions();
      var val = value.filter(function (val) {
        return registeredValues.value.indexOf(val) !== -1;
      }).sort(function (a, b) {
        var indexA = options.findIndex(function (opt) {
          return opt.value === a;
        });
        var indexB = options.findIndex(function (opt) {
          return opt.value === b;
        });
        return indexA - indexB;
      });
      emit('update:value', val);
      emit('change', val);
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])('checkboxGroupContext', {
      registerValue: registerValue,
      cancelValue: cancelValue,
      toggleOption: toggleOption,
      name: props.name,
      sValue: sValue,
      disabled: props.disabled
    });
    return {
      configProvider: configProvider,
      sValue: sValue,
      getOptions: getOptions,
      cancelValue: cancelValue,
      registerValue: registerValue,
      toggleOption: toggleOption
    };
  },
  render: function render() {
    var _this = this;

    var props = this.$props,
        $slots = this.$slots;
    var customizePrefixCls = props.prefixCls,
        options = props.options;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('checkbox', customizePrefixCls);
    var children = $slots["default"];
    var groupPrefixCls = "".concat(prefixCls, "-group");

    if (options && options.length > 0) {
      children = this.getOptions().map(function (option) {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(checkbox_checkbox, {
          "prefixCls": prefixCls,
          "key": option.value.toString(),
          "disabled": 'disabled' in option ? option.disabled : props.disabled,
          "indeterminate": option.indeterminate,
          "value": option.value,
          "checked": _this.sValue.indexOf(option.value) !== -1,
          "onChange": option.onChange || checkbox_group_noop,
          "class": "".concat(groupPrefixCls, "-item")
        }, [option.label]);
      });
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": groupPrefixCls
    }, [children]);
  }
}));
// CONCATENATED MODULE: ./src/components/checkbox/index.ts




checkbox_checkbox.Group = checkbox_group;
/* istanbul ignore next */

checkbox_checkbox.install = function (app) {
  app.use(base);
  app.component(checkbox_checkbox.name, checkbox_checkbox);
  app.component(checkbox_group.name, checkbox_group);
};

/* harmony default export */ var components_checkbox = (checkbox_checkbox);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/calendar/ok-button.tsx


function ok_button_noop() {}

/* harmony default export */ var ok_button = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  functional: true,
  name: 'OkButton',
  render: function render(createElement, context) {
    var props = context.props,
        _context$listeners = context.listeners,
        listeners = _context$listeners === void 0 ? {} : _context$listeners;
    var prefixCls = props.prefixCls,
        locale = props.locale,
        okDisabled = props.okDisabled;
    var _listeners$ok = listeners.ok,
        ok = _listeners$ok === void 0 ? ok_button_noop : _listeners$ok;
    var className = "".concat(prefixCls, "-ok-btn");

    if (okDisabled) {
      className += " ".concat(prefixCls, "-ok-btn-disabled");
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "class": className,
      "role": "button",
      "onClick": okDisabled ? ok_button_noop : ok
    }, [locale.ok]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-calendar/src/calendar/time-picker-button.tsx



function time_picker_button_noop() {}

/* harmony default export */ var time_picker_button = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  functional: true,
  name: 'TimePicker',
  render: function render(h, context) {
    var _className;

    var props = context.props,
        _context$listeners = context.listeners,
        listeners = _context$listeners === void 0 ? {} : _context$listeners;
    var prefixCls = props.prefixCls,
        locale = props.locale,
        showTimePicker = props.showTimePicker,
        timePickerDisabled = props.timePickerDisabled;
    var _listeners$closeTimeP = listeners.closeTimePicker,
        closeTimePicker = _listeners$closeTimeP === void 0 ? time_picker_button_noop : _listeners$closeTimeP,
        _listeners$openTimePi = listeners.openTimePicker,
        openTimePicker = _listeners$openTimePi === void 0 ? time_picker_button_noop : _listeners$openTimePi;
    var className = (_className = {}, defineProperty_default()(_className, "".concat(prefixCls, "-time-picker-btn"), true), defineProperty_default()(_className, "".concat(prefixCls, "-time-picker-btn-disabled"), timePickerDisabled), _className);
    var onClick = time_picker_button_noop;

    if (!timePickerDisabled) {
      onClick = showTimePicker ? closeTimePicker : openTimePicker;
    }

    return h("a", {
      "class": className,
      "role": "button",
      "onClick": onClick
    }, [showTimePicker ? locale.dateSelect : locale.timeSelect]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-calendar/src/calendar/today-button.tsx



function today_button_noop() {}

/* harmony default export */ var today_button = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  functional: true,
  name: 'TodayButton',
  render: function render(ctx) {
    var _this = this;

    var context = Object.assign(Object.assign({}, ctx), this.$attrs);
    var prefixCls = context.prefixCls,
        locale = context.locale,
        value = context.value,
        timePicker = context.timePicker,
        disabled = context.disabled,
        disabledDate = context.disabledDate,
        text = context.text;

    var today = function today() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this.$emit.apply(_this, ['today'].concat(args));
    };

    var localeNow = (!text && timePicker ? locale.now : text) || locale.today;
    var disabledToday = disabledDate && !util_isAllowedDate(getTodayTime(value), disabledDate);
    var isDisabled = disabledToday || disabled;
    var disabledTodayClass = isDisabled ? "".concat(prefixCls, "-today-btn-disabled") : '';
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "class": "".concat(prefixCls, "-today-btn ").concat(disabledTodayClass),
      "role": "button",
      "onClick": isDisabled ? today_button_noop : today,
      "title": getTodayTimeStr(value)
    }, [localeNow]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-calendar/src/calendar/calendar-footer.tsx


function calendar_footer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function calendar_footer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { calendar_footer_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { calendar_footer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }







var CalendarFooter = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'CalendarFooter',
  props: {
    prefixCls: vue_types.string,
    showDateInput: vue_types.bool,
    disabledTime: vue_types.any,
    timePicker: vue_types.any,
    selectedValue: vue_types.any,
    showOk: vue_types.bool,
    // onSelect: PropTypes.func,
    value: vue_types.object,
    renderFooter: vue_types.func,
    defaultValue: vue_types.object,
    locale: vue_types.object,
    showToday: vue_types.bool,
    disabledDate: vue_types.func,
    showTimePicker: vue_types.bool,
    okDisabled: vue_types.bool,
    mode: vue_types.string
  },
  methods: {
    onSelect: function onSelect(value) {
      var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
      instance.emit('select', value);
    }
  },
  render: function render(ctx) {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var props = getOptionProps(instance);
    var value = props.value,
        prefixCls = props.prefixCls,
        showOk = props.showOk,
        timePicker = props.timePicker,
        renderFooter = props.renderFooter,
        showToday = props.showToday,
        mode = props.mode;
    var footerEl = null;
    var extraFooter = renderFooter && renderFooter(mode);

    if (showToday || timePicker || extraFooter) {
      var _cls;

      var btnProps = Object.assign(Object.assign(Object.assign({}, props), {
        value: value
      }), getListenersFromInstance(instance));
      var nowEl = null;

      if (showToday) {
        nowEl = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(today_button, calendar_footer_objectSpread({
          "key": "todayButton"
        }, btnProps), []);
      }

      delete btnProps.value;
      var okBtn = null;

      if (showOk === true || showOk !== false && !!timePicker) {
        okBtn = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(ok_button, calendar_footer_objectSpread({
          "key": "okButton"
        }, btnProps), []);
      }

      var timePickerBtn = null;

      if (timePicker) {
        timePickerBtn = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(time_picker_button, calendar_footer_objectSpread({
          "key": "timePickerButton"
        }, btnProps), []);
      }

      var footerBtn;

      if (nowEl || timePickerBtn || okBtn || extraFooter) {
        footerBtn = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
          "class": "".concat(prefixCls, "-footer-btn")
        }, [extraFooter, nowEl, timePickerBtn, okBtn]);
      }

      var cls = (_cls = {}, defineProperty_default()(_cls, "".concat(prefixCls, "-footer"), true), defineProperty_default()(_cls, "".concat(prefixCls, "-footer-show-ok"), !!okBtn), _cls);
      footerEl = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": cls
      }, [footerBtn]);
    }

    return footerEl;
  }
});
/* harmony default export */ var calendar_footer = (CalendarFooter);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/decade/decade-panel.tsx



var decade_panel_ROW = 4;
var decade_panel_COL = 3;
/* harmony default export */ var decade_panel = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: {
    locale: vue_types.object,
    value: vue_types.object,
    defaultValue: vue_types.object,
    rootPrefixCls: vue_types.string,
    renderFooter: vue_types.func
  },
  setup: function setup($props, _ref) {
    var emit = _ref.emit;
    var sValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])($props.value || $props.defaultValue);

    var goYear = function goYear(direction) {
      var next = sValue.value.clone();
      next.add(direction, 'years');
      sValue.value = next;
    };

    var chooseDecade = function chooseDecade(year, event) {
      var next = sValue.value.clone();
      next.year(year);
      next.month(sValue.value.month());
      emit('select', next);
      event.preventDefault();
    };

    return {
      nextCentury: goYear.bind(null, 100),
      previousCentury: goYear.bind(null, -100),
      sValue: sValue,
      chooseDecade: chooseDecade
    };
  },
  render: function render() {
    var _this = this;

    var value = this.sValue;
    var _this$$props = this.$props,
        locale = _this$$props.locale,
        renderFooter = _this$$props.renderFooter;
    var currentYear = value.year();
    var startYear = parseInt((currentYear / 100).toString(), 10) * 100;
    var preYear = startYear - 10;
    var endYear = startYear + 99;
    var decades = [];
    var index = 0;
    var prefixCls = "".concat(this.rootPrefixCls, "-decade-panel");

    for (var rowIndex = 0; rowIndex < decade_panel_ROW; rowIndex++) {
      decades[rowIndex] = [];

      for (var colIndex = 0; colIndex < decade_panel_COL; colIndex++) {
        var startDecade = preYear + index * 10;
        var endDecade = preYear + index * 10 + 9;
        decades[rowIndex][colIndex] = {
          startDecade: startDecade,
          endDecade: endDecade
        };
        index++;
      }
    }

    var footer = renderFooter && renderFooter('decade');
    var decadesEls = decades.map(function (row, decadeIndex) {
      var tds = row.map(function (decadeData) {
        var _classNameMap;

        var dStartDecade = decadeData.startDecade;
        var dEndDecade = decadeData.endDecade;
        var isLast = dStartDecade < startYear;
        var isNext = dEndDecade > endYear;
        var classNameMap = (_classNameMap = {}, defineProperty_default()(_classNameMap, "".concat(prefixCls, "-cell"), 1), defineProperty_default()(_classNameMap, "".concat(prefixCls, "-selected-cell"), dStartDecade <= currentYear && currentYear <= dEndDecade), defineProperty_default()(_classNameMap, "".concat(prefixCls, "-last-century-cell"), isLast), defineProperty_default()(_classNameMap, "".concat(prefixCls, "-next-century-cell"), isNext), _classNameMap);
        var content = "".concat(dStartDecade, "-").concat(dEndDecade);
        var clickHandler;

        if (isLast) {
          clickHandler = _this.previousCentury;
        } else if (isNext) {
          clickHandler = _this.nextCentury;
        } else {
          clickHandler = _this.chooseDecade.bind(null, dStartDecade);
        }

        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("td", {
          "key": dStartDecade,
          "onClick": clickHandler,
          "role": "gridcell",
          "class": classNameMap
        }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
          "class": "".concat(prefixCls, "-decade")
        }, [content])]);
      });
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("tr", {
        "key": decadeIndex,
        "role": "row"
      }, [tds]);
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": prefixCls
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-header")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "class": "".concat(prefixCls, "-prev-century-btn"),
      "role": "button",
      "onClick": this.previousCentury,
      "title": locale.previousCentury
    }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-century")
    }, [startYear, "-", endYear]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "class": "".concat(prefixCls, "-next-century-btn"),
      "role": "button",
      "onClick": this.nextCentury,
      "title": locale.nextCentury
    }, [])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-body")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("table", {
      "class": "".concat(prefixCls, "-table"),
      "cellspacing": "0",
      "role": "grid"
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("tbody", {
      "class": "".concat(prefixCls, "-tbody")
    }, [decadesEls])])]), footer && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-footer")
    }, [footer])]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-calendar/src/month/month-panel.tsx






function month_panel_noop() {}

var MonthPanel = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'MonthPanel',
  props: {
    value: vue_types.any,
    defaultValue: vue_types.any,
    cellRender: vue_types.any,
    contentRender: vue_types.any,
    locale: vue_types.any,
    rootPrefixCls: vue_types.string,
    // onChange: PropTypes.func,
    disabledDate: vue_types.func,
    // onSelect: PropTypes.func,
    renderFooter: vue_types.func,
    changeYear: vue_types.func.def(month_panel_noop)
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var _useLocalValue = value_useLocalValue(props.defaultValue),
        sValue = _useLocalValue.value,
        setValue = _useLocalValue.setValue;

    var goYear = function goYear(direction) {
      props.changeYear(direction);
    };

    return {
      sValue: sValue,
      setValue: setValue,
      nextYear: function nextYear() {
        goYear(1);
      },
      previousYear: function previousYear() {
        goYear(-1);
      },
      setAndSelectValue: function setAndSelectValue(value) {
        setValue(value);
        emit('select', value);
      }
    };
  },
  methods: {},
  render: function render() {
    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var sValue = this.sValue,
        cellRender = this.cellRender,
        contentRender = this.contentRender,
        locale = this.locale,
        rootPrefixCls = this.rootPrefixCls,
        disabledDate = this.disabledDate,
        renderFooter = this.renderFooter;
    var year = sValue.year();
    var prefixCls = "".concat(rootPrefixCls, "-month-panel");
    var footer = renderFooter && renderFooter('month');
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": prefixCls
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {}, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-header")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "class": "".concat(prefixCls, "-prev-year-btn"),
      "role": "button",
      "onClick": this.previousYear,
      "title": locale.previousYear
    }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "class": "".concat(prefixCls, "-year-select"),
      "role": "button",
      "onClick": getListenersFromInstance(currentInstance).yearPanelShow || month_panel_noop,
      "title": locale.yearSelect
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-year-select-content")
    }, [year]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-year-select-arrow")
    }, ["x"])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "class": "".concat(prefixCls, "-next-year-btn"),
      "role": "button",
      "onClick": this.nextYear,
      "title": locale.nextYear
    }, [])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-body")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(month_table, {
      "disabledDate": disabledDate,
      "onSelect": this.setAndSelectValue,
      "locale": locale,
      "value": sValue,
      "cellRender": cellRender,
      "contentRender": contentRender,
      "prefixCls": prefixCls
    }, [])]), footer && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-footer")
    }, [footer])])]);
  }
});
/* harmony default export */ var month_panel = (MonthPanel);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/year/year-panel.tsx





var year_panel_ROW = 4;
var year_panel_COL = 3;

function year_panel_noop() {}

/* harmony default export */ var year_panel = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: {
    rootPrefixCls: vue_types.string,
    value: vue_types.object,
    defaultValue: vue_types.object,
    locale: vue_types.object,
    renderFooter: vue_types.func
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var _useLocalValue = value_useLocalValue(props.defaultValue),
        sValue = _useLocalValue.value,
        getValue = _useLocalValue.getValue,
        setValue = _useLocalValue.setValue;

    var goYear = function goYear(direction) {
      var value = getValue().clone();
      value.add(direction, 'year');
      setValue(value);
    };

    return {
      sValue: sValue,
      nextDecade: function nextDecade() {
        goYear(10);
      },
      previousDecade: function previousDecade() {
        goYear(-10);
      },
      chooseYear: function chooseYear(year) {
        var value = sValue.value.clone();
        value.year(year);
        value.month(sValue.value.month());
        sValue.value = value;
        emit('select', value);
      },
      goYear: goYear,
      years: function years() {
        var value = sValue.value;
        var currentYear = value.year();
        var startYear = parseInt((currentYear / 10).toString(), 10) * 10;
        var previousYear = startYear - 1;
        var years = [];
        var index = 0;

        for (var rowIndex = 0; rowIndex < year_panel_ROW; rowIndex++) {
          years[rowIndex] = [];

          for (var colIndex = 0; colIndex < year_panel_COL; colIndex++) {
            var year = previousYear + index;
            var content = String(year);
            years[rowIndex][colIndex] = {
              content: content,
              year: year,
              title: content
            };
            index++;
          }
        }

        return years;
      }
    };
  },
  render: function render(ctx) {
    var value = ctx.sValue,
        locale = ctx.locale,
        renderFooter = ctx.renderFooter;
    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var decadePanelShow = getListenersFromInstance(currentInstance).decadePanelShow || year_panel_noop;
    var years = ctx.years();
    var currentYear = value.year();
    var startYear = parseInt((currentYear / 10).toString(), 10) * 10;
    var endYear = startYear + 9;
    var prefixCls = "".concat(ctx.rootPrefixCls, "-year-panel");
    var yeasEls = years.map(function (row, index) {
      var tds = row.map(function (yearData) {
        var _classNameMap;

        var classNameMap = (_classNameMap = {}, defineProperty_default()(_classNameMap, "".concat(prefixCls, "-cell"), 1), defineProperty_default()(_classNameMap, "".concat(prefixCls, "-selected-cell"), yearData.year === currentYear), defineProperty_default()(_classNameMap, "".concat(prefixCls, "-last-decade-cell"), yearData.year < startYear), defineProperty_default()(_classNameMap, "".concat(prefixCls, "-next-decade-cell"), yearData.year > endYear), _classNameMap);
        var clickHandler;

        if (yearData.year < startYear) {
          clickHandler = ctx.previousDecade;
        } else if (yearData.year > endYear) {
          clickHandler = ctx.nextDecade;
        } else {
          clickHandler = function clickHandler() {
            ctx.chooseYear(yearData.year);
          };
        }

        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("td", {
          "role": "gridcell",
          "title": yearData.title,
          "key": yearData.content,
          "onClick": clickHandler,
          "class": classNameMap
        }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
          "class": "".concat(prefixCls, "-year")
        }, [yearData.content])]);
      });
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("tr", {
        "key": index,
        "role": "row"
      }, [tds]);
    });
    var footer = renderFooter && renderFooter('year');
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": prefixCls
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {}, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-header")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "class": "".concat(prefixCls, "-prev-decade-btn"),
      "role": "button",
      "onClick": ctx.previousDecade,
      "title": locale.previousDecade
    }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "class": "".concat(prefixCls, "-decade-select"),
      "role": "button",
      "onClick": decadePanelShow,
      "title": locale.decadeSelect
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-decade-select-content")
    }, [startYear, "-", endYear]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-decade-select-arrow")
    }, ["x"])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "class": "".concat(prefixCls, "-next-decade-btn"),
      "role": "button",
      "onClick": ctx.nextDecade,
      "title": locale.nextDecade
    }, [])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-body")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("table", {
      "class": "".concat(prefixCls, "-table"),
      "cellspacing": "0",
      "role": "grid"
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("tbody", {
      "class": "".concat(prefixCls, "-tbody")
    }, [yeasEls])])]), footer && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-footer")
    }, [footer])])]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-calendar/src/calendar/calendar-header.tsx







function calendar_header_noop() {}

function showIf(condition, el) {
  return condition ? el : null;
}

var calendar_header_CalendarHeader = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'CalendarHeader',
  props: {
    prefixCls: vue_types.string,
    value: vue_types.object,
    // onValueChange: PropTypes.func,
    showTimePicker: vue_types.bool,
    // onPanelChange: PropTypes.func,
    locale: vue_types.object,
    enablePrev: vue_types.any.def(1),
    enableNext: vue_types.any.def(1),
    disabledMonth: vue_types.func,
    mode: vue_types.any,
    monthCellRender: vue_types.func,
    monthCellContentRender: vue_types.func,
    renderFooter: vue_types.func
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        attrs = _ref.attrs;
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var yearPanelReferer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var goMonth = function goMonth(direction) {
      var next = props.value.clone();
      next.add(direction, 'months');
      emit('valueChange', next);
    };

    var goYear = function goYear(direction) {
      var next = props.value.clone();
      next.add(direction, 'years');
      emit('valueChange', next);
    };

    var previousMonth = function previousMonth() {
      goMonth(-1);
    };

    var nextMonth = function nextMonth() {
      goMonth(1);
    };

    var nextYear = function nextYear() {
      goYear(1);
    };

    var previousYear = function previousYear() {
      goYear(-1);
    };

    return {
      nextMonth: nextMonth,
      previousMonth: previousMonth,
      nextYear: nextYear,
      previousYear: previousYear,
      yearPanelReferer: yearPanelReferer,
      onMonthSelect: function onMonthSelect(value) {
        emit('panelChange', value, 'date');

        if (getListenersFromInstance(instance).onMonthSelect) {
          emit('monthSelect', value);
        } else {
          emit('valueChange', value);
        }
      },
      onYearSelect: function onYearSelect(value) {
        var referer = yearPanelReferer.value;
        yearPanelReferer.value = null;
        emit('panelChange', value, referer);
        emit('valueChange', value);
      },
      onDecadeSelect: function onDecadeSelect(value) {
        emit('panelChange', value, 'year');
        emit('valueChange', value);
      },
      showMonthPanel: function showMonthPanel() {
        // null means that users' interaction doesn't change value
        emit('panelChange', null, 'month');
      },
      showYearPanel: function showYearPanel(referer) {
        yearPanelReferer.value = referer;
        emit('panelChange', null, 'year');
      },
      showDecadePanel: function showDecadePanel() {
        emit('panelChange', null, 'decade');
      },
      goMonth: goMonth
    };
  },
  methods: {
    changeYear: function changeYear(direction) {
      if (direction > 0) {
        this.nextYear();
      } else {
        this.previousYear();
      }
    },
    monthYearElement: function monthYearElement(showTimePicker) {
      var _this = this;

      var props = this.$props;
      var prefixCls = props.prefixCls;
      var locale = props.locale;
      var value = props.value;
      var localeData = value.localeData();
      var monthBeforeYear = locale.monthBeforeYear;
      var selectClassName = "".concat(prefixCls, "-").concat(monthBeforeYear ? 'my-select' : 'ym-select');
      var timeClassName = showTimePicker ? " ".concat(prefixCls, "-time-status") : '';
      var year = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
        "class": "".concat(prefixCls, "-year-select").concat(timeClassName),
        "role": "button",
        "onClick": showTimePicker ? calendar_header_noop : function () {
          return _this.showYearPanel('date');
        },
        "title": showTimePicker ? null : locale.yearSelect
      }, [value.format(locale.yearFormat)]);
      var month = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
        "class": "".concat(prefixCls, "-month-select").concat(timeClassName),
        "role": "button",
        "onClick": showTimePicker ? calendar_header_noop : this.showMonthPanel,
        "title": showTimePicker ? null : locale.monthSelect
      }, [locale.monthFormat ? value.format(locale.monthFormat) : localeData.monthsShort(value)]);
      var day;

      if (showTimePicker) {
        day = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
          "class": "".concat(prefixCls, "-day-select").concat(timeClassName),
          "role": "button"
        }, [value.format(locale.dayFormat)]);
      }

      var my = [];

      if (monthBeforeYear) {
        my = [month, day, year];
      } else {
        my = [year, month, day];
      }

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": selectClassName
      }, [my]);
    }
  },
  render: function render(ctx) {
    var _this2 = this;

    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var props = getOptionProps(instance);
    var prefixCls = props.prefixCls,
        locale = props.locale,
        mode = props.mode,
        value = props.value,
        showTimePicker = props.showTimePicker,
        enableNext = props.enableNext,
        enablePrev = props.enablePrev,
        disabledMonth = props.disabledMonth,
        renderFooter = props.renderFooter;
    var panel = null;

    if (mode === 'month') {
      panel = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(month_panel, {
        "locale": locale,
        "value": value,
        "rootPrefixCls": prefixCls,
        "onSelect": ctx.onMonthSelect,
        "onYearPanelShow": function onYearPanelShow() {
          return _this2.showYearPanel('month');
        },
        "disabledDate": disabledMonth,
        "cellRender": props.monthCellRender,
        "contentRender": props.monthCellContentRender,
        "renderFooter": renderFooter,
        "changeYear": ctx.changeYear
      }, []);
    }

    if (mode === 'year') {
      panel = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(year_panel, {
        "locale": locale,
        "defaultValue": value,
        "rootPrefixCls": prefixCls,
        "onSelect": ctx.onYearSelect,
        "onDecadePanelShow": ctx.showDecadePanel,
        "renderFooter": renderFooter
      }, []);
    }

    if (mode === 'decade') {
      panel = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(decade_panel, {
        "locale": locale,
        "defaultValue": value,
        "rootPrefixCls": prefixCls,
        "onSelect": this.onDecadeSelect,
        "renderFooter": renderFooter
      }, []);
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-header")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "style": {
        position: 'relative'
      }
    }, [showIf(enablePrev && !showTimePicker, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "class": "".concat(prefixCls, "-prev-year-btn"),
      "role": "button",
      "onClick": this.previousYear,
      "title": locale.previousYear
    }, [])), showIf(enablePrev && !showTimePicker, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "class": "".concat(prefixCls, "-prev-month-btn"),
      "role": "button",
      "onClick": this.previousMonth,
      "title": locale.previousMonth
    }, [])), this.monthYearElement(showTimePicker), showIf(enableNext && !showTimePicker, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "class": "".concat(prefixCls, "-next-month-btn"),
      "onClick": this.nextMonth,
      "title": locale.nextMonth
    }, [])), showIf(enableNext && !showTimePicker, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "class": "".concat(prefixCls, "-next-year-btn"),
      "onClick": this.nextYear,
      "title": locale.nextYear
    }, []))]), panel]);
  }
});
/* harmony default export */ var calendar_calendar_header = (calendar_header_CalendarHeader);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/date/date-input.tsx






var cachedSelectionStart;
var cachedSelectionEnd;
var dateInputInstance;
var DateInput = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'DateInput',
  props: {
    prefixCls: vue_types.string,
    timePicker: vue_types.object,
    value: vue_types.object,
    disabledTime: vue_types.any,
    format: vue_types.oneOfType([vue_types.string, vue_types.arrayOf(vue_types.string)]),
    locale: vue_types.object,
    disabledDate: vue_types.func,
    // onChange: PropTypes.func,
    // onClear: PropTypes.func,
    placeholder: vue_types.string,
    // onSelect: PropTypes.func,
    selectedValue: vue_types.object,
    clearIcon: vue_types.any,
    inputMode: vue_types.string
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var selectedValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.selectedValue);
    var hasFocus = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var str = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(formatDate(selectedValue.value, props.format));
    var invalid = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);

    var updateState = function updateState() {
      if (dateInputInstance) {
        cachedSelectionStart = dateInputInstance.selectionStart;
        cachedSelectionEnd = dateInputInstance.selectionEnd;
      } // when popup show, click body will call this, bug!


      if (!hasFocus.value) {
        str.value = formatDate(selectedValue.value, props.format);
        invalid.value = false;
      }
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return selectedValue.value;
    }, function (val) {
      updateState();
    });

    var onInputChange = function onInputChange(e) {
      var _e$target = e.target,
          tmpStr = _e$target.value,
          composing = _e$target.composing;
      var oldStr = tmpStr.value;

      if (composing || oldStr === tmpStr) {
        return;
      }

      var disabledDate = props.disabledDate,
          format = props.format; // 没有内容，合法并直接退出

      if (!tmpStr) {
        emit('change', null);
        invalid.value = false;
        str.value = tmpStr;
        return;
      } // 不合法直接退出


      var parsed = moment_default()(tmpStr, format, true);

      if (!parsed.isValid()) {
        invalid.value = true;
        str.value = tmpStr;
        return;
      }

      var value = props.value.clone();
      value.year(parsed.year()).month(parsed.month()).date(parsed.date()).hour(parsed.hour()).minute(parsed.minute()).second(parsed.second());

      if (!value || disabledDate && disabledDate(value)) {
        invalid.value = true;
        str.value = tmpStr;
        return;
      }

      if (selectedValue.value !== value || selectedValue.value && value && !selectedValue.value.isSame(value)) {
        invalid.value = false;
        str.value = tmpStr;
        emit('change', value);
      }
    };

    var onFocus = function onFocus() {
      hasFocus.value = true;
    };

    var onClear = function onClear() {
      str.value = '';
      emit('clear', null);
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.format;
    }, function () {
      updateState();
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        if (dateInputInstance && hasFocus.value && !invalid.value && !(cachedSelectionStart === 0 && cachedSelectionEnd === 0)) {
          dateInputInstance.setSelectionRange(cachedSelectionStart, cachedSelectionEnd);
        }
      });
    });
    return {
      str: str,
      invalid: invalid,
      hasFocus: hasFocus,
      onClear: onClear,
      onFocus: onFocus,
      onInputChange: onInputChange,
      onBlur: function onBlur() {
        hasFocus.value = false;
        str.value = formatDate(props.value, props.format);
      },
      onKeyDown: function onKeyDown(event) {
        var keyCode = event.keyCode;
        var value = props.value,
            disabledDate = props.disabledDate;

        if (keyCode === keycode.ENTER) {
          var validateDate = !disabledDate || !disabledDate(value);

          if (validateDate) {
            emit('select', value.clone());
          }

          event.preventDefault();
        }
      },
      focus: function focus() {
        if (dateInputInstance) {
          dateInputInstance.focus();
        }
      },
      saveDateInput: function saveDateInput(dateInput) {
        dateInputInstance = dateInput;
      }
    };
  },
  getInstance: function getInstance() {
    return dateInputInstance;
  },
  render: function render(ctx) {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var invalid = ctx.invalid,
        str = ctx.str,
        locale = ctx.locale,
        prefixCls = ctx.prefixCls,
        placeholder = ctx.placeholder,
        disabled = ctx.disabled,
        showClear = ctx.showClear,
        inputMode = ctx.inputMode;
    var clearIcon = props_util_getComponentFromProp(instance, 'clearIcon');
    var invalidClass = invalid ? "".concat(prefixCls, "-input-invalid") : '';
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-input-wrap")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-date-input-wrap")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", {
      "ref": this.saveDateInput,
      "class": "".concat(prefixCls, "-input ").concat(invalidClass),
      "value": str,
      "disabled": disabled,
      "placeholder": placeholder,
      "onInput": ctx.onInputChange,
      "onKeydown": ctx.onKeyDown,
      "onFocus": ctx.onFocus,
      "onBlur": ctx.onBlur,
      "inputmode": inputMode
    }, [])]), showClear ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "role": "button",
      "title": locale.clear,
      "onClick": this.onClear
    }, [clearIcon || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-clear-btn")
    }, [])]) : null]);
  }
});
/* harmony default export */ var date_input = (DateInput);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/util/toTime.ts

function goStartMonth(time) {
  return time.clone().startOf('month');
}
function goEndMonth(time) {
  return time.clone().endOf('month');
}
function toTime_goTime(time, direction, unit) {
  return time.clone().add(direction, unit);
}
function includesTime() {
  var timeList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var time = arguments.length > 1 ? arguments[1] : undefined;
  var unit = arguments.length > 2 ? arguments[2] : undefined;
  return timeList.some(function (t) {
    return t.isSame(time, unit);
  });
}
// CONCATENATED MODULE: ./src/components/vc-calendar/src/calendar.tsx
















var calendar_getMomentObjectIfValid = function getMomentObjectIfValid(date) {
  if (moment_default.a.isMoment(date) && date.isValid()) {
    return date;
  }

  return false;
};

var calendar_Calendar = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'Calendar',
  props: {
    locale: vue_types.object.def(zh_CN),
    format: vue_types.oneOfType([vue_types.string, vue_types.arrayOf(vue_types.string)]),
    visible: vue_types.bool.def(true),
    prefixCls: vue_types.string.def('rc-calendar'),
    // prefixCls: PropTypes.string,
    defaultValue: vue_types.object,
    value: vue_types.object,
    selectedValue: vue_types.object,
    defaultSelectedValue: vue_types.object,
    mode: vue_types.oneOf(['time', 'date', 'month', 'year', 'decade']),
    // locale: PropTypes.object,
    showDateInput: vue_types.bool.def(true),
    showWeekNumber: vue_types.bool,
    showToday: vue_types.bool.def(true),
    showOk: vue_types.bool,
    // onSelect: PropTypes.func,
    // onOk: PropTypes.func,
    // onKeyDown: PropTypes.func,
    timePicker: vue_types.any,
    dateInputPlaceholder: vue_types.any,
    // onClear: PropTypes.func,
    // onChange: PropTypes.func,
    // onPanelChange: PropTypes.func,
    disabledDate: vue_types.func,
    disabledTime: vue_types.any,
    dateRender: vue_types.func,
    renderFooter: vue_types.func.def(function () {
      return null;
    }),
    renderSidebar: vue_types.func.def(function () {
      return null;
    }),
    clearIcon: vue_types.any,
    focusablePanel: vue_types.bool.def(true),
    inputMode: vue_types.string
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var sMode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.mode || 'date');
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.mode;
    }, function (mode) {
      sMode.value = mode;
    });

    var onBlur = function onBlur(event) {
      setTimeout(function () {
        var dateInput = date_input.getInstance();

        if (!rootInstance.value || rootInstance.value.contains(document.activeElement) || dateInput && dateInput.contains(document.activeElement)) {
          // focused element is still part of Calendar
          return;
        }

        emit('blur', event);
      }, 0);
    };

    var onKeyDown = function onKeyDown(event) {
      if (event.target.nodeName.toLowerCase() === 'input') {
        return undefined;
      }

      var keyCode = event.keyCode; // mac

      var ctrlKey = event.ctrlKey || event.metaKey;
      var disabledDate = props.disabledDate;

      switch (keyCode) {
        case keycode.DOWN:
          goTime(1, 'weeks');
          event.preventDefault();
          return 1;

        case keycode.UP:
          goTime(-1, 'weeks');
          event.preventDefault();
          return 1;

        case keycode.LEFT:
          if (ctrlKey) {
            goTime(-1, 'years');
          } else {
            goTime(-1, 'days');
          }

          event.preventDefault();
          return 1;

        case keycode.RIGHT:
          if (ctrlKey) {
            goTime(1, 'years');
          } else {
            goTime(1, 'days');
          }

          event.preventDefault();
          return 1;

        case keycode.HOME:
          setValue(goStartMonth(sValue.value));
          event.preventDefault();
          return 1;

        case keycode.END:
          setValue(goEndMonth(sValue.value));
          event.preventDefault();
          return 1;

        case keycode.PAGE_DOWN:
          goTime(1, 'month');
          event.preventDefault();
          return 1;

        case keycode.PAGE_UP:
          goTime(-1, 'month');
          event.preventDefault();
          return 1;

        case keycode.ENTER:
          if (!disabledDate || !disabledDate(sValue.value)) {
            onSelect(sValue.value, {
              source: 'keyboard'
            });
          }

          event.preventDefault();
          return 1;

        default:
          emit('keydown', event);
          return 1;
      }
    };

    var _useCalendarMixin = calendar_mixin_useCalendarMixin(props, emit, {
      onKeyDown: onKeyDown,
      onBlur: onBlur
    }),
        setValue = _useCalendarMixin.setValue,
        onSelect = _useCalendarMixin.onSelect,
        isAllowedDate = _useCalendarMixin.isAllowedDate,
        renderRoot = _useCalendarMixin.renderRoot,
        setSelectedValue = _useCalendarMixin.setSelectedValue,
        sSelectedValue = _useCalendarMixin.selectedValue,
        sValue = _useCalendarMixin.sValue;

    var goTime = function goTime(direction, unit) {
      setValue(toTime_goTime(sValue.value, direction, unit));
    };

    var onPanelChange = function onPanelChange(value, mode) {
      if (props.mode === undefined) {
        sMode.value = mode;
      }

      emit('panelChange', value || sValue.value, mode);
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        saveFocusElement(date_input.getInstance());
      });
    });

    var _useCommonMixin = common_mixin_useCommonMixin(props),
        rootInstance = _useCommonMixin.rootInstance,
        focus = _useCommonMixin.focus,
        focusElement = _useCommonMixin.focusElement,
        getFormat = _useCommonMixin.getFormat,
        saveFocusElement = _useCommonMixin.saveFocusElement,
        setRootInstance = _useCommonMixin.setRootInstance;

    return {
      rootInstance: rootInstance,
      focus: focus,
      focusElement: focusElement,
      getFormat: getFormat,
      saveFocusElement: saveFocusElement,
      setRootInstance: setRootInstance,
      sMode: sMode,
      sValue: sValue,
      selectedValue: sSelectedValue,
      setSelectedValue: setSelectedValue,
      setValue: setValue,
      renderRoot: renderRoot,
      isAllowedDate: isAllowedDate,
      onSelect: onSelect,
      onPanelChange: onPanelChange,
      onClear: function onClear() {
        onSelect(null);
        emit('clear');
      },
      onOk: function onOk() {
        if (isAllowedDate(sSelectedValue.value)) {
          emit('ok', sSelectedValue.value);
        }
      },
      onDateInputChange: function onDateInputChange(value) {
        onSelect(value, {
          source: 'dateInput'
        });
      },
      onDateInputSelect: function onDateInputSelect(value) {
        onSelect(value, {
          source: 'dateInputSelect'
        });
      },
      onDateTableSelect: function onDateTableSelect(value) {
        var timePicker = props.timePicker;

        if (!sSelectedValue.value && timePicker) {
          var timePickerProps = getOptionProps(timePicker);
          var timePickerDefaultValue = timePickerProps.defaultValue;

          if (timePickerDefaultValue) {
            syncTime(timePickerDefaultValue, value);
          }
        }

        onSelect(value);
      },
      onToday: function onToday() {
        var now = getTodayTime(sValue.value);
        onSelect(now, {
          source: 'todayButton'
        });
      },
      onBlur: onBlur,
      openTimePicker: function openTimePicker() {
        onPanelChange(null, 'time');
      },
      closeTimePicker: function closeTimePicker() {
        onPanelChange(null, 'date');
      },
      goTime: goTime
    };
  },
  render: function render(ctx) {
    var locale = ctx.locale,
        prefixCls = ctx.prefixCls,
        disabledDate = ctx.disabledDate,
        dateInputPlaceholder = ctx.dateInputPlaceholder,
        timePicker = ctx.timePicker,
        disabledTime = ctx.disabledTime,
        showDateInput = ctx.showDateInput,
        sValue = ctx.sValue,
        sSelectedValue = ctx.sSelectedValue,
        sMode = ctx.sMode,
        renderFooter = ctx.renderFooter,
        inputMode = ctx.inputMode,
        monthCellRender = ctx.monthCellRender,
        monthCellContentRender = ctx.monthCellContentRender;
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var clearIcon = props_util_getComponentFromProp(instance, 'clearIcon');
    var showTimePicker = sMode === 'time';
    var disabledTimeConfig = showTimePicker && disabledTime && timePicker ? getTimeConfig(sSelectedValue, disabledTime) : null;
    var timePickerEle = null;

    if (timePicker && showTimePicker) {
      var timePickerOriginProps = getOptionProps(timePicker);
      var timePickerProps = Object.assign(Object.assign(Object.assign({
        showHour: true,
        showSecond: true,
        showMinute: true
      }, timePickerOriginProps), disabledTimeConfig), {
        value: sSelectedValue,
        disabledTime: disabledTime,
        onChange: ctx.onDateInputChange
      });

      if (timePickerOriginProps.defaultValue !== undefined) {
        timePickerProps.defaultOpenValue = timePickerOriginProps.defaultValue;
      }

      timePickerEle = cloneElement(timePicker, timePickerProps);
    }

    var dateInputElement = showDateInput ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(date_input, {
      "format": ctx.getFormat(),
      "key": "date-input",
      "value": sValue,
      "locale": locale,
      "placeholder": dateInputPlaceholder,
      "showClear": true,
      "disabledTime": disabledTime,
      "disabledDate": disabledDate,
      "onClear": ctx.onClear,
      "prefixCls": prefixCls,
      "selectedValue": sSelectedValue,
      "onChange": ctx.onDateInputChange,
      "clearIcon": clearIcon,
      "onSelect": ctx.onDateInputSelect,
      "inputMode": inputMode
    }, []) : null;
    var children = [];

    if (ctx.renderSidebar) {
      children.push(ctx.renderSidebar());
    }

    children.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-panel"),
      "key": "panel"
    }, [dateInputElement, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "tabindex": ctx.focusablePanel ? 0 : undefined,
      "class": "".concat(prefixCls, "-date-panel")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(calendar_calendar_header, {
      "locale": locale,
      "mode": sMode,
      "value": sValue,
      "onValueChange": ctx.setValue,
      "onPanelChange": ctx.onPanelChange,
      "renderFooter": renderFooter,
      "showTimePicker": showTimePicker,
      "prefixCls": prefixCls,
      "monthCellRender": monthCellRender,
      "monthCellContentRender": monthCellContentRender
    }, []), timePicker && showTimePicker ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-time-picker")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-time-picker-panel")
    }, [timePickerEle])]) : null, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-body")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(date_table, {
      "locale": locale,
      "value": sValue,
      "selectedValue": sSelectedValue,
      "prefixCls": prefixCls,
      "dateRender": ctx.dateRender,
      "onSelect": ctx.onDateTableSelect,
      "disabledDate": disabledDate,
      "showWeekNumber": ctx.showWeekNumber
    }, [])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(calendar_footer, {
      "showOk": ctx.showOk,
      "mode": sMode,
      "renderFooter": ctx.renderFooter,
      "locale": locale,
      "prefixCls": prefixCls,
      "showToday": ctx.showToday,
      "disabledTime": disabledTime,
      "showTimePicker": showTimePicker,
      "showDateInput": ctx.showDateInput,
      "timePicker": timePicker,
      "selectedValue": sSelectedValue,
      "value": sValue,
      "disabledDate": disabledDate,
      "okDisabled": ctx.showOk !== false && (!sSelectedValue || !ctx.isAllowedDate(sSelectedValue)),
      "onOk": ctx.onOk,
      "onSelect": ctx.onSelect,
      "onToday": ctx.onToday,
      "onOpenTimePicker": ctx.openTimePicker,
      "onCloseTimePicker": ctx.closeTimePicker
    }, [])])]));
    return ctx.renderRoot({
      children: children,
      "class": ctx.showWeekNumber ? "".concat(prefixCls, "-week-number") : ''
    });
  }
});
/* harmony default export */ var src_calendar = (calendar_Calendar);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/index.ts


/* harmony default export */ var vc_calendar_src = (src_calendar);
// CONCATENATED MODULE: ./src/components/vc-calendar/index.ts

// based on rc-calendar 9.15.8

/* harmony default export */ var vc_calendar = (vc_calendar_src);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/month-calendar.tsx








/* harmony default export */ var month_calendar = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'MonthCalendar',
  props: {
    locale: vue_types.object.def(zh_CN),
    format: vue_types.string,
    visible: vue_types.bool.def(true),
    prefixCls: vue_types.string.def('rc-calendar'),
    monthCellRender: vue_types.func,
    value: vue_types.object,
    defaultValue: vue_types.object,
    selectedValue: vue_types.object,
    defaultSelectedValue: vue_types.object,
    disabledDate: vue_types.func,
    monthCellContentRender: vue_types.func,
    renderFooter: vue_types.func.def(function () {
      return null;
    }),
    renderSidebar: vue_types.func.def(function () {
      return null;
    })
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var onKeyDown = function onKeyDown(event) {
      var keyCode = event.keyCode;
      var ctrlKey = event.ctrlKey || event.metaKey;
      var stateValue = sValue.value;
      var disabledDate = props.disabledDate;
      var value = stateValue;

      switch (keyCode) {
        case keycode.DOWN:
          value = stateValue.clone();
          value.add(3, 'months');
          break;

        case keycode.UP:
          value = stateValue.clone();
          value.add(-3, 'months');
          break;

        case keycode.LEFT:
          value = stateValue.clone();

          if (ctrlKey) {
            value.add(-1, 'years');
          } else {
            value.add(-1, 'months');
          }

          break;

        case keycode.RIGHT:
          value = stateValue.clone();

          if (ctrlKey) {
            value.add(1, 'years');
          } else {
            value.add(1, 'months');
          }

          break;

        case keycode.ENTER:
          if (!disabledDate || !disabledDate(stateValue)) {
            onSelect(stateValue);
          }

          event.preventDefault();
          return 1;

        default:
          return undefined;
      }

      if (value !== stateValue) {
        setValue(value);
        event.preventDefault();
        return 1;
      }
    };

    var _useCalendarMixin = calendar_mixin_useCalendarMixin(props, emit, {
      onKeyDown: onKeyDown
    }),
        sValue = _useCalendarMixin.sValue,
        setSelectedValue = _useCalendarMixin.setSelectedValue,
        onSelect = _useCalendarMixin.onSelect,
        renderRoot = _useCalendarMixin.renderRoot,
        isAllowedDate = _useCalendarMixin.isAllowedDate,
        setValue = _useCalendarMixin.setValue,
        sSelectedValue = _useCalendarMixin.selectedValue;

    var mode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])('month');
    return {
      renderRoot: renderRoot,
      isAllowedDate: isAllowedDate,
      setSelectedValue: setSelectedValue,
      mode: mode,
      sValue: sValue,
      selectedValue: sSelectedValue,
      onSelect: onSelect,
      setValue: setValue,
      handlePanelChange: function handlePanelChange(_, smode) {
        if (smode !== 'date') {
          mode.value = smode;
        }
      }
    };
  },
  render: function render(ctx) {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var props = this.$props;
    var mode = ctx.mode,
        value = ctx.sValue;
    var prefixCls = props.prefixCls,
        locale = props.locale,
        disabledDate = props.disabledDate;
    var monthCellRender = props_util_getComponentFromProp(instance, 'monthCellRender');
    var monthCellContentRender = props_util_getComponentFromProp(instance, 'monthCellContentRender');
    var renderFooter = props_util_getComponentFromProp(instance, 'renderFooter');
    var children = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-month-calendar-content")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-month-header-wrap")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(calendar_calendar_header, {
      "prefixCls": prefixCls,
      "mode": mode,
      "value": value,
      "locale": locale,
      "disabledMonth": disabledDate,
      "monthCellRender": monthCellRender,
      "monthCellContentRender": monthCellContentRender,
      "onMonthSelect": ctx.onSelect,
      "onValueChange": ctx.setValue,
      "onPanelChange": ctx.handlePanelChange
    }, [])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(calendar_footer, {
      "prefixCls": prefixCls,
      "renderFooter": renderFooter
    }, [])]);
    return ctx.renderRoot({
      "class": "".concat(props.prefixCls, "-month-calendar"),
      children: children
    });
  }
}));
// EXTERNAL MODULE: ./node_modules/lodash/omit.js
var lodash_omit = __webpack_require__("3eea");
var omit_default = /*#__PURE__*/__webpack_require__.n(lodash_omit);

// EXTERNAL MODULE: ./node_modules/timers-browserify/main.js
var main = __webpack_require__("5118");

// CONCATENATED MODULE: ./src/components/_util/create-chained-function.ts


/**
 * Safe chained function
 *
 * Will only create a new function if needed,
 * otherwise will pass back existing functions or null.
 *
 * @returns {function|null}
 */
function createChainedFunction() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  var args = [].slice.call(fns, 0);

  if (args.length === 1) {
    return args[0];
  }

  return function chainedFunction() {
    for (var i = 0; i < args.length; i++) {
      if (args[i] && args[i].apply) {
        args[i].apply(this, arguments);
      }
    }
  };
}
// CONCATENATED MODULE: ./src/components/vc-calendar/src/picker/placements.ts

var picker_placements_autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var picker_placements_targetOffset = [0, 0];
var picker_placements_placements = {
  bottomLeft: {
    points: ['tl', 'tl'],
    overflow: picker_placements_autoAdjustOverflow,
    offset: [0, -3],
    targetOffset: picker_placements_targetOffset
  },
  bottomRight: {
    points: ['tr', 'tr'],
    overflow: picker_placements_autoAdjustOverflow,
    offset: [0, -3],
    targetOffset: picker_placements_targetOffset
  },
  topRight: {
    points: ['br', 'br'],
    overflow: picker_placements_autoAdjustOverflow,
    offset: [0, 3],
    targetOffset: picker_placements_targetOffset
  },
  topLeft: {
    points: ['bl', 'bl'],
    overflow: picker_placements_autoAdjustOverflow,
    offset: [0, 3],
    targetOffset: picker_placements_targetOffset
  }
};
/* harmony default export */ var picker_placements = (picker_placements_placements);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/picker.tsx











function picker_isMoment(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || value.findIndex(function (val) {
      return val === undefined || moment_default.a.isMoment(val);
    }) !== -1;
  } else {
    return value === undefined || moment_default.a.isMoment(value);
  }
}

var picker_MomentType = vue_types.custom(picker_isMoment);
var picker_Picker = {
  name: 'Picker',
  props: {
    animation: vue_types.oneOfType([vue_types.func, vue_types.string]),
    disabled: vue_types.bool,
    transitionName: vue_types.string,
    format: vue_types.oneOfType([vue_types.string, vue_types.array]),
    // onChange: PropTypes.func,
    // onOpenChange: PropTypes.func,
    children: vue_types.func,
    getCalendarContainer: vue_types.func,
    calendar: vue_types.any,
    open: vue_types.bool,
    defaultOpen: vue_types.bool.def(false),
    prefixCls: vue_types.string.def('rc-calendar-picker'),
    placement: vue_types.any.def('bottomLeft'),
    value: vue_types.oneOfType([picker_MomentType, vue_types.arrayOf(picker_MomentType)]),
    defaultValue: vue_types.oneOfType([picker_MomentType, vue_types.arrayOf(picker_MomentType)]),
    align: vue_types.object.def(function () {
      return {};
    }),
    dropdownClassName: vue_types.string,
    dateRender: vue_types.func
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var _useLocalValue = value_useLocalValue(props.defaultOpen, 'open'),
        getOpen = _useLocalValue.getValue,
        setOpen = _useLocalValue.setValue;

    var _useLocalValue2 = value_useLocalValue(props.defaultValue),
        getValue = _useLocalValue2.getValue,
        setValue = _useLocalValue2.setValue;

    var focus = function focus() {
      if (!getOpen() && rootRef.value) {
        rootRef.value.focus();
      }
    };

    var onCalendarClear = function onCalendarClear() {
      closeCalendar(focus);
    };

    var openCalendar = function openCalendar(callback) {
      setOpen(true, callback);
    };

    var closeCalendar = function closeCalendar(callback) {
      setOpen(false, callback);
    };

    var onCalendarSelect = function onCalendarSelect(value) {
      var cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      setValue(value);
      var calendarProps = getOptionProps(props.calendar);

      if (cause.source === 'keyboard' || cause.source === 'dateInputSelect' || !calendarProps.timePicker && cause.source !== 'dateInput' || cause.source === 'todayButton') {
        closeCalendar(focus);
      }

      emit('change', value);
    };

    var onCalendarBlur = function onCalendarBlur() {
      setOpen(false);
    };

    var onCalendarKeyDown = function onCalendarKeyDown(event) {
      if (event.keyCode === keycode.ESC) {
        event.stopPropagation();
        closeCalendar(focus);
      }
    };

    var calendarInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var focusCalendar = function focusCalendar() {
      if (getOpen() && calendarInstance.value && calendarInstance.value.componentInstance) {
        calendarInstance.value.componentInstance.focus();
      }
    };

    var onCalendarOk = function onCalendarOk() {
      closeCalendar(focus);
    };

    var preOpen = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.open);
    var focusTimeout = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      preOpen.value = getOpen();
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      if (!preOpen.value && getOpen()) {
        // setTimeout is for making sure saveCalendarRef happen before focusCalendar
        focusTimeout.value = Object(main["setTimeout"])(focusCalendar, 0);
      }

      preOpen.value = getOpen();
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      clearTimeout(focusTimeout.value);
    });
    var rootRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var setRootRef = function setRootRef(el) {
      rootRef.value = el;
    };

    return {
      setRootRef: setRootRef,
      getOpen: getOpen,
      setOpen: setOpen,
      getValue: getValue,
      setValue: setValue,
      onCalendarKeyDown: onCalendarKeyDown,
      onCalendarSelect: onCalendarSelect,
      setCalendarInstance: function setCalendarInstance(value) {
        calendarInstance.value = value;
      },
      onKeyDown: function onKeyDown(event) {
        if (!getOpen() && (event.key === KeyName.Down || event.key === KeyName.Enter)) {
          openCalendar();
          event.preventDefault();
        }
      },
      onCalendarOk: onCalendarOk,
      onCalendarClear: onCalendarClear,
      onCalendarBlur: onCalendarBlur,
      onVisibleChange: function onVisibleChange(open) {
        setOpen(open);
      },
      getCalendarElement: function getCalendarElement() {
        var calendarProps = props.calendar.props;
        var calendarEvents = getListenersFromVNode(props.calendar);
        var defaultValue = getValue();
        var extraProps = {
          ref: 'calendarInstance',
          defaultValue: defaultValue || calendarProps.defaultValue,
          selectedValue: getValue(),
          onKeydown: onCalendarKeyDown,
          onOk: createChainedFunction(calendarEvents.onOk, onCalendarOk),
          onSelect: createChainedFunction(calendarEvents.onSelect, onCalendarSelect),
          onClear: createChainedFunction(calendarEvents.onClear, onCalendarClear),
          onBlur: createChainedFunction(calendarEvents.onBlur, onCalendarBlur)
        };
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(props.calendar, extraProps);
      },
      getCalendarInstance: function getCalendarInstance() {
        return calendarInstance.value;
      },
      openCalendar: openCalendar,
      closeCalendar: closeCalendar,
      focusCalendar: focusCalendar
    };
  },
  render: function render(ctx) {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var style = getStyleFromInstance(instance);
    var prefixCls = ctx.prefixCls,
        placement = ctx.placement,
        getCalendarContainer = ctx.getCalendarContainer,
        align = ctx.align,
        animation = ctx.animation,
        disabled = ctx.disabled,
        dropdownClassName = ctx.dropdownClassName,
        transitionName = ctx.transitionName,
        getCalendarInstance = ctx.getCalendarInstance;
    var sOpen = ctx.getOpen();
    var children = this.$slots["default"];
    var childrenState = {
      value: ctx.getValue(),
      open: sOpen
    };

    if (sOpen || !getCalendarInstance()) {
      ctx.setCalendarInstance(ctx.getCalendarElement());
    }

    var action = disabled && !sOpen ? [] : ['click'];
    var displayElement = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(children(childrenState, ctx)[0], {
      onKeydown: this.onKeyDown,
      ref: ctx.setRootRef
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_trigger, {
      "popupAlign": align,
      "builtinPlacements": picker_placements,
      "popupPlacement": placement,
      "action": action,
      "destroyPopupOnHide": true,
      "getPopupContainer": getCalendarContainer,
      "popupStyle": style,
      "popupAnimation": animation,
      "popupTransitionName": transitionName,
      "popupVisible": sOpen,
      "onPopupVisibleChange": this.onVisibleChange,
      "prefixCls": prefixCls,
      "popupClassName": dropdownClassName
    }, {
      "popup": [ctx.getCalendarInstance()],
      "default": [displayElement]
    });
  }
};
/* harmony default export */ var picker = (picker_Picker);
// CONCATENATED MODULE: ./src/components/date-picker/create-picker.tsx


function create_picker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function create_picker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { create_picker_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { create_picker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }












 // export const PickerProps = {
//   value?: moment.Moment;
//   prefixCls: string;
// }

function create_picker_noop() {}

function createPicker(TheCalendar, propsDef) {
  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
    props: initDefaultProps(propsDef, {
      allowClear: true,
      showToday: true
    }),
    setup: function setup(props, _ref) {
      var emit = _ref.emit;

      var _useLocalValue = value_useLocalValue(props.value),
          getValue = _useLocalValue.getValue,
          setValue = _useLocalValue.setValue,
          afterValueSetAction = _useLocalValue.afterValueSetAction;

      var _useLocalValue2 = value_useLocalValue(props.open, 'open'),
          localOpen = _useLocalValue2.value,
          getOpen = _useLocalValue2.getValue,
          afterOpenSetAction = _useLocalValue2.afterValueSetAction,
          setOpen = _useLocalValue2.setValue;

      var showDate = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(getValue());
      afterValueSetAction(function (val) {
        showDate.value = val;
      });
      afterOpenSetAction(function (val) {
        if (!val && getValue() !== showDate.value) {
          showDate.value = getValue();
        }
      });

      if (getValue() && !interopDefault(moment).isMoment(getValue())) {
        throw new Error('The value/defaultValue of DatePicker or MonthPicker must be ' + 'a moment object');
      }

      var handleCalendarChange = function handleCalendarChange(value) {
        showDate.value = value;
      };

      var handleChange = function handleChange(value) {
        setValue(value, 'change');
        showDate.value = value; // this.$emit('change', value, formatDate(value, this.format));
      };

      var handleOpenChange = function handleOpenChange(open) {
        setOpen(open);
      };

      var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

      var renderFooter = function renderFooter() {
        var renderExtraFooter = props_util_getComponentFromProp(instance, 'renderExtraFooter');
        return renderExtraFooter ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
          "class": "".concat(props.prefixCls, "-footer-extra")
        }, [typeof renderExtraFooter === 'function' ? renderExtraFooter.apply(void 0, arguments) : renderExtraFooter]) : null;
      };

      var clearSelection = function clearSelection(e) {
        e.preventDefault();
        e.stopPropagation();
        handleChange(null);
      };

      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
        return localOpen.value;
      }, function (val, oldVal) {
        Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
          if (props.open === undefined && oldVal && !val) {
            focus();
          }
        });
      });
      var inputRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
      return {
        showDate: showDate,
        getValue: getValue,
        setValue: setValue,
        getOpen: getOpen,
        setOpen: setOpen,
        clearSelection: clearSelection,
        handleCalendarChange: handleCalendarChange,
        handleOpenChange: handleOpenChange,
        renderFooter: renderFooter,
        configProvider: config_provider_useConfigProvider(),
        onMouseEnter: function onMouseEnter(e) {
          emit('mouseenter', e);
        },
        onMouseLeave: function onMouseLeave(e) {
          emit('mouseleave', e);
        },
        setInputRef: function setInputRef(el) {
          inputRef.value = el;
        },
        focus: function focus() {
          inputRef.value.focus();
        },
        blur: function blur() {
          inputRef.value.blur();
        }
      };
    },
    render: function render(ctx) {
      var _classNames,
          _this = this;

      var props = this.$props;
      var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
      var value = ctx.getValue();
      var showDate = ctx.showDate;
      var open = ctx.getOpen();
      var suffixIcon = getComponentFromContext(this, 'suffixIcon');
      suffixIcon = Array.isArray(suffixIcon) ? suffixIcon[0] : suffixIcon;
      var listeners = getListenersFromInstance(instance);
      var _listeners$panelChang = listeners.panelChange,
          panelChange = _listeners$panelChang === void 0 ? create_picker_noop : _listeners$panelChang,
          _listeners$focus = listeners.focus,
          focus = _listeners$focus === void 0 ? create_picker_noop : _listeners$focus,
          _listeners$blur = listeners.blur,
          blur = _listeners$blur === void 0 ? create_picker_noop : _listeners$blur,
          _listeners$ok = listeners.ok,
          ok = _listeners$ok === void 0 ? create_picker_noop : _listeners$ok;
      var customizePrefixCls = ctx.prefixCls,
          locale = ctx.locale,
          localeCode = ctx.localeCode,
          inputReadOnly = ctx.inputReadOnly;
      var getPrefixCls = ctx.configProvider.getPrefixCls;
      var prefixCls = getPrefixCls('calendar', customizePrefixCls);
      var dateRender = props_util_getComponentFromProp(instance, 'dateRender');
      var monthCellContentRender = props_util_getComponentFromProp(instance, 'monthCellContentRender');
      var placeholder = 'placeholder' in props ? props.placeholder : locale.lang.placeholder;
      var disabledTime = props.showTime ? props.disabledTime : null;
      var calendarClassName = classnames_default()((_classNames = {}, defineProperty_default()(_classNames, "".concat(prefixCls, "-time"), props.showTime), defineProperty_default()(_classNames, "".concat(prefixCls, "-month"), month_calendar === TheCalendar), _classNames));

      if (value && localeCode) {
        value.locale(localeCode);
      }

      var pickerProps = {};
      var calendarProps = {};
      var pickerStyle = {};

      if (props.showTime) {
        // fix https://github.com/ant-design/ant-design/issues/1902
        calendarProps.onSelect = ctx.handleChange;
        pickerStyle.minWidth = '195px';
      } else {
        pickerProps.onChange = ctx.handleChange;
      }

      if ('mode' in props) {
        calendarProps.mode = props.mode;
      }

      var theCalendarProps = mergeProps(calendarProps, {
        disabledDate: props.disabledDate,
        disabledTime: disabledTime,
        locale: locale.lang,
        timePicker: props.timePicker,
        defaultValue: props.defaultPickerValue || interopDefault(moment)(),
        dateInputPlaceholder: placeholder,
        prefixCls: prefixCls,
        dateRender: dateRender,
        format: props.format,
        showToday: props.showToday,
        monthCellContentRender: monthCellContentRender,
        renderFooter: this.renderFooter,
        value: showDate,
        inputReadOnly: inputReadOnly,
        onOk: ok,
        onPanelChange: panelChange,
        onChange: ctx.handleCalendarChange,
        "class": calendarClassName
      });
      var calendar = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(TheCalendar, create_picker_objectSpread({}, theCalendarProps), []);
      var clearIcon = !props.disabled && props.allowClear && value ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "close-circle",
        "class": "".concat(prefixCls, "-picker-clear"),
        "onClick": this.clearSelection,
        "theme": "filled"
      }, []) : null;
      var inputIcon = suffixIcon && (isValidElement(suffixIcon) ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["cloneVNode"])(suffixIcon, {
        "class": "".concat(prefixCls, "-picker-icon")
      }) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-picker-icon")
      }, [suffixIcon])) || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "calendar",
        "class": "".concat(prefixCls, "-picker-icon")
      }, []);

      var input = function input(_ref2) {
        var inputValue = _ref2.value;
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {}, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", {
          "ref": "input",
          "disabled": props.disabled,
          "onFocus": focus,
          "onBlur": blur,
          "readonly": true,
          "value": formatDate(inputValue, _this.format),
          "placeholder": placeholder,
          "class": props.pickerInputClass,
          "tabindex": props.tabIndex,
          "name": _this.name
        }, []), clearIcon, inputIcon]);
      };

      var vcDatePickerProps = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, props), pickerProps), {
        calendar: calendar,
        value: value,
        prefixCls: "".concat(prefixCls, "-picker-container")
      }), omit_default()(listeners, 'change')), {
        onOpen: open,
        onOpenChange: this.handleOpenChange,
        style: props.popupStyle
      });
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": props.pickerClass,
        "style": pickerStyle,
        "tabindex": props.disabled ? -1 : 0,
        "onFocus": focus,
        "onBlur": blur,
        "onMouseenter": this.onMouseEnter,
        "onMouseleave": this.onMouseLeave
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(picker, create_picker_objectSpread({}, vcDatePickerProps), Object.assign(Object.assign({}, this.$slots), {
        "default": input
      }))]);
    }
  });
}
// CONCATENATED MODULE: ./src/components/vc-time-picker/select.tsx






function select_noop() {}

var select_scrollTo = function scrollTo(element, to, duration) {
  // jump to target if duration zero
  if (duration <= 0) {
    raf_default()(function () {
      element.scrollTop = to;
    });
    return;
  }

  var difference = to - element.scrollTop;
  var perTick = difference / duration * 10;
  raf_default()(function () {
    element.scrollTop += perTick;

    if (element.scrollTop === to) {
      return;
    }

    scrollTo(element, to, duration - 10);
  });
};

var vc_time_picker_select_Select = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: {
    prefixCls: vue_types.string,
    options: vue_types.array,
    selectedIndex: vue_types.number,
    type: vue_types.string // onSelect: PropTypes.func,
    // onMouseEnter: PropTypes.func,

  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var active = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var listRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var onSelect = function onSelect(value) {
      var type = props.type;
      emit('select', type, value);
    };

    var onEsc = function onEsc(e) {
      emit('esc', e);
    };

    var getOptions = function getOptions() {
      var options = props.options,
          selectedIndex = props.selectedIndex,
          prefixCls = props.prefixCls;
      return options.map(function (item, index) {
        var _classnames;

        var cls = classnames_default()((_classnames = {}, defineProperty_default()(_classnames, "".concat(prefixCls, "-select-option-selected"), selectedIndex === index), defineProperty_default()(_classnames, "".concat(prefixCls, "-select-option-disabled"), item.disabled), _classnames));
        var onClick = item.disabled ? select_noop : function () {
          onSelect(item.value);
        };

        var onKeyDown = function onKeyDown(e) {
          if (e.key === 'Enter') {
            onClick();
          } else if (e.key === 'Escape') {
            onEsc(e);
          }
        };

        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
          "role": "button",
          "onClick": onClick,
          "class": cls,
          "key": index,
          "tabindex": 0,
          "onKeydown": onKeyDown
        }, [item.value]);
      });
    };

    var handleMouseEnter = function handleMouseEnter(e) {
      active.value = true;
      emit('mouseenter', e);
    };

    var handleMouseLeave = function handleMouseLeave() {
      active.value = false;
    };

    var scrollToSelected = function scrollToSelected(duration) {
      // move to selected item
      var select = instance.vnode.el;
      var list = listRef.value;

      if (!list) {
        return;
      }

      var index = props.selectedIndex;

      if (index < 0) {
        index = 0;
      }

      var topOption = list.children[index];
      var to = topOption.offsetTop;
      select_scrollTo(select, to, duration);
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        // jump to selected option
        scrollToSelected(0);
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.selectedIndex;
    }, function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        // smooth scroll to selected option
        scrollToSelected(120);
      });
    });
    return {
      active: active,
      handleMouseLeave: handleMouseLeave,
      getOptions: getOptions,
      handleMouseEnter: handleMouseEnter,
      setList: function setList(el) {
        listRef.value = el;
      }
    };
  },
  render: function render(ctx) {
    var _cls;

    var prefixCls = this.prefixCls,
        options = this.options,
        active = this.active;

    if (options.length === 0) {
      return null;
    }

    var cls = (_cls = {}, defineProperty_default()(_cls, "".concat(prefixCls, "-select"), 1), defineProperty_default()(_cls, "".concat(prefixCls, "-select-active"), active), _cls);
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": cls,
      "onMouseenter": ctx.handleMouseEnter,
      "onMouseleave": ctx.handleMouseLeave
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("ul", {
      "ref": ctx.setList
    }, [ctx.getOptions()])]);
  }
});
/* harmony default export */ var vc_time_picker_select = (vc_time_picker_select_Select);
// CONCATENATED MODULE: ./src/components/vc-time-picker/combobox.tsx




var formatOption = function formatOption(option, disabledOptions) {
  var value = "".concat(option);

  if (option < 10) {
    value = "0".concat(option);
  }

  var disabled = false;

  if (disabledOptions && disabledOptions.indexOf(option) >= 0) {
    disabled = true;
  }

  return {
    value: value,
    disabled: disabled
  };
};

var Combobox = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'Combobox',
  props: {
    format: vue_types.string,
    defaultOpenValue: vue_types.object,
    prefixCls: vue_types.string,
    value: vue_types.object,
    // onChange: PropTypes.func,
    // onAmPmChange: PropTypes.func,
    showHour: vue_types.bool,
    showMinute: vue_types.bool,
    showSecond: vue_types.bool,
    hourOptions: vue_types.array,
    minuteOptions: vue_types.array,
    secondOptions: vue_types.array,
    disabledHours: vue_types.func,
    disabledMinutes: vue_types.func,
    disabledSeconds: vue_types.func,
    // onCurrentSelectPanelChange: PropTypes.func,
    use12Hours: vue_types.bool,
    isAM: vue_types.bool
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var onItemChange = function onItemChange(type, itemValue) {
      var defaultOpenValue = props.defaultOpenValue,
          use12Hours = props.use12Hours,
          propValue = props.value,
          isAM = props.isAM;
      var value = (propValue || defaultOpenValue).clone();

      if (type === 'hour') {
        if (use12Hours) {
          if (isAM) {
            value.hour(+itemValue % 12);
          } else {
            value.hour(+itemValue % 12 + 12);
          }
        } else {
          value.hour(+itemValue);
        }
      } else if (type === 'minute') {
        value.minute(+itemValue);
      } else if (type === 'ampm') {
        var ampm = itemValue.toUpperCase();

        if (use12Hours) {
          if (ampm === 'PM' && value.hour() < 12) {
            value.hour(value.hour() % 12 + 12);
          }

          if (ampm === 'AM') {
            if (value.hour() >= 12) {
              value.hour(value.hour() - 12);
            }
          }
        }

        emit('amPmChange', ampm);
      } else {
        value.second(+itemValue);
      }

      emit('change', value);
    };

    var onEnterSelectPanel = function onEnterSelectPanel(range) {
      emit('currentSelectPanelChange', range);
    };

    var onEsc = function onEsc(e) {
      emit('esc', e);
    };

    var getHourSelect = function getHourSelect(hour) {
      var prefixCls = props.prefixCls,
          hourOptions = props.hourOptions,
          disabledHours = props.disabledHours,
          showHour = props.showHour,
          use12Hours = props.use12Hours;

      if (!showHour) {
        return null;
      }

      var disabledOptions = disabledHours();
      var hourOptionsAdj;
      var hourAdj;

      if (use12Hours) {
        hourOptionsAdj = [12].concat(hourOptions.filter(function (h) {
          return h < 12 && h > 0;
        }));
        hourAdj = hour % 12 || 12;
      } else {
        hourOptionsAdj = hourOptions;
        hourAdj = hour;
      }

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_time_picker_select, {
        "prefixCls": prefixCls,
        "options": hourOptionsAdj.map(function (option) {
          return formatOption(option, disabledOptions);
        }),
        "selectedIndex": hourOptionsAdj.indexOf(hourAdj),
        "type": "hour",
        "onSelect": onItemChange,
        "onMouseenter": function onMouseenter() {
          return onEnterSelectPanel('hour');
        },
        "onEsc": onEsc
      }, []);
    };

    var getMinuteSelect = function getMinuteSelect(minute) {
      var prefixCls = props.prefixCls,
          minuteOptions = props.minuteOptions,
          disabledMinutes = props.disabledMinutes,
          defaultOpenValue = props.defaultOpenValue,
          showMinute = props.showMinute,
          propValue = props.value;

      if (!showMinute) {
        return null;
      }

      var value = propValue || defaultOpenValue;
      var disabledOptions = disabledMinutes(value.hour());
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_time_picker_select, {
        "prefixCls": prefixCls,
        "options": minuteOptions.map(function (option) {
          return formatOption(option, disabledOptions);
        }),
        "selectedIndex": minuteOptions.indexOf(minute),
        "type": "minute",
        "onSelect": onItemChange,
        "onMouseenter": function onMouseenter() {
          return onEnterSelectPanel('minute');
        },
        "onEsc": onEsc
      }, []);
    };

    var getSecondSelect = function getSecondSelect(second) {
      var prefixCls = props.prefixCls,
          secondOptions = props.secondOptions,
          disabledSeconds = props.disabledSeconds,
          showSecond = props.showSecond,
          defaultOpenValue = props.defaultOpenValue,
          propValue = props.value;

      if (!showSecond) {
        return null;
      }

      var value = propValue || defaultOpenValue;
      var disabledOptions = disabledSeconds(value.hour(), value.minute());
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_time_picker_select, {
        "prefixCls": prefixCls,
        "options": secondOptions.map(function (option) {
          return formatOption(option, disabledOptions);
        }),
        "selectedIndex": secondOptions.indexOf(second),
        "type": "second",
        "onSelect": onItemChange,
        "onMouseenter": function onMouseenter() {
          return onEnterSelectPanel('second');
        },
        "onEsc": onEsc
      }, []);
    };

    var getAMPMSelect = function getAMPMSelect() {
      var prefixCls = props.prefixCls,
          use12Hours = props.use12Hours,
          format = props.format,
          isAM = props.isAM;

      if (!use12Hours) {
        return null;
      }

      var AMPMOptions = ['am', 'pm'] // If format has A char, then we should uppercase AM/PM
      .map(function (c) {
        return format.match(/\sA/) ? c.toUpperCase() : c;
      }).map(function (c) {
        return {
          value: c
        };
      });
      var selected = isAM ? 0 : 1;
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_time_picker_select, {
        "prefixCls": prefixCls,
        "options": AMPMOptions,
        "selectedIndex": selected,
        "type": "ampm",
        "onSelect": onItemChange,
        "onMouseenter": function onMouseenter() {
          return onEnterSelectPanel('ampm');
        },
        "onEsc": onEsc
      }, []);
    };

    return {
      getHourSelect: getHourSelect,
      getMinuteSelect: getMinuteSelect,
      getSecondSelect: getSecondSelect,
      getAMPMSelect: getAMPMSelect
    };
  },
  render: function render(ctx) {
    var prefixCls = ctx.prefixCls,
        defaultOpenValue = ctx.defaultOpenValue,
        propValue = ctx.value;
    var value = propValue || defaultOpenValue;
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-combobox")
    }, [ctx.getHourSelect(value.hour()), ctx.getMinuteSelect(value.minute()), ctx.getSecondSelect(value.second()), ctx.getAMPMSelect()]);
  }
});
/* harmony default export */ var vc_time_picker_combobox = (Combobox);
// CONCATENATED MODULE: ./src/components/vc-time-picker/header.tsx


function header_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function header_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { header_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { header_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




var Header = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: {
    format: vue_types.string,
    prefixCls: vue_types.string,
    disabledDate: vue_types.func,
    placeholder: vue_types.string,
    clearText: vue_types.string,
    value: vue_types.object,
    inputReadOnly: vue_types.bool.def(false),
    hourOptions: vue_types.array,
    minuteOptions: vue_types.array,
    secondOptions: vue_types.array,
    disabledHours: vue_types.func,
    disabledMinutes: vue_types.func,
    disabledSeconds: vue_types.func,
    // onChange: PropTypes.func,
    // onClear: PropTypes.func,
    // onEsc: PropTypes.func,
    allowEmpty: vue_types.bool,
    defaultOpenValue: vue_types.object,
    currentSelectPanel: vue_types.string,
    focusOnOpen: vue_types.bool,
    // onKeyDown: PropTypes.func,
    clearIcon: vue_types.any
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var str = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.value && props.value.format(props.format) || '');
    var invalid = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var inputRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var setInput = function setInput(el) {
      inputRef.value = el;
    };

    var onInputChange = function onInputChange(e) {
      var _e$target = e.target,
          value = _e$target.value,
          composing = _e$target.composing;
      var oldStr = str.value;

      if (e.isComposing || composing || oldStr === value) {
        return;
      }

      str.value = value;
      var format = props.format,
          hourOptions = props.hourOptions,
          minuteOptions = props.minuteOptions,
          secondOptions = props.secondOptions,
          disabledHours = props.disabledHours,
          disabledMinutes = props.disabledMinutes,
          disabledSeconds = props.disabledSeconds,
          originalValue = props.value;

      if (str) {
        var _value = getProtoValue().clone();

        var parsed = moment_default()(str, format, true);

        if (!parsed.isValid()) {
          invalid.value = true;
          return;
        }

        _value.hour(parsed.hour()).minute(parsed.minute()).second(parsed.second()); // if time value not allowed, response warning.


        if (hourOptions.indexOf(_value.hour()) < 0 || minuteOptions.indexOf(_value.minute()) < 0 || secondOptions.indexOf(_value.second()) < 0) {
          invalid.value = true;
          return;
        } // if time value is disabled, response warning.


        var disabledHourOptions = disabledHours();
        var disabledMinuteOptions = disabledMinutes(_value.hour());
        var disabledSecondOptions = disabledSeconds(_value.hour(), _value.minute());

        if (disabledHourOptions && disabledHourOptions.indexOf(_value.hour()) >= 0 || disabledMinuteOptions && disabledMinuteOptions.indexOf(_value.minute()) >= 0 || disabledSecondOptions && disabledSecondOptions.indexOf(_value.second()) >= 0) {
          invalid.value = true;
          return;
        }

        if (originalValue) {
          if (originalValue.hour() !== _value.hour() || originalValue.minute() !== _value.minute() || originalValue.second() !== _value.second()) {
            // keep other fields for rc-calendar
            var changedValue = originalValue.clone();
            changedValue.hour(_value.hour());
            changedValue.minute(_value.minute());
            changedValue.second(_value.second());
            emit('change', changedValue);
          }
        } else if (originalValue !== _value) {
          emit('change', _value);
        }
      } else {
        emit('change', null);
      }

      invalid.value = false;
    };

    var getProtoValue = function getProtoValue() {
      return props.value || props.defaultOpenValue;
    };

    var onKeyDown = function onKeyDown(e) {
      if (e.key === 'Escape') {
        emit('esc');
      }

      emit('keydown', e);
    };

    var getInput = function getInput() {
      var prefixCls = props.prefixCls,
          placeholder = props.placeholder,
          inputReadOnly = props.inputReadOnly;
      var invalidClass = invalid.value ? "".concat(prefixCls, "-input-invalid") : '';
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", header_objectSpread({
        "class": "".concat(prefixCls, "-input ").concat(invalidClass),
        "ref": setInput,
        "onKeydown": onKeyDown,
        "value": str.value,
        "placeholder": placeholder,
        "onInput": onInputChange,
        "readonly": !!inputReadOnly
      }, {
        directives: [{
          name: 'ant-input'
        }]
      }), []);
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      if (props.focusOnOpen) {
        // Wait one frame for the panel to be positioned before focusing
        var requestAnimationFrame = window.requestAnimationFrame || window.setTimeout;
        requestAnimationFrame(function () {
          inputRef.value.focus();
          inputRef.value.select();
        });
      }
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.value;
    }, function (val) {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        str.value = val && val.format(props.format) || '';
        invalid.value = false;
      });
    });
    return {
      str: str,
      invalid: invalid,
      onInputChange: onInputChange,
      onKeyDown: onKeyDown,
      getInput: getInput
    };
  },
  render: function render(ctx) {
    var prefixCls = ctx.prefixCls;
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-input-wrap")
    }, [this.getInput()]);
  }
});
/* harmony default export */ var vc_time_picker_header = (Header);
// CONCATENATED MODULE: ./src/components/vc-time-picker/panel.tsx








function panel_noop() {}

function generateOptions(length, disabledOptions, hideDisabledOptions) {
  var step = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var arr = [];

  for (var value = 0; value < length; value += step) {
    if (!disabledOptions || disabledOptions.indexOf(value) < 0 || !hideDisabledOptions) {
      arr.push(value);
    }
  }

  return arr;
}

function toNearestValidTime(time, hourOptions, minuteOptions, secondOptions) {
  var hour = hourOptions.slice().sort(function (a, b) {
    return Math.abs(time.hour() - a) - Math.abs(time.hour() - b);
  })[0];
  var minute = minuteOptions.slice().sort(function (a, b) {
    return Math.abs(time.minute() - a) - Math.abs(time.minute() - b);
  })[0];
  var second = secondOptions.slice().sort(function (a, b) {
    return Math.abs(time.second() - a) - Math.abs(time.second() - b);
  })[0];
  return moment_default()("".concat(hour, ":").concat(minute, ":").concat(second), 'HH:mm:ss');
}

var Panel = {
  props: {
    clearText: vue_types.string,
    prefixCls: vue_types.string.def('rc-time-picker-panel'),
    defaultOpenValue: {
      type: Object,
      "default": function _default() {
        return moment_default()();
      }
    },
    value: vue_types.any,
    defaultValue: vue_types.any,
    placeholder: vue_types.string,
    format: vue_types.string,
    inputReadOnly: vue_types.bool.def(false),
    disabledHours: vue_types.func.def(panel_noop),
    disabledMinutes: vue_types.func.def(panel_noop),
    disabledSeconds: vue_types.func.def(panel_noop),
    hideDisabledOptions: vue_types.bool,
    // onChange: PropTypes.func,
    // onEsc: PropTypes.func,
    allowEmpty: vue_types.bool,
    showHour: vue_types.bool,
    showMinute: vue_types.bool,
    showSecond: vue_types.bool,
    // onClear: PropTypes.func,
    use12Hours: vue_types.bool.def(false),
    hourStep: vue_types.number,
    minuteStep: vue_types.number,
    secondStep: vue_types.number,
    addon: vue_types.func.def(panel_noop),
    focusOnOpen: vue_types.bool,
    // onKeydown: PropTypes.func,
    clearIcon: vue_types.any
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var _useLocalValue = value_useLocalValue(),
        sValue = _useLocalValue.value;

    var selectionRange = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])([]);
    var currentSelectPanel = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var isAM = function isAM() {
      var value = sValue.value || props.defaultOpenValue;
      return value.hour() >= 0 && value.hour() < 12;
    };

    return {
      isAM: isAM,
      selectionRange: selectionRange,
      sValue: sValue,
      onChange: function onChange(newValue) {
        sValue.value = newValue;
        emit('change', newValue);
      },
      onAmPmChange: function onAmPmChange(ampm) {
        emit('amPmChange', ampm);
      },
      onCurrentSelectPanelChange: function onCurrentSelectPanelChange(panel) {
        currentSelectPanel.value = panel;
      },
      close: function close() {
        emit('esc');
      },
      onEsc: function onEsc(e) {
        emit('esc', e);
      },
      disabledHours2: function disabledHours2() {
        var use12Hours = props.use12Hours,
            disabledHours = props.disabledHours;
        var disabledOptions = disabledHours();

        if (use12Hours && Array.isArray(disabledOptions)) {
          if (isAM()) {
            disabledOptions = disabledOptions.filter(function (h) {
              return h < 12;
            }).map(function (h) {
              return h === 0 ? 12 : h;
            });
          } else {
            disabledOptions = disabledOptions.map(function (h) {
              return h === 12 ? 12 : h - 12;
            });
          }
        }

        return disabledOptions;
      }
    };
  },
  render: function render(ctx) {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var prefixCls = ctx.prefixCls,
        placeholder = ctx.placeholder,
        disabledMinutes = ctx.disabledMinutes,
        addon = ctx.addon,
        disabledSeconds = ctx.disabledSeconds,
        hideDisabledOptions = ctx.hideDisabledOptions,
        showHour = ctx.showHour,
        showMinute = ctx.showMinute,
        showSecond = ctx.showSecond,
        format = ctx.format,
        defaultOpenValue = ctx.defaultOpenValue,
        clearText = ctx.clearText,
        use12Hours = ctx.use12Hours,
        focusOnOpen = ctx.focusOnOpen,
        hourStep = ctx.hourStep,
        minuteStep = ctx.minuteStep,
        secondStep = ctx.secondStep,
        inputReadOnly = ctx.inputReadOnly,
        sValue = ctx.sValue,
        currentSelectPanel = ctx.currentSelectPanel;
    var clearIcon = props_util_getComponentFromProp(currentSelectPanel, 'clearIcon');

    var _getListenersFromInst = getListenersFromInstance(instance),
        _getListenersFromInst2 = _getListenersFromInst.esc,
        esc = _getListenersFromInst2 === void 0 ? panel_noop : _getListenersFromInst2,
        _getListenersFromInst3 = _getListenersFromInst.keydown,
        keydown = _getListenersFromInst3 === void 0 ? panel_noop : _getListenersFromInst3;

    var disabledHourOptions = ctx.disabledHours2();
    var disabledMinuteOptions = disabledMinutes(sValue ? sValue.hour() : null);
    var disabledSecondOptions = disabledSeconds(sValue ? sValue.hour() : null, sValue ? sValue.minute() : null);
    var hourOptions = generateOptions(24, disabledHourOptions, hideDisabledOptions, hourStep);
    var minuteOptions = generateOptions(60, disabledMinuteOptions, hideDisabledOptions, minuteStep);
    var secondOptions = generateOptions(60, disabledSecondOptions, hideDisabledOptions, secondStep);
    var validDefaultOpenValue = toNearestValidTime(defaultOpenValue, hourOptions, minuteOptions, secondOptions);
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-inner")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_time_picker_header, {
      "clearText": clearText,
      "prefixCls": prefixCls,
      "defaultOpenValue": validDefaultOpenValue,
      "value": sValue,
      "currentSelectPanel": currentSelectPanel,
      "onEsc": esc,
      "format": format,
      "placeholder": placeholder,
      "hourOptions": hourOptions,
      "minuteOptions": minuteOptions,
      "secondOptions": secondOptions,
      "disabledHours": ctx.disabledHours2,
      "disabledMinutes": disabledMinutes,
      "disabledSeconds": disabledSeconds,
      "onChange": ctx.onChange,
      "focusOnOpen": focusOnOpen,
      "onKeydown": keydown,
      "inputReadOnly": inputReadOnly,
      "clearIcon": clearIcon
    }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_time_picker_combobox, {
      "prefixCls": prefixCls,
      "value": sValue,
      "defaultOpenValue": validDefaultOpenValue,
      "format": format,
      "onChange": ctx.onChange,
      "onAmPmChange": ctx.onAmPmChange,
      "showHour": showHour,
      "showMinute": showMinute,
      "showSecond": showSecond,
      "hourOptions": hourOptions,
      "minuteOptions": minuteOptions,
      "secondOptions": secondOptions,
      "disabledHours": ctx.disabledHours2,
      "disabledMinutes": disabledMinutes,
      "disabledSeconds": disabledSeconds,
      "onCurrentSelectPanelChange": ctx.onCurrentSelectPanelChange,
      "use12Hours": use12Hours,
      "onEsc": ctx.onEsc,
      "isAM": ctx.isAM()
    }, []), addon(this)]);
  }
};
/* harmony default export */ var vc_time_picker_panel = (Panel);
// CONCATENATED MODULE: ./src/components/vc-time-picker/placements.ts

var vc_time_picker_placements_autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var vc_time_picker_placements_targetOffset = [0, 0];
var vc_time_picker_placements_placements = {
  bottomLeft: {
    points: ['tl', 'tl'],
    overflow: vc_time_picker_placements_autoAdjustOverflow,
    offset: [0, -3],
    targetOffset: vc_time_picker_placements_targetOffset
  },
  bottomRight: {
    points: ['tr', 'tr'],
    overflow: vc_time_picker_placements_autoAdjustOverflow,
    offset: [0, -3],
    targetOffset: vc_time_picker_placements_targetOffset
  },
  topRight: {
    points: ['br', 'br'],
    overflow: vc_time_picker_placements_autoAdjustOverflow,
    offset: [0, 3],
    targetOffset: vc_time_picker_placements_targetOffset
  },
  topLeft: {
    points: ['bl', 'bl'],
    overflow: vc_time_picker_placements_autoAdjustOverflow,
    offset: [0, 3],
    targetOffset: vc_time_picker_placements_targetOffset
  }
};
/* harmony default export */ var vc_time_picker_placements = (vc_time_picker_placements_placements);
// CONCATENATED MODULE: ./src/components/vc-time-picker/time-picker.tsx













function time_picker_noop() {
  return function () {};
}

/* harmony default export */ var time_picker = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'VcTimePicker',
  props: initDefaultProps({
    prefixCls: vue_types.string,
    clearText: vue_types.string,
    value: vue_types.any,
    defaultOpenValue: {
      type: Object,
      "default": function _default() {
        return moment_default()();
      }
    },
    inputReadOnly: vue_types.bool,
    disabled: vue_types.bool,
    allowEmpty: vue_types.bool,
    defaultValue: vue_types.any,
    open: vue_types.bool,
    defaultOpen: vue_types.bool,
    align: vue_types.object,
    placement: vue_types.any,
    transitionName: vue_types.string,
    getPopupContainer: vue_types.func,
    placeholder: vue_types.string,
    format: vue_types.string,
    showHour: vue_types.bool,
    showMinute: vue_types.bool,
    showSecond: vue_types.bool,
    popupClassName: vue_types.string,
    popupStyle: vue_types.object,
    disabledHours: vue_types.func,
    disabledMinutes: vue_types.func,
    disabledSeconds: vue_types.func,
    hideDisabledOptions: vue_types.bool,
    // onChange: PropTypes.func,
    // onAmPmChange: PropTypes.func,
    // onOpen: PropTypes.func,
    // onClose: PropTypes.func,
    // onFocus: PropTypes.func,
    // onBlur: PropTypes.func,
    name: vue_types.string,
    autoComplete: vue_types.string,
    use12Hours: vue_types.bool,
    hourStep: vue_types.number,
    minuteStep: vue_types.number,
    secondStep: vue_types.number,
    focusOnOpen: vue_types.bool,
    // onKeyDown: PropTypes.func,
    autoFocus: vue_types.bool,
    id: vue_types.string,
    inputIcon: vue_types.any,
    clearIcon: vue_types.any,
    addon: vue_types.func
  }, {
    clearText: 'clear',
    prefixCls: 'rc-time-picker',
    defaultOpen: false,
    inputReadOnly: false,
    popupClassName: '',
    popupStyle: {},
    align: {},
    allowEmpty: true,
    showHour: true,
    showMinute: true,
    showSecond: true,
    disabledHours: time_picker_noop,
    disabledMinutes: time_picker_noop,
    disabledSeconds: time_picker_noop,
    hideDisabledOptions: false,
    placement: 'bottomLeft',
    use12Hours: false,
    focusOnOpen: false
  }),
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var _useLocalValue = value_useLocalValue(props.defaultValue),
        sValue = _useLocalValue.value,
        setLocalValue = _useLocalValue.setValue;

    var _useLocalValue2 = value_useLocalValue(props.defaultOpen, 'open'),
        sOpen = _useLocalValue2.value,
        setLocalOpen = _useLocalValue2.setValue;

    var panelRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var pickerRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var setPanel = function setPanel(el) {
      panelRef.value = el;
    };

    var onEsc = function onEsc() {
      setOpen(false);
      focus();
    };

    var setPicker = function setPicker(el) {
      pickerRef.value = el;
    };

    var focus = function focus() {
      pickerRef.value.focus();
    };

    var setOpen = function setOpen(open) {
      if (sOpen.value !== open) {
        setLocalOpen(open);

        if (open) {
          emit('open', {
            open: open
          });
        } else {
          emit('close', {
            open: open
          });
        }
      }
    };

    var setValue = function setValue(value) {
      setLocalValue(value);
      emit('change', value);
    };

    var onClear = function onClear(event) {
      event.stopPropagation();
      setValue(null);
      setOpen(false);
    };

    var onPanelChange = function onPanelChange(value) {
      setValue(value);
    };

    var renderClearButton = function renderClearButton() {
      var prefixCls = props.prefixCls,
          allowEmpty = props.allowEmpty,
          clearText = props.clearText,
          disabled = props.disabled;

      if (!allowEmpty || !sValue.value || disabled) {
        return null;
      }

      var clearIcon = props_util_getComponentFromProp(instance, 'clearIcon');

      if (isValidElement(clearIcon)) {
        var _ref2 = getListenersFromVNode(clearIcon) || {},
            _onClick = _ref2.onClick;

        return cloneElement(clearIcon, {
          onClick: function onClick() {
            if (_onClick) {
              _onClick.apply(void 0, arguments);
            }

            onClear(arguments.length <= 0 ? undefined : arguments[0]);
          }
        });
      }

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
        "role": "button",
        "class": "".concat(prefixCls, "-clear"),
        "title": clearText,
        "onClick": onClear,
        "tabindex": 0
      }, [clearIcon || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("i", {
        "class": "".concat(prefixCls, "-clear-icon")
      }, [])]);
    };

    var getFormat = function getFormat() {
      var format = props.format,
          showHour = props.showHour,
          showMinute = props.showMinute,
          showSecond = props.showSecond,
          use12Hours = props.use12Hours;

      if (format) {
        return format;
      }

      if (use12Hours) {
        var fmtString = [showHour ? 'h' : '', showMinute ? 'mm' : '', showSecond ? 'ss' : ''].filter(function (item) {
          return !!item;
        }).join(':');
        return fmtString.concat(' a');
      }

      return [showHour ? 'HH' : '', showMinute ? 'mm' : '', showSecond ? 'ss' : ''].filter(function (item) {
        return !!item;
      }).join(':');
    };

    var getPanelElement = function getPanelElement() {
      var prefixCls = props.prefixCls,
          placeholder = props.placeholder,
          disabledHours = props.disabledHours,
          addon = props.addon,
          disabledMinutes = props.disabledMinutes,
          disabledSeconds = props.disabledSeconds,
          hideDisabledOptions = props.hideDisabledOptions,
          inputReadOnly = props.inputReadOnly,
          showHour = props.showHour,
          showMinute = props.showMinute,
          showSecond = props.showSecond,
          defaultOpenValue = props.defaultOpenValue,
          clearText = props.clearText,
          use12Hours = props.use12Hours,
          focusOnOpen = props.focusOnOpen,
          hourStep = props.hourStep,
          minuteStep = props.minuteStep,
          secondStep = props.secondStep;
      var clearIcon = props_util_getComponentFromProp(instance, 'clearIcon');
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_time_picker_panel, {
        "clearText": clearText,
        "prefixCls": "".concat(prefixCls, "-panel"),
        "ref": setPanel,
        "value": sValue,
        "inputReadOnly": inputReadOnly,
        "onChange": onPanelChange,
        "onAmPmChange": onAmPmChange,
        "defaultOpenValue": defaultOpenValue,
        "showHour": showHour,
        "showMinute": showMinute,
        "showSecond": showSecond,
        "onEsc": onEsc,
        "format": getFormat(),
        "placeholder": placeholder,
        "disabledHours": disabledHours,
        "disabledMinutes": disabledMinutes,
        "disabledSeconds": disabledSeconds,
        "hideDisabledOptions": hideDisabledOptions,
        "use12Hours": use12Hours,
        "hourStep": hourStep,
        "minuteStep": minuteStep,
        "secondStep": secondStep,
        "focusOnOpen": focusOnOpen,
        "onKeydown": onKeyDown2,
        "clearIcon": clearIcon,
        "addon": addon
      }, []);
    };

    var onFocus = function onFocus(e) {
      emit('focus', e);
    };

    var onAmPmChange = function onAmPmChange(ampm) {
      emit('amPmChange', ampm);
    };

    var onBlur = function onBlur(e) {
      emit('blur', e);
    };

    var onKeyDown = function onKeyDown(e) {
      if (e.key === KeyName.Down) {
        setOpen(true);
      }
    };

    var getPopupClassName = function getPopupClassName() {
      var showHour = props.showHour,
          showMinute = props.showMinute,
          showSecond = props.showSecond,
          use12Hours = props.use12Hours,
          prefixCls = props.prefixCls,
          popupClassName = props.popupClassName;
      var selectColumnCount = 0;

      if (showHour) {
        selectColumnCount += 1;
      }

      if (showMinute) {
        selectColumnCount += 1;
      }

      if (showSecond) {
        selectColumnCount += 1;
      }

      if (use12Hours) {
        selectColumnCount += 1;
      } // Keep it for old compatibility


      return classnames_default()(popupClassName, defineProperty_default()({}, "".concat(prefixCls, "-panel-narrow"), (!showHour || !showMinute || !showSecond) && !use12Hours), "".concat(prefixCls, "-panel-column-").concat(selectColumnCount));
    };

    var onKeyDown2 = function onKeyDown2(e) {
      emit('keydown', e);
    };

    var blur = function blur() {
      pickerRef.value.blur();
    };

    var onVisibleChange = function onVisibleChange(open) {
      setOpen(open);
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        if (props.autoFocus) {
          focus();
        }
      });
    });
    return {
      sValue: sValue,
      onFocus: onFocus,
      blur: blur,
      focus: focus,
      onBlur: onBlur,
      sOpen: sOpen,
      onVisibleChange: onVisibleChange,
      getPanelElement: getPanelElement,
      renderClearButton: renderClearButton,
      onKeyDown: onKeyDown,
      getFormat: getFormat,
      getPopupClassName: getPopupClassName,
      setPicker: setPicker
    };
  },
  render: function render(ctx) {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var prefixCls = ctx.prefixCls,
        placeholder = ctx.placeholder,
        placement = ctx.placement,
        align = ctx.align,
        id = ctx.id,
        disabled = ctx.disabled,
        transitionName = ctx.transitionName,
        getPopupContainer = ctx.getPopupContainer,
        name = ctx.name,
        autoComplete = ctx.autoComplete,
        autoFocus = ctx.autoFocus,
        inputReadOnly = ctx.inputReadOnly,
        sOpen = ctx.sOpen,
        sValue = ctx.sValue,
        onFocus = ctx.onFocus,
        onBlur = ctx.onBlur,
        popupStyle = ctx.popupStyle;
    var popupClassName = ctx.getPopupClassName();
    var inputIcon = props_util_getComponentFromProp(instance, 'inputIcon');
    var clearButton = ctx.renderClearButton();
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_trigger, {
      "prefixCls": "".concat(prefixCls, "-panel"),
      "popupClassName": popupClassName,
      "popupStyle": popupStyle,
      "popupAlign": align,
      "builtinPlacements": vc_time_picker_placements,
      "popupPlacement": placement,
      "action": disabled ? [] : ['click'],
      "destroyPopupOnHide": true,
      "getPopupContainer": getPopupContainer,
      "popupTransitionName": transitionName,
      "popupVisible": sOpen,
      "onPopupVisibleChange": ctx.onVisibleChange
    }, {
      "popup": [ctx.getPanelElement()],
      "default": [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls)
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", {
        "class": "".concat(prefixCls, "-input"),
        "ref": this.setPicker,
        "type": "text",
        "placeholder": placeholder,
        "name": name,
        "onKeydown": ctx.onKeyDown,
        "disabled": disabled,
        "value": sValue && sValue.format(ctx.getFormat()) || '',
        "autocomplete": autoComplete,
        "onFocus": onFocus,
        "onBlur": onBlur,
        "autofocus": autoFocus,
        "readonly": !!inputReadOnly,
        "id": id
      }, []), inputIcon || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-icon")
      }, []), clearButton])]
    });
  }
}));
// CONCATENATED MODULE: ./src/components/vc-time-picker/index.ts

// based on rc-time-picker 3.7.3

// CONCATENATED MODULE: ./src/components/time-picker/index.tsx


function time_picker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function time_picker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { time_picker_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { time_picker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }














function generateShowHourMinuteSecond(format) {
  // Ref: http://momentjs.com/docs/#/parsing/string-format/
  return {
    showHour: format.indexOf('H') > -1 || format.indexOf('h') > -1 || format.indexOf('k') > -1,
    showMinute: format.indexOf('m') > -1,
    showSecond: format.indexOf('s') > -1
  };
}

function time_picker_isMoment(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || value.findIndex(function (val) {
      return val === undefined || moment["isMoment"](val);
    }) !== -1;
  } else {
    return value === undefined || moment["isMoment"](value);
  }
}

var time_picker_MomentType = vue_types.custom(time_picker_isMoment);
var time_picker_TimePickerProps = function TimePickerProps() {
  return {
    size: vue_types.oneOf(['large', 'default', 'small']),
    value: time_picker_MomentType,
    defaultValue: time_picker_MomentType,
    open: vue_types.bool,
    format: vue_types.string,
    disabled: vue_types.bool,
    placeholder: vue_types.string,
    prefixCls: vue_types.string,
    hideDisabledOptions: vue_types.bool,
    disabledHours: vue_types.func,
    disabledMinutes: vue_types.func,
    disabledSeconds: vue_types.func,
    getPopupContainer: vue_types.func,
    use12Hours: vue_types.bool,
    focusOnOpen: vue_types.bool,
    hourStep: vue_types.number,
    minuteStep: vue_types.number,
    secondStep: vue_types.number,
    allowEmpty: vue_types.bool,
    allowClear: vue_types.bool,
    inputReadOnly: vue_types.bool,
    clearText: vue_types.string,
    defaultOpenValue: vue_types.object,
    popupClassName: vue_types.string,
    popupStyle: vue_types.object,
    suffixIcon: vue_types.any,
    align: vue_types.object,
    placement: vue_types.any,
    transitionName: vue_types.string,
    autoFocus: vue_types.bool,
    addon: vue_types.any,
    clearIcon: vue_types.any,
    locale: vue_types.object
  };
};
var TimePicker = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ATimePicker',
  props: initDefaultProps(time_picker_TimePickerProps(), {
    align: {
      offset: [0, -2]
    },
    disabled: false,
    disabledHours: undefined,
    disabledMinutes: undefined,
    disabledSeconds: undefined,
    hideDisabledOptions: false,
    placement: 'bottomLeft',
    transitionName: 'slide-up',
    focusOnOpen: true,
    allowClear: true
  }),
  provide: function provide() {
    return {
      savePopupRef: this.savePopupRef
    };
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var configProvider = config_provider_useConfigProvider();

    var _useLocalValue = value_useLocalValue(props.defaultValue),
        value = _useLocalValue.value,
        setValue = _useLocalValue.setValue;

    var popupRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var timePickerRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var getDefaultFormat = function getDefaultFormat() {
      var format = props.format,
          use12Hours = props.use12Hours;

      if (format) {
        return format;
      } else if (use12Hours) {
        return 'h:mm:ss a';
      }

      return 'HH:mm:ss';
    };

    var getAllowClear = function getAllowClear() {
      var allowClear = props.allowClear,
          allowEmpty = props.allowEmpty;

      if (props.allowClear !== undefined) {
        return allowClear;
      }

      return allowEmpty;
    };

    var getDefaultLocale = function getDefaultLocale() {
      return Object.assign(Object.assign({}, locale_zh_CN), props.locale);
    };

    var handleChange = function handleChange(v) {
      setValue(v);
      var _props$format = props.format,
          format = _props$format === void 0 ? 'HH:mm:ss' : _props$format;
      emit('change', v, v && v.format(format) || '');
    };

    var handleOpenClose = function handleOpenClose(_ref2) {
      var open = _ref2.open;
      emit('openChange', open);
      emit('update:open', open);
    };

    var setTimePicker = function setTimePicker(el) {
      timePickerRef.value = el;
    };

    var focus = function focus() {
      timePickerRef.value.focus();
    };

    var blur = function blur() {
      timePickerRef.value.blur();
    };

    var renderInputIcon = function renderInputIcon(prefixCls) {
      var suffixIcon = getComponentFromContext({
        $props: props,
        $slots: slots
      }, 'suffixIcon');
      suffixIcon = Array.isArray(suffixIcon) ? suffixIcon[0] : suffixIcon;
      var clockIcon = suffixIcon && isValidElement(suffixIcon) && cloneElement(suffixIcon, {
        "class": "".concat(prefixCls, "-clock-icon")
      }) || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "clock-circle",
        "class": "".concat(prefixCls, "-clock-icon")
      }, []);
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-icon")
      }, [clockIcon]);
    };

    var renderClearIcon = function renderClearIcon(prefixCls) {
      var clearIcon = props_util_getComponentFromProp(instance, 'clearIcon');
      var clearIconPrefixCls = "".concat(prefixCls, "-clear");

      if (clearIcon && isValidElement(clearIcon)) {
        return cloneElement(clearIcon, {
          "class": clearIconPrefixCls
        });
      }

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "close-circle",
        "class": clearIconPrefixCls,
        "theme": "filled"
      }, []);
    };

    return {
      value: value,
      focus: focus,
      blur: blur,
      getDefaultLocale: getDefaultLocale,
      savePopupRef: function savePopupRef(el) {
        popupRef.value = el;
      },
      renderTimePicker: function renderTimePicker(locale) {
        var ommitedProps = es(props, ['defaultValue', 'suffixIcon', 'allowEmpty', 'allowClear']);
        var customizePrefixCls = ommitedProps.prefixCls,
            getPopupContainer = ommitedProps.getPopupContainer,
            placeholder = ommitedProps.placeholder,
            size = ommitedProps.size;
        var getPrefixCls = configProvider.getPrefixCls;
        var prefixCls = getPrefixCls('time-picker', customizePrefixCls);
        var format = getDefaultFormat();

        var pickerClassName = defineProperty_default()({}, "".concat(prefixCls, "-").concat(size), !!size);

        var tempAddon = props_util_getComponentFromProp(instance, 'addon', {}, false);

        var pickerAddon = function pickerAddon(panel) {
          return tempAddon ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
            "class": "".concat(prefixCls, "-panel-addon")
          }, [typeof tempAddon === 'function' ? tempAddon(panel) : tempAddon]) : null;
        };

        var inputIcon = renderInputIcon(prefixCls);
        var clearIcon = renderClearIcon(prefixCls);
        var getContextPopupContainer = configProvider.getPopupContainer;
        var timeProps = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, generateShowHourMinuteSecond(format)), ommitedProps), {
          allowEmpty: getAllowClear(),
          prefixCls: prefixCls,
          getPopupContainer: getPopupContainer || getContextPopupContainer,
          format: format,
          value: value.value,
          placeholder: placeholder === undefined ? locale.placeholder : placeholder,
          addon: pickerAddon,
          inputIcon: inputIcon,
          clearIcon: clearIcon,
          "class": pickerClassName,
          ref: setTimePicker
        }), getListenersFromInstance(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])())), {
          onChange: handleChange,
          onOpen: handleOpenClose,
          onClose: handleOpenClose
        });
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(time_picker, time_picker_objectSpread({}, timeProps), []);
      }
    };
  },
  render: function render(ctx) {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(locale_receiver, {
      "componentName": "TimePicker",
      "defaultLocale": ctx.getDefaultLocale()
    }, {
      "default": ctx.renderTimePicker
    });
  }
});
/* istanbul ignore next */

TimePicker.install = function (Vue) {
  Vue.use(base);
  Vue.component(TimePicker.name, TimePicker);
};

/* harmony default export */ var components_time_picker = (TimePicker);
// CONCATENATED MODULE: ./src/components/date-picker/wrap-picker.tsx


function wrap_picker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function wrap_picker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { wrap_picker_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { wrap_picker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }













function checkValidate(value, propName) {
  var values = Array.isArray(value) ? value : [value];
  values.forEach(function (val) {
    if (!val) {
      return;
    }

    _util_warning(!interopDefault(moment).isMoment(val) || val.isValid(), 'DatePicker', "`".concat(propName, "` provides invalidate moment time. If you want to set empty value, use `null` instead."));
  });
}

var DEFAULT_FORMAT = {
  date: 'YYYY-MM-DD',
  dateTime: 'YYYY-MM-DD HH:mm:ss',
  week: 'gggg-wo',
  month: 'YYYY-MM'
};
var LOCALE_FORMAT_MAPPING = {
  date: 'dateFormat',
  dateTime: 'dateTimeFormat',
  week: 'weekFormat',
  month: 'monthFormat'
};

function getColumns(_ref) {
  var showHour = _ref.showHour,
      showMinute = _ref.showMinute,
      showSecond = _ref.showSecond,
      use12Hours = _ref.use12Hours;
  var column = 0;

  if (showHour) {
    column += 1;
  }

  if (showMinute) {
    column += 1;
  }

  if (showSecond) {
    column += 1;
  }

  if (use12Hours) {
    column += 1;
  }

  return column;
}

function wrapPicker(Picker, propsDef, pickerType) {
  return {
    name: Picker.name,
    props: initDefaultProps(propsDef, {
      transitionName: 'slide-up',
      popupStyle: {},
      locale: {}
    }),
    model: {
      prop: 'value',
      event: 'change'
    },
    setup: function setup(props, _ref2) {
      var emit = _ref2.emit,
          slots = _ref2.slots;
      form_useForm().registerControl();
      var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
      var popupRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
      var pickerRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
        return props.value;
      }, function (val) {
        checkValidate(val, 'value');
      });

      var savePopupRef = function savePopupRef(el) {
        popupRef.value = el;
      };

      var handleOpenChange = function handleOpenChange(open) {
        emit('openChange', open);
      };

      var getDefaultLocale = function getDefaultLocale() {
        var result = Object.assign(Object.assign({}, date_picker_locale_zh_CN), props.locale);
        result.lang = Object.assign(Object.assign({}, result.lang), (props.locale || {}).lang);
        return result;
      };

      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])('savePopupRef', savePopupRef);
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
        var autoFocus = props.autoFocus,
            disabled = props.disabled,
            value = props.value,
            defaultValue = props.defaultValue;
        checkValidate(defaultValue, 'defaultValue');
        checkValidate(value, 'value');

        if (autoFocus && !disabled) {
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
            focus();
          });
        }
      });

      var handleFocus = function handleFocus(e) {
        emit('focus', e);
      };

      var handleBlur = function handleBlur(e) {
        emit('blur', e);
      };

      var handleMouseEnter = function handleMouseEnter(e) {
        emit('mouseenter', e);
      };

      var handleMouseLeave = function handleMouseLeave(e) {
        emit('mouseleave', e);
      };

      return {
        configProvider: config_provider_useConfigProvider(),
        getDefaultLocale: getDefaultLocale,
        handleFocus: handleFocus,
        handleBlur: handleBlur,
        handleMouseEnter: handleMouseEnter,
        handleMouseLeave: handleMouseLeave,
        focus: function focus() {
          pickerRef.value.focus();
        },
        blur: function blur() {
          pickerRef.value.blur();
        },
        renderPicker: function renderPicker(locale, localeCode) {
          var _classNames2;

          var customizePrefixCls = props.prefixCls,
              customizeInputPrefixCls = props.inputPrefixCls,
              getCalendarContainer = props.getCalendarContainer,
              size = props.size,
              showTime = props.showTime,
              disabled = props.disabled,
              format = props.format;
          var mergedPickerType = showTime ? "".concat(pickerType, "Time") : pickerType;
          var mergedFormat = format || locale[LOCALE_FORMAT_MAPPING[mergedPickerType]] || DEFAULT_FORMAT[mergedPickerType];
          var _this$configProvider = this.configProvider,
              getPrefixCls = _this$configProvider.getPrefixCls,
              getContextPopupContainer = _this$configProvider.getPopupContainer;
          var getPopupContainer = getCalendarContainer || getContextPopupContainer;
          var prefixCls = getPrefixCls('calendar', customizePrefixCls);
          var inputPrefixCls = getPrefixCls('input', customizeInputPrefixCls);
          var pickerClass = classnames_default()("".concat(prefixCls, "-picker"), defineProperty_default()({}, "".concat(prefixCls, "-picker-").concat(size), !!size));
          var pickerInputClass = classnames_default()("".concat(prefixCls, "-picker-input"), inputPrefixCls, (_classNames2 = {}, defineProperty_default()(_classNames2, "".concat(inputPrefixCls, "-lg"), size === 'large'), defineProperty_default()(_classNames2, "".concat(inputPrefixCls, "-sm"), size === 'small'), defineProperty_default()(_classNames2, "".concat(inputPrefixCls, "-disabled"), disabled), _classNames2));
          var timeFormat = showTime && showTime.format || 'HH:mm:ss';
          var vcTimePickerProps = Object.assign(Object.assign({}, generateShowHourMinuteSecond(timeFormat)), {
            format: timeFormat,
            use12Hours: showTime && showTime.use12Hours
          });
          var columns = getColumns(vcTimePickerProps);
          var timePickerCls = "".concat(prefixCls, "-time-picker-column-").concat(columns);
          var timePickerPanelProps = Object.assign(Object.assign(Object.assign({}, vcTimePickerProps), showTime), {
            prefixCls: "".concat(prefixCls, "-time-picker"),
            placeholder: locale.timePickerLocale.placeholder,
            transitionName: 'slide-up',
            "class": timePickerCls,
            onEsc: function onEsc() {}
          });
          var timePicker = showTime ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_time_picker_panel, wrap_picker_objectSpread({}, timePickerPanelProps), []) : null;
          var pickerProps = Object.assign(Object.assign(Object.assign(Object.assign({}, props), {
            getCalendarContainer: getPopupContainer,
            format: mergedFormat,
            pickerClass: pickerClass,
            pickerInputClass: pickerInputClass,
            locale: locale,
            localeCode: localeCode,
            timePicker: timePicker
          }), getListenersFromInstance(instance)), {
            onOpenChange: handleOpenChange,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onMouseenter: handleMouseEnter,
            onMouseleave: handleMouseLeave,
            ref: 'picker'
          });
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Picker, wrap_picker_objectSpread({}, pickerProps), slots);
        }
      };
    },
    render: function render(ctx) {
      return ctx.renderPicker(ctx.getDefaultLocale());
    }
  };
}
// EXTERNAL MODULE: ./node_modules/shallowequal/index.js
var shallowequal = __webpack_require__("1b2b");
var shallowequal_default = /*#__PURE__*/__webpack_require__.n(shallowequal);

// CONCATENATED MODULE: ./src/components/tag/tag.tsx


function tag_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function tag_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tag_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tag_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }










var PresetColorTypes = ['pink', 'red', 'yellow', 'orange', 'cyan', 'green', 'blue', 'purple', 'geekblue', 'magenta', 'volcano', 'gold', 'lime'];
var PresetColorRegex = new RegExp("^(".concat(PresetColorTypes.join('|'), ")(-inverse)?$"));
/* harmony default export */ var tag_tag = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ATag',
  props: {
    prefixCls: vue_types.string,
    color: vue_types.string,
    closable: vue_types.bool.def(false),
    visible: vue_types.bool,
    afterClose: vue_types.func
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var _useLocalValue = value_useLocalValue(true, 'visible'),
        _visible = _useLocalValue.value,
        setLocalVisible = _useLocalValue.setValue;

    var setVisible = function setVisible(visible, e) {
      emit('close', e);
      emit('close.visible', false);
      var afterClose = props.afterClose;

      if (afterClose) {
        // next version remove.
        afterClose();
      }

      if (e.defaultPrevented) {
        return;
      }

      setLocalVisible(visible);
    };

    var handleIconClick = function handleIconClick(e) {
      e.stopPropagation();
      setVisible(false, e);
    };

    var isPresetColor = function isPresetColor() {
      var color = props.color;

      if (!color) {
        return false;
      }

      return PresetColorRegex.test(color);
    };

    var getTagStyle = function getTagStyle() {
      var color = props.color;
      return {
        backgroundColor: color && !isPresetColor() ? color : undefined
      };
    };

    var getTagClassName = function getTagClassName(prefixCls) {
      var _ref2;

      var color = props.color;
      return _ref2 = {}, defineProperty_default()(_ref2, prefixCls, true), defineProperty_default()(_ref2, "".concat(prefixCls, "-").concat(color), isPresetColor()), defineProperty_default()(_ref2, "".concat(prefixCls, "-has-color"), color && !isPresetColor()), _ref2;
    };

    var renderCloseIcon = function renderCloseIcon() {
      var closable = props.closable;
      return closable ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "close",
        "onClick": handleIconClick
      }, []) : null;
    };

    return {
      _visible: _visible,
      setVisible: setVisible,
      handleIconClick: handleIconClick,
      isPresetColor: isPresetColor,
      getTagStyle: getTagStyle,
      getTagClassName: getTagClassName,
      renderCloseIcon: renderCloseIcon,
      configProvider: config_provider_useConfigProvider()
    };
  },
  render: function render(ctx) {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var customizePrefixCls = ctx.prefixCls;
    var getPrefixCls = ctx.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('tag', customizePrefixCls);
    var visible = ctx._visible;
    var tag = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", tag_objectSpread({}, es(getListenersFromInstance(instance), ['close']), {
      "class": ctx.getTagClassName(prefixCls),
      "style": ctx.getTagStyle()
    }), [this.$slots["default"] && this.$slots["default"](), ctx.renderCloseIcon()]), [[external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], visible]]);
    var transitionProps = get_transition_props("".concat(prefixCls, "-zoom"), {
      appear: false
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(wave, {}, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], tag_objectSpread({}, transitionProps), [tag])]);
  }
}));
// CONCATENATED MODULE: ./src/components/tag/checkable-tag.tsx





/* harmony default export */ var checkable_tag = ({
  name: 'ACheckableTag',
  props: {
    prefixCls: vue_types.string,
    checked: Boolean
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var _useLocalValue = value_useLocalValue(false, 'checked'),
        value = _useLocalValue.value,
        setValue = _useLocalValue.setValue,
        getValue = _useLocalValue.getValue;

    var configProvider = config_provider_useConfigProvider();
    var classes = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["computed"])(function () {
      var _ref2;

      var customizePrefixCls = props.prefixCls;
      var getPrefixCls = configProvider.getPrefixCls;
      var prefixCls = getPrefixCls('tag', customizePrefixCls);
      return _ref2 = {}, defineProperty_default()(_ref2, "".concat(prefixCls), true), defineProperty_default()(_ref2, "".concat(prefixCls, "-checkable"), true), defineProperty_default()(_ref2, "".concat(prefixCls, "-checkable-checked"), value.value), _ref2;
    });

    var handleClick = function handleClick() {
      var checked = getValue();
      setValue(!checked);
      emit('change', !checked);
    };

    return {
      classes: classes,
      handleClick: handleClick,
      value: value
    };
  },
  render: function render(ctx) {
    var classes = ctx.classes,
        handleClick = ctx.handleClick,
        $slots = ctx.$slots;
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": classes,
      "onClick": handleClick
    }, [$slots["default"] && $slots["default"]()]);
  }
});
// CONCATENATED MODULE: ./src/components/tag/index.ts




tag_tag.CheckableTag = checkable_tag;
/* istanbul ignore next */

tag_tag.install = function (Vue) {
  Vue.use(base);
  Vue.component(tag_tag.name, tag_tag);
  Vue.component(tag_tag.CheckableTag.name, tag_tag.CheckableTag);
};

/* harmony default export */ var components_tag = (tag_tag);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/range-calendar/calendar-part.tsx


function calendar_part_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function calendar_part_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { calendar_part_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { calendar_part_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }










function calendar_part_noop() {}

var CalendarPart = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'CalendarPart',
  props: {
    prefixCls: vue_types.string,
    value: vue_types.any,
    hoverValue: vue_types.any,
    selectedValue: vue_types.any,
    direction: vue_types.any,
    locale: vue_types.any,
    showDateInput: vue_types.bool,
    showTimePicker: vue_types.bool,
    showWeekNumber: vue_types.bool,
    format: vue_types.any,
    placeholder: vue_types.any,
    disabledDate: vue_types.any,
    timePicker: vue_types.any,
    disabledTime: vue_types.any,
    disabledMonth: vue_types.any,
    mode: vue_types.any,
    // onInputSelect: PropTypes.func,
    timePickerDisabledTime: vue_types.object,
    enableNext: vue_types.any,
    enablePrev: vue_types.any,
    clearIcon: vue_types.any,
    dateRender: vue_types.func,
    inputMode: vue_types.string
  },
  render: function render() {
    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var props = currentInstance.props;
    var prefixCls = props.prefixCls,
        value = props.value,
        hoverValue = props.hoverValue,
        selectedValue = props.selectedValue,
        mode = props.mode,
        direction = props.direction,
        locale = props.locale,
        format = props.format,
        placeholder = props.placeholder,
        disabledDate = props.disabledDate,
        timePicker = props.timePicker,
        disabledTime = props.disabledTime,
        timePickerDisabledTime = props.timePickerDisabledTime,
        showTimePicker = props.showTimePicker,
        enablePrev = props.enablePrev,
        enableNext = props.enableNext,
        disabledMonth = props.disabledMonth,
        showDateInput = props.showDateInput,
        dateRender = props.dateRender,
        showWeekNumber = props.showWeekNumber,
        showClear = props.showClear,
        inputMode = props.inputMode;
    var clearIcon = props_util_getComponentFromProp(currentInstance, 'clearIcon');

    var _getListenersFromInst = getListenersFromInstance(currentInstance),
        _getListenersFromInst2 = _getListenersFromInst.onInputChange,
        onInputChange = _getListenersFromInst2 === void 0 ? calendar_part_noop : _getListenersFromInst2,
        _getListenersFromInst3 = _getListenersFromInst.onInputSelect,
        onInputSelect = _getListenersFromInst3 === void 0 ? calendar_part_noop : _getListenersFromInst3,
        _getListenersFromInst4 = _getListenersFromInst.onValueChange,
        onValueChange = _getListenersFromInst4 === void 0 ? calendar_part_noop : _getListenersFromInst4,
        _getListenersFromInst5 = _getListenersFromInst.onPanelChange,
        onPanelChange = _getListenersFromInst5 === void 0 ? calendar_part_noop : _getListenersFromInst5,
        _getListenersFromInst6 = _getListenersFromInst.onSelect,
        onSelect = _getListenersFromInst6 === void 0 ? calendar_part_noop : _getListenersFromInst6,
        _getListenersFromInst7 = _getListenersFromInst.onDayHover,
        onDayHover = _getListenersFromInst7 === void 0 ? calendar_part_noop : _getListenersFromInst7;

    var shouldShowTimePicker = showTimePicker && timePicker;
    var disabledTimeConfig = shouldShowTimePicker && disabledTime ? getTimeConfig(selectedValue, disabledTime) : null;
    var rangeClassName = "".concat(prefixCls, "-range");
    var newProps = {
      locale: locale,
      value: value,
      prefixCls: prefixCls,
      showTimePicker: showTimePicker
    };
    var index = direction === 'left' ? 0 : 1;
    var timePickerEle = null;

    if (shouldShowTimePicker) {
      var timePickerProps = getOptionProps(timePicker);
      timePickerEle = cloneElement(timePicker, Object.assign(Object.assign(Object.assign(Object.assign({
        showHour: true,
        showMinute: true,
        showSecond: true
      }, timePickerProps), disabledTimeConfig), timePickerDisabledTime), {
        defaultOpenValue: value,
        value: selectedValue[index],
        onChange: onInputChange
      }));
    }

    var dateInputElement = showDateInput && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(date_input, {
      "format": format,
      "locale": locale,
      "prefixCls": prefixCls,
      "timePicker": timePicker,
      "disabledDate": disabledDate,
      "placeholder": placeholder,
      "disabledTime": disabledTime,
      "value": value,
      "showClear": showClear || false,
      "selectedValue": selectedValue[index],
      "onChange": onInputChange,
      "onSelect": onInputSelect,
      "clearIcon": clearIcon,
      "inputMode": inputMode
    }, []);
    var headerProps = Object.assign(Object.assign({}, newProps), {
      mode: mode,
      enableNext: enableNext,
      enablePrev: enablePrev,
      disabledMonth: disabledMonth,
      onValueChange: onValueChange,
      onPanelChange: onPanelChange
    });
    var tableProps = Object.assign(Object.assign({}, newProps), {
      hoverValue: hoverValue,
      selectedValue: selectedValue,
      dateRender: dateRender,
      disabledDate: disabledDate,
      showWeekNumber: showWeekNumber,
      onSelect: onSelect,
      onDayHover: onDayHover
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(rangeClassName, "-part ").concat(rangeClassName, "-").concat(direction)
    }, [dateInputElement, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "style": {
        outline: 'none'
      }
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(calendar_calendar_header, calendar_part_objectSpread({}, headerProps), []), showTimePicker ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-time-picker")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-time-picker-panel")
    }, [timePickerEle])]) : null, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-body")
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(date_table, calendar_part_objectSpread({}, tableProps), [])])])]);
  }
});
/* harmony default export */ var calendar_part = (CalendarPart);
// CONCATENATED MODULE: ./src/components/vc-calendar/src/range-calendar.tsx




function range_calendar_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function range_calendar_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { range_calendar_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { range_calendar_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
















function range_calendar_noop() {}

function isEmptyArray(arr) {
  return Array.isArray(arr) && (arr.length === 0 || arr.every(function (i) {
    return !i;
  }));
}

function isArraysEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (a === null || typeof a === 'undefined' || b === null || typeof b === 'undefined') {
    return false;
  }

  if (a.length !== b.length) {
    return false;
  }

  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) {
      return false;
    }
  }

  return true;
}

function getValueFromSelectedValue(selectedValue) {
  var _selectedValue = slicedToArray_default()(selectedValue, 2),
      start = _selectedValue[0],
      end = _selectedValue[1];

  if (end && (start === undefined || start === null)) {
    start = end.clone().subtract(1, 'month');
  }

  if (start && (end === undefined || end === null)) {
    end = start.clone().add(1, 'month');
  }

  return [start, end];
}

function normalizeAnchor(props, init) {
  var selectedValue = props.selectedValue || init && props.defaultSelectedValue;
  var value = props.value || init && props.defaultValue;
  var normalizedValue = value ? getValueFromSelectedValue(value) : getValueFromSelectedValue(selectedValue);
  return !isEmptyArray(normalizedValue) ? normalizedValue : init && [moment_default()(), moment_default()().add(1, 'months')];
}

function range_calendar_generateOptions(length, extraOptionGen) {
  var arr = extraOptionGen ? extraOptionGen().concat() : [];

  for (var value = 0; value < length; value++) {
    if (arr.indexOf(value) === -1) {
      arr.push(value);
    }
  }

  return arr;
}

var RangeCalendar = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: {
    locale: vue_types.object.def(zh_CN),
    visible: vue_types.bool.def(true),
    prefixCls: vue_types.string.def('rc-calendar'),
    dateInputPlaceholder: vue_types.any,
    seperator: vue_types.string.def('~'),
    defaultValue: vue_types.any,
    value: vue_types.any,
    hoverValue: vue_types.any,
    mode: vue_types.arrayOf(vue_types.oneOf(['time', 'date', 'month', 'year', 'decade'])),
    showDateInput: vue_types.bool.def(true),
    timePicker: vue_types.any,
    showOk: vue_types.bool,
    showToday: vue_types.bool.def(true),
    defaultSelectedValue: vue_types.array.def([]),
    selectedValue: vue_types.array,
    showClear: vue_types.bool,
    showWeekNumber: vue_types.bool,
    // locale: PropTypes.object,
    // onChange: PropTypes.func,
    // onSelect: PropTypes.func,
    // onValueChange: PropTypes.func,
    // onHoverChange: PropTypes.func,
    // onPanelChange: PropTypes.func,
    format: vue_types.oneOfType([vue_types.string, vue_types.arrayOf(vue_types.string)]),
    // onClear: PropTypes.func,
    type: vue_types.any.def('both'),
    disabledDate: vue_types.func,
    disabledTime: vue_types.func.def(function () {
      return function () {
        return range_calendar_noop;
      };
    }),
    renderFooter: vue_types.func.def(function () {
      return function () {
        return null;
      };
    }),
    renderSidebar: vue_types.func.def(function () {
      return function () {
        return null;
      };
    }),
    dateRender: vue_types.func,
    clearIcon: vue_types.any
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var _useLocalValue = value_useLocalValue(props.defaultSelectedValue, 'selectedValue'),
        sSelectedValue = _useLocalValue.value;

    var prevSelectedValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(sSelectedValue.value);
    var firstSelectedValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var sHoverValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.hoverValue || []);
    var sValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(normalizeAnchor(props, 1));
    var sShowTimePicker = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var sPanelTriggerSource = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])('');

    var _useLocalValue2 = value_useLocalValue(['date', 'date'], 'mode'),
        sMode = _useLocalValue2.value;

    var _useCommonMixin = common_mixin_useCommonMixin(props),
        getFormat = _useCommonMixin.getFormat;

    var hasSelectedValue = function hasSelectedValue() {
      return !!sSelectedValue.value[1] && !!sSelectedValue.value[0];
    };

    var compare = function compare(v1, v2) {
      if (props.timePicker) {
        return v1.diff(v2);
      }

      return v1.diff(v2, 'days');
    };

    var fireHoverValueChange = function fireHoverValueChange(hoverValue) {
      if (props.hoverValue === undefined) {
        sHoverValue.value = hoverValue;
      }

      emit('hoverChange', hoverValue);
    };

    var onSelect = function onSelect(value) {
      var type = props.type;
      var nextSelectedValue;

      if (type === 'both') {
        if (!firstSelectedValue.value) {
          syncTime(prevSelectedValue.value[0], value);
          nextSelectedValue = [value];
        } else if (compare(firstSelectedValue.value, value) < 0) {
          syncTime(prevSelectedValue.value[1], value);
          nextSelectedValue = [firstSelectedValue.value, value];
        } else {
          syncTime(prevSelectedValue.value[0], value);
          syncTime(prevSelectedValue.value[1], firstSelectedValue.value);
          nextSelectedValue = [value, firstSelectedValue.value];
        }
      } else if (type === 'start') {
        syncTime(prevSelectedValue.value[0], value);
        var endValue = sSelectedValue.value[1];
        nextSelectedValue = endValue && compare(endValue, value) > 0 ? [value, endValue] : [value];
      } else {
        // type === 'end'
        var startValue = sSelectedValue.value[0];

        if (startValue && compare(startValue, value) <= 0) {
          syncTime(prevSelectedValue.value[1], value);
          nextSelectedValue = [startValue, value];
        } else {
          syncTime(prevSelectedValue.value[0], value);
          nextSelectedValue = [value];
        }
      }

      fireSelectValueChange(nextSelectedValue);
    };

    var getStartValue = function getStartValue() {
      var selectedValue = sSelectedValue.value;
      var showTimePicker = sShowTimePicker.value;
      var value = sValue.value;
      var mode = sMode.value;
      var panelTriggerSource = sPanelTriggerSource.value;
      var startValue = value[0]; // keep selectedTime when select date

      if (selectedValue[0] && props.timePicker) {
        startValue = startValue.clone();
        syncTime(selectedValue[0], startValue);
      }

      if (showTimePicker && selectedValue[0]) {
        startValue = selectedValue[0];
      } // Adjust month if date not align


      if (panelTriggerSource === 'end' && mode[0] === 'date' && mode[1] === 'date' && startValue.isSame(value[1], 'month')) {
        startValue = startValue.clone().subtract(1, 'month');
      }

      return startValue;
    };

    var onDayHover = function onDayHover(value) {
      var hoverValue = [];
      var selectedValue = sSelectedValue.value;
      var sFirstSelectedValue = firstSelectedValue.value;
      var type = props.type;

      if (type === 'start' && selectedValue[1]) {
        hoverValue = compare(value, selectedValue[1]) < 0 ? [value, selectedValue[1]] : [value];
      } else if (type === 'end' && selectedValue[0]) {
        hoverValue = compare(value, selectedValue[0]) > 0 ? [selectedValue[0], value] : [];
      } else {
        if (!sFirstSelectedValue) {
          if (sHoverValue.value.length) {
            sHoverValue.value = [];
          }

          return hoverValue;
        }

        hoverValue = compare(value, sFirstSelectedValue) < 0 ? [value, sFirstSelectedValue] : [sFirstSelectedValue, value];
      }

      fireHoverValueChange(hoverValue);
      return hoverValue;
    };

    var onDatePanelEnter = function onDatePanelEnter() {
      if (hasSelectedValue()) {
        fireHoverValueChange(sSelectedValue.value.concat());
      }
    };

    var fireValueChange = function fireValueChange(value) {
      if (props.value === undefined) {
        sValue.value = value;
      }

      emit('valueChange', value);
    };

    var onInputSelect = function onInputSelect(direction, value, cause) {
      if (!value) {
        return;
      }

      var originalValue = sSelectedValue.value;
      var selectedValue = originalValue.concat();
      var index = direction === 'left' ? 0 : 1;
      selectedValue[index] = value;

      if (selectedValue[0] && compare(selectedValue[0], selectedValue[1]) > 0) {
        selectedValue[1 - index] = sShowTimePicker.value ? selectedValue[index] : undefined;
      }

      emit('inputSelect', selectedValue);
      fireSelectValueChange(selectedValue, null, cause || {
        source: 'dateInput'
      });
    };

    var disabledStartTime = function disabledStartTime(time) {
      return props.disabledTime(time, 'start');
    };

    var disabledEndTime = function disabledEndTime(time) {
      return props.disabledTime(time, 'end');
    };

    var isAllowedDateAndTime = function isAllowedDateAndTime(selectedValue) {
      return util_isAllowedDate(selectedValue[0], props.disabledDate, disabledStartTime) && util_isAllowedDate(selectedValue[1], props.disabledDate, disabledEndTime);
    };

    var fireSelectValueChange = function fireSelectValueChange(selectedValue, direct, cause) {
      var prevSelectedVal = prevSelectedValue.value;
      var timePicker = props.timePicker;

      if (timePicker) {
        var timePickerProps = getOptionProps(timePicker);

        if (timePickerProps.defaultValue) {
          var timePickerDefaultValue = timePickerProps.defaultValue;

          if (!prevSelectedVal[0] && selectedValue[0]) {
            syncTime(timePickerDefaultValue[0], selectedValue[0]);
          }

          if (!prevSelectedVal[1] && selectedValue[1]) {
            syncTime(timePickerDefaultValue[1], selectedValue[1]);
          }
        }
      } // 尚未选择过时间，直接输入的话


      if (!sSelectedValue.value[0] || !sSelectedValue.value[1]) {
        var startValue = selectedValue[0] || moment_default()();
        var endValue = selectedValue[1] || startValue.clone().add(1, 'months');
        sSelectedValue.value = selectedValue;
        sValue.value = selectedValue && selectedValue.length === 2 ? getValueFromSelectedValue([startValue, endValue]) : sValue.value;
      }

      if (selectedValue[0] && !selectedValue[1]) {
        firstSelectedValue.value = selectedValue[0];
        fireHoverValueChange(selectedValue.concat());
      }

      emit('change', selectedValue);

      if (direct || selectedValue[0] && selectedValue[1]) {
        prevSelectedValue.value = selectedValue;
        firstSelectedValue.value = null;
        fireHoverValueChange([]);
        emit('select', selectedValue, cause);
      }

      if (props.selectedValue === undefined) {
        sSelectedValue.value = selectedValue;
      }
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.value;
    }, function (val) {
      sValue.value = normalizeAnchor(props, 0);
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.hoverValue;
    }, function (val) {
      if (!isArraysEqual(sHoverValue.value, val)) {
        sHoverValue.value = val;
      }
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.selectedValue.value;
    }, function (val) {
      sSelectedValue.value = val;
      prevSelectedValue.value = val;
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.mode;
    }, function (val) {
      if (!isArraysEqual(sMode.value, val)) {
        sMode.value = val;
      }
    });
    return {
      getFormat: getFormat,
      sSelectedValue: sSelectedValue,
      prevSelectedValue: prevSelectedValue,
      firstSelectedValue: firstSelectedValue,
      sHoverValue: sHoverValue,
      sValue: sValue,
      sShowTimePicker: sShowTimePicker,
      sMode: sMode,
      sPanelTriggerSource: sPanelTriggerSource,
      onDatePanelEnter: onDatePanelEnter,
      onDatePanelLeave: function onDatePanelLeave() {
        if (hasSelectedValue()) {
          fireHoverValueChange([]);
        }
      },
      onSelect: onSelect,
      onKeyDown: function onKeyDown(event) {
        if (event.target.nodeName.toLowerCase() === 'input') {
          return;
        }

        var keyCode = event.keyCode;
        var ctrlKey = event.ctrlKey || event.metaKey;
        var selectedValue = sSelectedValue.value;
        var hoverValue = sHoverValue.value;
        var value = sValue.value;
        var disabledDate = props.disabledDate; // Update last time of the picker

        var updateHoverPoint = function updateHoverPoint(func) {
          // Change hover to make focus in UI
          var currentHoverTime;
          var nextHoverTime;
          var nextHoverValue;

          if (!firstSelectedValue.value) {
            currentHoverTime = hoverValue[0] || selectedValue[0] || value[0] || moment_default()();
            nextHoverTime = func(currentHoverTime);
            nextHoverValue = [nextHoverTime];
            fireHoverValueChange(nextHoverValue);
          } else {
            if (hoverValue.length === 1) {
              currentHoverTime = hoverValue[0].clone();
              nextHoverTime = func(currentHoverTime);
              nextHoverValue = onDayHover(nextHoverTime);
            } else {
              currentHoverTime = hoverValue[0].isSame(firstSelectedValue.value, 'day') ? hoverValue[1] : hoverValue[0];
              nextHoverTime = func(currentHoverTime);
              nextHoverValue = onDayHover(nextHoverTime);
            }
          } // Find origin hover time on value index


          if (nextHoverValue.length >= 2) {
            var miss = nextHoverValue.some(function (ht) {
              return !includesTime(value, ht, 'month');
            });

            if (miss) {
              var newValue = nextHoverValue.slice().sort(function (t1, t2) {
                return t1.valueOf() - t2.valueOf();
              });

              if (newValue[0].isSame(newValue[1], 'month')) {
                newValue[1] = newValue[0].clone().add(1, 'month');
              }

              fireValueChange(newValue);
            }
          } else if (nextHoverValue.length === 1) {
            // If only one value, let's keep the origin panel
            var oriValueIndex = value.findIndex(function (time) {
              return time.isSame(currentHoverTime, 'month');
            });

            if (oriValueIndex === -1) {
              oriValueIndex = 0;
            }

            if (value.every(function (time) {
              return !time.isSame(nextHoverTime, 'month');
            })) {
              var _newValue = value.slice();

              _newValue[oriValueIndex] = nextHoverTime.clone();
              fireValueChange(_newValue);
            }
          }

          event.preventDefault();
          return nextHoverTime;
        };

        switch (keyCode) {
          case keycode.DOWN:
            updateHoverPoint(function (time) {
              return toTime_goTime(time, 1, 'weeks');
            });
            return;

          case keycode.UP:
            updateHoverPoint(function (time) {
              return toTime_goTime(time, -1, 'weeks');
            });
            return;

          case keycode.LEFT:
            if (ctrlKey) {
              updateHoverPoint(function (time) {
                return toTime_goTime(time, -1, 'years');
              });
            } else {
              updateHoverPoint(function (time) {
                return toTime_goTime(time, -1, 'days');
              });
            }

            return;

          case keycode.RIGHT:
            if (ctrlKey) {
              updateHoverPoint(function (time) {
                return toTime_goTime(time, 1, 'years');
              });
            } else {
              updateHoverPoint(function (time) {
                return toTime_goTime(time, 1, 'days');
              });
            }

            return;

          case keycode.HOME:
            updateHoverPoint(function (time) {
              return goStartMonth(time);
            });
            return;

          case keycode.END:
            updateHoverPoint(function (time) {
              return goEndMonth(time);
            });
            return;

          case keycode.PAGE_DOWN:
            updateHoverPoint(function (time) {
              return toTime_goTime(time, 1, 'month');
            });
            return;

          case keycode.PAGE_UP:
            updateHoverPoint(function (time) {
              return toTime_goTime(time, -1, 'month');
            });
            return;

          case keycode.ENTER:
            {
              var lastValue;

              if (hoverValue.length === 0) {
                lastValue = updateHoverPoint(function (time) {
                  return time;
                });
              } else if (hoverValue.length === 1) {
                lastValue = hoverValue[0];
              } else {
                lastValue = hoverValue[0].isSame(firstSelectedValue, 'day') ? hoverValue[1] : hoverValue[0];
              }

              if (lastValue && (!disabledDate || !disabledDate(lastValue))) {
                onSelect(lastValue);
              }

              event.preventDefault();
              return;
            }

          default:
            emit('keydown', event);
        }
      },
      onDayHover: onDayHover,
      onToday: function onToday() {
        var startValue = getTodayTime(sValue.value[0]);
        var endValue = startValue.clone().add(1, 'months');
        sValue.value = [startValue, endValue];
      },
      onOpenTimePicker: function onOpenTimePicker() {
        sShowTimePicker.value = true;
      },
      onCloseTimePicker: function onCloseTimePicker() {
        sShowTimePicker.value = false;
      },
      onOk: function onOk() {
        if (isAllowedDateAndTime(sSelectedValue.value)) {
          emit('ok', sSelectedValue.value);
        }
      },
      onStartInputChange: function onStartInputChange() {
        for (var _len = arguments.length, oargs = new Array(_len), _key = 0; _key < _len; _key++) {
          oargs[_key] = arguments[_key];
        }

        var args = ['left'].concat(oargs);
        return onInputSelect.apply(void 0, toConsumableArray_default()(args));
      },
      onEndInputChange: function onEndInputChange() {
        for (var _len2 = arguments.length, oargs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          oargs[_key2] = arguments[_key2];
        }

        var args = ['right'].concat(oargs);
        return onInputSelect.apply(void 0, toConsumableArray_default()(args));
      },
      onStartInputSelect: function onStartInputSelect(value) {
        var args = ['left', value, {
          source: 'dateInputSelect'
        }];
        return onInputSelect.apply(void 0, args);
      },
      onEndInputSelect: function onEndInputSelect(value) {
        var args = ['right', value, {
          source: 'dateInputSelect'
        }];
        return onInputSelect.apply(void 0, args);
      },
      onStartValueChange: function onStartValueChange(leftValue) {
        var value = toConsumableArray_default()(sValue.value);

        value[0] = leftValue;
        return fireValueChange(value);
      },
      onEndValueChange: function onEndValueChange(rightValue) {
        var value = toConsumableArray_default()(sValue.value);

        value[1] = rightValue;
        return fireValueChange(value);
      },
      onStartPanelChange: function onStartPanelChange(value, mode) {
        var newMode = [mode, sMode.value[1]];
        var newValue = [value || sValue.value[0], sValue.value[1]];
        emit('panelChange', newValue, newMode);
        sPanelTriggerSource.value = 'start';

        if (props.mode === undefined) {
          sMode.value = newMode;
        }
      },
      onEndPanelChange: function onEndPanelChange(value, mode) {
        var newMode = [sMode.value[0], mode];
        var newValue = [sValue.value[0], value || sValue.value[1]];
        emit('panelChange', newValue, newMode);
        sPanelTriggerSource.value = 'start';

        if (props.mode === undefined) {
          sMode.value = newMode;
        }
      },
      getStartValue: getStartValue,
      getEndValue: function getEndValue() {
        var selectedValue = sSelectedValue.value;
        var showTimePicker = sShowTimePicker.value;
        var value = sValue.value;
        var mode = sMode.value;
        var panelTriggerSource = sPanelTriggerSource.value;
        var endValue = value[1] ? value[1].clone() : value[0].clone().add(1, 'month'); // keep selectedTime when select date

        if (selectedValue[1] && props.timePicker) {
          syncTime(selectedValue[1], endValue);
        }

        if (showTimePicker) {
          endValue = selectedValue[1] ? selectedValue[1] : getStartValue();
        } // Adjust month if date not align


        if (!showTimePicker && panelTriggerSource !== 'end' && mode[0] === 'date' && mode[1] === 'date' && endValue.isSame(value[0], 'month')) {
          endValue = endValue.clone().add(1, 'month');
        }

        return endValue;
      },
      // get disabled hours for second picker
      getEndDisableTime: function getEndDisableTime() {
        var selectedValue = sSelectedValue.value;
        var value = sValue.value;
        var disabledTime = props.disabledTime;
        var userSettingDisabledTime = disabledTime(selectedValue, 'end') || {};
        var startValue = selectedValue && selectedValue[0] || value[0].clone(); // if startTime and endTime is same day..
        // the second time picker will not able to pick time before first time picker

        if (!selectedValue[1] || startValue.isSame(selectedValue[1], 'day')) {
          var hours = startValue.hour();
          var minutes = startValue.minute();
          var second = startValue.second();
          var _disabledHours = userSettingDisabledTime.disabledHours,
              _disabledMinutes = userSettingDisabledTime.disabledMinutes,
              _disabledSeconds = userSettingDisabledTime.disabledSeconds;
          var oldDisabledMinutes = _disabledMinutes ? _disabledMinutes() : [];
          var olddisabledSeconds = _disabledSeconds ? _disabledSeconds() : [];
          _disabledHours = range_calendar_generateOptions(hours, _disabledHours);
          _disabledMinutes = range_calendar_generateOptions(minutes, _disabledMinutes);
          _disabledSeconds = range_calendar_generateOptions(second, _disabledSeconds);
          return {
            disabledHours: function disabledHours() {
              return _disabledHours;
            },
            disabledMinutes: function disabledMinutes(hour) {
              if (hour === hours) {
                return _disabledMinutes;
              }

              return oldDisabledMinutes;
            },
            disabledSeconds: function disabledSeconds(hour, minute) {
              if (hour === hours && minute === minutes) {
                return _disabledSeconds;
              }

              return olddisabledSeconds;
            }
          };
        }

        return userSettingDisabledTime;
      },
      isAllowedDateAndTime: isAllowedDateAndTime,
      isMonthYearPanelShow: function isMonthYearPanelShow(mode) {
        return ['month', 'year', 'decade'].indexOf(mode) > -1;
      },
      hasSelectedValue: hasSelectedValue,
      compare: compare,
      fireSelectValueChange: fireSelectValueChange,
      fireValueChange: fireValueChange,
      fireHoverValueChange: fireHoverValueChange,
      clear: function clear() {
        fireSelectValueChange([], true);
        emit('clear');
      },
      disabledStartTime: disabledStartTime,
      disabledEndTime: disabledEndTime,
      disabledStartMonth: function disabledStartMonth(month) {
        var value = sValue.value;
        return month.isAfter(value[1], 'month');
      },
      disabledEndMonth: function disabledEndMonth(month) {
        var value = sValue.value;
        return month.isBefore(value[0], 'month');
      }
    };
  },
  render: function render(ctx) {
    var _className, _cls;

    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var props = getOptionProps(instance);
    var prefixCls = props.prefixCls,
        dateInputPlaceholder = props.dateInputPlaceholder,
        timePicker = props.timePicker,
        showOk = props.showOk,
        locale = props.locale,
        showClear = props.showClear,
        showToday = props.showToday,
        type = props.type,
        seperator = props.seperator;
    var clearIcon = props_util_getComponentFromProp(instance, 'clearIcon');
    var sHoverValue = ctx.sHoverValue,
        sSelectedValue = ctx.sSelectedValue,
        mode = ctx.sMode,
        sShowTimePicker = ctx.sShowTimePicker,
        sValue = ctx.sValue;
    var className = (_className = {}, defineProperty_default()(_className, prefixCls, 1), defineProperty_default()(_className, "".concat(prefixCls, "-hidden"), !props.visible), defineProperty_default()(_className, "".concat(prefixCls, "-range"), 1), defineProperty_default()(_className, "".concat(prefixCls, "-show-time-picker"), sShowTimePicker), defineProperty_default()(_className, "".concat(prefixCls, "-week-number"), props.showWeekNumber), _className);
    var baseProps = Object.assign(Object.assign({}, props), getListenersFromInstance(instance));
    var newProps = {
      selectedValue: sSelectedValue,
      onSelect: this.onSelect,
      onDayHover: type === 'start' && sSelectedValue[1] || type === 'end' && sSelectedValue[0] || !!sHoverValue.length ? this.onDayHover : range_calendar_noop
    };
    var placeholder1;
    var placeholder2;

    if (dateInputPlaceholder) {
      if (Array.isArray(dateInputPlaceholder)) {
        var _dateInputPlaceholder = slicedToArray_default()(dateInputPlaceholder, 2);

        placeholder1 = _dateInputPlaceholder[0];
        placeholder2 = _dateInputPlaceholder[1];
      } else {
        placeholder1 = placeholder2 = dateInputPlaceholder;
      }
    }

    var showOkButton = showOk === true || showOk !== false && !!timePicker;
    var cls = (_cls = {}, defineProperty_default()(_cls, "".concat(prefixCls, "-footer"), true), defineProperty_default()(_cls, "".concat(prefixCls, "-range-bottom"), true), defineProperty_default()(_cls, "".concat(prefixCls, "-footer-show-ok"), showOkButton), _cls);
    var startValue = this.getStartValue();
    var endValue = this.getEndValue();
    var todayTime = getTodayTime(startValue);
    var thisMonth = todayTime.month();
    var thisYear = todayTime.year();
    var isTodayInView = startValue.year() === thisYear && startValue.month() === thisMonth || endValue.year() === thisYear && endValue.month() === thisMonth;
    var nextMonthOfStart = startValue.clone().add(1, 'months');
    var isClosestMonths = nextMonthOfStart.year() === endValue.year() && nextMonthOfStart.month() === endValue.month();
    var leftPartProps = mergeProps(baseProps, newProps, {
      hoverValue: sHoverValue,
      direction: 'left',
      disabledTime: this.disabledStartTime,
      disabledMonth: this.disabledStartMonth,
      format: this.getFormat(),
      value: startValue,
      mode: mode[0],
      placeholder: placeholder1,
      showDateInput: this.showDateInput,
      timePicker: timePicker,
      showTimePicker: sShowTimePicker || mode[0] === 'time',
      enablePrev: true,
      enableNext: !isClosestMonths || this.isMonthYearPanelShow(mode[1]),
      clearIcon: clearIcon,
      onInputChange: this.onStartInputChange,
      onInputSelect: this.onStartInputSelect,
      onValueChange: this.onStartValueChange,
      onPanelChange: this.onStartPanelChange
    });
    var rightPartProps = mergeProps(baseProps, newProps, {
      hoverValue: sHoverValue,
      direction: 'right',
      format: this.getFormat(),
      timePickerDisabledTime: this.getEndDisableTime(),
      placeholder: placeholder2,
      value: endValue,
      mode: mode[1],
      showDateInput: this.showDateInput,
      timePicker: timePicker,
      showTimePicker: sShowTimePicker || mode[1] === 'time',
      disabledTime: this.disabledEndTime,
      disabledMonth: this.disabledEndMonth,
      enablePrev: !isClosestMonths || this.isMonthYearPanelShow(mode[0]),
      enableNext: true,
      clearIcon: clearIcon,
      onInputChange: this.onEndInputChange,
      onInputSelect: this.onEndInputSelect,
      onValueChange: this.onEndValueChange,
      onPanelChange: this.onEndPanelChange
    });
    var TodayButtonNode = null;

    if (showToday) {
      var todayButtonProps = mergeProps(baseProps, {
        disabled: isTodayInView,
        value: sValue[0],
        text: locale.backToToday,
        onToday: this.onToday
      });
      TodayButtonNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(today_button, range_calendar_objectSpread({
        "key": "todayButton"
      }, todayButtonProps), []);
    }

    var TimePickerButtonNode = null;

    if (props.timePicker) {
      var timePickerButtonProps = mergeProps(baseProps, {
        showTimePicker: sShowTimePicker || mode[0] === 'time' && mode[1] === 'time',
        timePickerDisabled: !this.hasSelectedValue() || sHoverValue.length,
        onOpenTimePicker: this.onOpenTimePicker,
        onCloseTimePicker: this.onCloseTimePicker
      });
      TimePickerButtonNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(time_picker_button, range_calendar_objectSpread({
        "key": "timePickerButton"
      }, timePickerButtonProps), []);
    }

    var OkButtonNode = null;

    if (showOkButton) {
      var okButtonProps = mergeProps(baseProps, {
        okDisabled: !this.isAllowedDateAndTime(sSelectedValue) || !this.hasSelectedValue() || sHoverValue.length,
        onOk: this.onOk
      });
      OkButtonNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(ok_button, range_calendar_objectSpread({
        "key": "okButtonNode"
      }, okButtonProps), []);
    }

    var extraFooter = this.renderFooter(mode);
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "ref": "rootInstance",
      "class": className,
      "tabindex": 0,
      "onKeydown": this.onKeyDown
    }, [props.renderSidebar(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-panel")
    }, [showClear && sSelectedValue[0] && sSelectedValue[1] ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
      "role": "button",
      "title": locale.clear,
      "onClick": this.clear
    }, [clearIcon || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-clear-btn")
    }, [])]) : null, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-date-panel"),
      "onMouseleave": type !== 'both' ? this.onDatePanelLeave : range_calendar_noop,
      "onMouseenter": type !== 'both' ? this.onDatePanelEnter : range_calendar_noop
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(calendar_part, range_calendar_objectSpread({}, leftPartProps), []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-range-middle")
    }, [seperator]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(calendar_part, range_calendar_objectSpread({}, rightPartProps), [])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": cls
    }, [showToday || props.timePicker || showOkButton || extraFooter ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-footer-btn")
    }, [extraFooter, TodayButtonNode, TimePickerButtonNode, OkButtonNode]) : null])])]);
  }
});
/* harmony default export */ var range_calendar = (RangeCalendar);
// CONCATENATED MODULE: ./src/components/date-picker/input-icon.tsx




/* harmony default export */ var input_icon = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  functional: true,
  props: {
    prefixCls: String,
    suffixIcon: {}
  },
  components: {
    AIcon: components_icon
  },
  render: function render() {
    var _getCurrentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])(),
        props = _getCurrentInstance.props;

    var suffixIcon = props.suffixIcon,
        prefixCls = props.prefixCls;
    return (suffixIcon && isValidElement(suffixIcon) ? cloneElement(suffixIcon, {
      "class": "".concat(prefixCls, "-picker-icon")
    }) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-picker-icon")
    }, [suffixIcon])) || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
      "type": "calendar",
      "class": "".concat(prefixCls, "-picker-icon")
    }, []);
  }
}));
// CONCATENATED MODULE: ./src/components/date-picker/interface.tsx

 // import { TimePickerProps } from '../time-picker'


var interface_MomentType = {
  type: Object,
  validator: function validator(value) {
    return value === undefined || moment["isMoment"](value);
  }
};
var interface_PickerProps = function PickerProps() {
  return {
    name: vue_types.string,
    transitionName: vue_types.string,
    prefixCls: vue_types.string,
    inputPrefixCls: vue_types.string,
    format: vue_types.oneOfType([vue_types.string, vue_types.array]),
    disabled: vue_types.bool,
    allowClear: vue_types.bool,
    suffixIcon: vue_types.any,
    popupStyle: vue_types.object,
    dropdownClassName: vue_types.string,
    locale: vue_types.any,
    localeCode: vue_types.string,
    size: vue_types.oneOf(['large', 'small', 'default']),
    getCalendarContainer: vue_types.func,
    open: vue_types.bool,
    // onOpenChange: PropTypes.(status: bool) => void,
    disabledDate: vue_types.func,
    showToday: vue_types.bool,
    dateRender: vue_types.any,
    pickerClass: vue_types.string,
    pickerInputClass: vue_types.string,
    timePicker: vue_types.any,
    autoFocus: vue_types.bool,
    tagPrefixCls: vue_types.string,
    tabIndex: vue_types.oneOfType([vue_types.string, vue_types.number]),
    align: vue_types.object.def(function () {
      return {};
    })
  };
};
var interface_SinglePickerProps = function SinglePickerProps() {
  return {
    value: interface_MomentType,
    defaultValue: interface_MomentType,
    defaultPickerValue: interface_MomentType,
    renderExtraFooter: vue_types.any,
    placeholder: vue_types.string
  };
};
var interface_DatePickerProps = function DatePickerProps() {
  return Object.assign(Object.assign(Object.assign({}, interface_PickerProps()), interface_SinglePickerProps()), {
    showTime: vue_types.oneOfType([vue_types.object, vue_types.bool]),
    open: vue_types.bool,
    disabledTime: vue_types.func,
    // onOpenChange?: (status: bool) => void;
    // onOk?: (selectedTime: moment.Moment) => void;
    mode: vue_types.oneOf(['time', 'date', 'month', 'year'])
  });
};
var interface_MonthPickerProps = function MonthPickerProps() {
  return Object.assign(Object.assign(Object.assign({}, interface_PickerProps()), interface_SinglePickerProps()), {
    placeholder: vue_types.string,
    monthCellContentRender: vue_types.func
  });
};

function interface_isMomentArray(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || value.findIndex(function (val) {
      return val === undefined || moment["isMoment"](val);
    }) !== -1;
  }

  return false;
}

var RangePickerValue = vue_types.custom(interface_isMomentArray); // export const RangePickerPresetRange = PropTypes.oneOfType([RangePickerValue, PropTypes.func])

var interface_RangePickerProps = function RangePickerProps() {
  return Object.assign(Object.assign({}, interface_PickerProps()), {
    tagPrefixCls: vue_types.string,
    value: RangePickerValue,
    defaultValue: RangePickerValue,
    defaultPickerValue: RangePickerValue,
    timePicker: vue_types.any,
    // onChange?: (dates: RangePickerValue, dateStrings: [string, string]) => void;
    // onCalendarChange?: (dates: RangePickerValue, dateStrings: [string, string]) => void;
    // onOk?: (selectedTime: moment.Moment) => void;
    showTime: vue_types.oneOfType([vue_types.object, vue_types.bool]),
    ranges: vue_types.object,
    placeholder: vue_types.arrayOf(String),
    mode: vue_types.oneOfType([vue_types.string, vue_types.arrayOf(String)]),
    separator: vue_types.any,
    disabledTime: vue_types.func,
    showToday: vue_types.bool,
    renderExtraFooter: vue_types.any
  });
};
var interface_WeekPickerProps = function WeekPickerProps() {
  return Object.assign(Object.assign(Object.assign({}, interface_PickerProps()), interface_SinglePickerProps()), {
    placeholder: vue_types.string
  });
};
// CONCATENATED MODULE: ./src/components/date-picker/range-picker.tsx



function range_picker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function range_picker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { range_picker_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { range_picker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

















function range_picker_noop() {}

function getShowDateFromValue(value, mode) {
  var _value = slicedToArray_default()(value, 2),
      start = _value[0],
      end = _value[1]; // value could be an empty array, then we should not reset showDate


  if (!start && !end) {
    return;
  }

  if (mode && mode[0] === 'month') {
    return [start, end];
  }

  var newEnd = end && end.isSame(start, 'month') ? end.clone().add(1, 'month') : end;
  return [start, newEnd];
}

function pickerValueAdapter(value) {
  if (!value) {
    return;
  }

  if (Array.isArray(value)) {
    return value;
  }

  return [value, value.clone().add(1, 'month')];
}

function range_picker_isEmptyArray(arr) {
  if (Array.isArray(arr)) {
    return arr.length === 0 || arr.every(function (i) {
      return !i;
    });
  }

  return false;
}

function fixLocale(value, localeCode) {
  if (!localeCode) {
    return;
  }

  if (!value || value.length === 0) {
    return;
  }

  var _value2 = slicedToArray_default()(value, 2),
      start = _value2[0],
      end = _value2[1];

  if (start) {
    start.locale(localeCode);
  }

  if (end) {
    end.locale(localeCode);
  }
}

/* harmony default export */ var range_picker = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ARangePicker',
  props: initDefaultProps(interface_RangePickerProps(), {
    allowClear: true,
    showToday: false,
    separator: '~'
  }),
  data: function data() {},
  setup: function setup(props, _ref) {
    var _this = this;

    var emit = _ref.emit;

    var _useLocalValue = value_useLocalValue(props.defaultValue || []),
        sValue = _useLocalValue.value;

    var pickerValue = sValue.value || range_picker_isEmptyArray(sValue.value) ? props.defaultPickerValue : sValue.value;
    var sShowDate = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(pickerValueAdapter(pickerValue || interopDefault(moment)()));
    var sOpen = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(props.open);
    var sHoverValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])([]);
    var pickerRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var _prefixCls = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var _tagPrefixCls = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.open;
    }, function (val) {
      sOpen.value = val;
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return sOpen.value;
    }, function (val, oldVal) {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        if (props.open === undefined && oldVal && !val) {
          focus();
        }
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.value;
    }, function (val) {
      var value = val || [];

      if (!shallowequal_default()(val, sValue.value)) {
        sShowDate.value = getShowDateFromValue(value, props.mode) || sShowDate.value;
      }

      sValue.value = value;
    });

    var setValue = function setValue(value, hidePanel) {
      handleChange(value);

      if ((hidePanel || !props.showTime) && props.open === undefined) {
        sOpen.value = false;
      }
    };

    var clearSelection = function clearSelection(e) {
      e.preventDefault();
      e.stopPropagation();
      sValue.value = [];
      handleChange([]);
    };

    var clearHoverValue = function clearHoverValue() {
      sHoverValue.value = [];
    };

    var handleChange = function handleChange(value) {
      if (props.value === undefined) {
        sValue.value = value;
        sShowDate.value = getShowDateFromValue(value) || sShowDate.value;
      }

      if (value[0] && value[1] && value[0].diff(value[1]) > 0) {
        value[1] = undefined;
      }

      var _value3 = slicedToArray_default()(value, 2),
          start = _value3[0],
          end = _value3[1];

      emit('change', value, [formatDate(start, props.format), formatDate(end, props.format)]);
    };

    var handleOpenChange = function handleOpenChange(open) {
      if (props.open === undefined) {
        sOpen.value = open;
      }

      if (open === false) {
        clearHoverValue();
      }

      emit('openChange', open);
    };

    var handleShowDateChange = function handleShowDateChange(showDate) {
      sShowDate.value = showDate;
    };

    var handleHoverChange = function handleHoverChange(hoverValue) {
      sHoverValue.value = hoverValue;
    };

    var handleRangeMouseLeave = function handleRangeMouseLeave() {
      if (sOpen.value) {
        clearHoverValue();
      }
    };

    var handleCalendarInputSelect = function handleCalendarInputSelect(value) {
      var _value4 = slicedToArray_default()(value, 1),
          start = _value4[0];

      if (!start) {
        return;
      }

      sValue.value = value;
      sShowDate.value = getShowDateFromValue(value) || sShowDate.value;
    };

    var handleRangeClick = function handleRangeClick(value) {
      var copyValue = value;

      if (typeof value === 'function') {
        copyValue = value();
      }

      setValue(copyValue, true);
      emit('ok', copyValue);
      emit('openChange', false);
    };

    var onMouseEnter = function onMouseEnter(e) {
      emit('mouseenter', e);
    };

    var onMouseLeave = function onMouseLeave(e) {
      emit('mouseleave', e);
    };

    var focus = function focus() {
      pickerRef.value.focus();
    };

    var blur = function blur() {
      pickerRef.value.blur();
    };

    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var renderFooter = function renderFooter() {
      var ranges = props.ranges;
      var prefixCls = _prefixCls.value;
      var tagPrefixCls = _tagPrefixCls.value;
      var renderExtraFooter = props_util_getComponentFromProp(currentInstance, 'renderExtraFooter');

      if (!ranges && !renderExtraFooter) {
        return null;
      }

      var customFooter = renderExtraFooter ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": "".concat(prefixCls, "-footer-extra"),
        "key": "extra"
      }, [typeof renderExtraFooter === 'function' ? renderExtraFooter() : renderExtraFooter]) : null;
      var operations = ranges && Object.keys(ranges).map(function (range) {
        var value = ranges[range];
        var hoverValue = typeof value === 'function' ? value.call(_this) : value;
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_tag, {
          "key": range,
          "prefixCls": tagPrefixCls,
          "color": "blue",
          "onClick": function onClick() {
            return handleRangeClick(value);
          },
          "onMouseenter": function onMouseenter() {
            return sHoverValue.value = hoverValue;
          },
          "onMouseleave": handleRangeMouseLeave
        }, [range]);
      });
      var rangeNode = operations && operations.length > 0 ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": "".concat(prefixCls, "-footer-extra ").concat(prefixCls, "-range-quick-selector"),
        "key": "range"
      }, [operations]) : null;
      return [rangeNode, customFooter];
    };

    return {
      sValue: sValue,
      sOpen: sOpen,
      sHoverValue: sHoverValue,
      sShowDate: sShowDate,
      setValue: setValue,
      clearSelection: clearSelection,
      clearHoverValue: clearHoverValue,
      handleChange: handleChange,
      handleOpenChange: handleOpenChange,
      handleShowDateChange: handleShowDateChange,
      handleHoverChange: handleHoverChange,
      handleRangeMouseLeave: handleRangeMouseLeave,
      handleCalendarInputSelect: handleCalendarInputSelect,
      handleRangeClick: handleRangeClick,
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave,
      focus: focus,
      blur: blur,
      renderFooter: renderFooter,
      setPrefixCls: function setPrefixCls(prefixCls) {
        _prefixCls.value = prefixCls;
      },
      setTagPrefixCls: function setTagPrefixCls(prefixCls) {
        _tagPrefixCls.value = prefixCls;
      },
      setPickerRef: function setPickerRef(el) {
        pickerRef.value = el;
      }
    };
  },
  render: function render(ctx) {
    var _classNames,
        _this2 = this;

    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var props = getOptionProps(instance);
    var suffixIcon = getComponentFromContext(this, 'suffixIcon');
    suffixIcon = Array.isArray(suffixIcon) ? suffixIcon[0] : suffixIcon;
    var value = ctx.sValue,
        showDate = ctx.sShowDate,
        hoverValue = ctx.sHoverValue,
        open = ctx.sOpen;
    var listeners = getListenersFromInstance(instance);
    var _listeners$onCalendar = listeners.onCalendarChange,
        onCalendarChange = _listeners$onCalendar === void 0 ? range_picker_noop : _listeners$onCalendar,
        _listeners$onOk = listeners.onOk,
        onOk = _listeners$onOk === void 0 ? range_picker_noop : _listeners$onOk,
        _listeners$onFocus = listeners.onFocus,
        onFocus = _listeners$onFocus === void 0 ? range_picker_noop : _listeners$onFocus,
        _listeners$onBlur = listeners.onBlur,
        onBlur = _listeners$onBlur === void 0 ? range_picker_noop : _listeners$onBlur,
        _listeners$onPanelCha = listeners.onPanelChange,
        onPanelChange = _listeners$onPanelCha === void 0 ? range_picker_noop : _listeners$onPanelCha;
    var customizePrefixCls = props.prefixCls,
        customizeTagPrefixCls = props.tagPrefixCls,
        popupStyle = props.popupStyle,
        disabledDate = props.disabledDate,
        disabledTime = props.disabledTime,
        showTime = props.showTime,
        showToday = props.showToday,
        ranges = props.ranges,
        locale = props.locale,
        localeCode = props.localeCode,
        format = props.format,
        separator = props.separator;
    var configProvider = config_provider_useConfigProvider();
    var getPrefixCls = configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('calendar', customizePrefixCls);
    var tagPrefixCls = getPrefixCls('tag', customizeTagPrefixCls);
    ctx.setPrefixCls(prefixCls);
    ctx.setTagPrefixCls(tagPrefixCls);
    var dateRender = props_util_getComponentFromProp(instance, 'dateRender');
    fixLocale(value, localeCode);
    fixLocale(showDate, localeCode);
    var calendarClassName = classnames_default()((_classNames = {}, defineProperty_default()(_classNames, "".concat(prefixCls, "-time"), showTime), defineProperty_default()(_classNames, "".concat(prefixCls, "-range-with-ranges"), ranges), _classNames)); // 需要选择时间时，点击 ok 时才触发 onChange

    var pickerChangeHandler = {
      onChange: ctx.handleChange
    };
    var calendarProps = {
      onOk: this.handleChange
    };

    if (props.timePicker) {
      pickerChangeHandler.onChange = function (changedValue) {
        return _this2.handleChange(changedValue);
      };
    } else {
      calendarProps = {};
    }

    if ('mode' in props) {
      calendarProps.mode = props.mode;
    }

    var startPlaceholder = Array.isArray(props.placeholder) ? props.placeholder[0] : locale.lang.rangePlaceholder[0];
    var endPlaceholder = Array.isArray(props.placeholder) ? props.placeholder[1] : locale.lang.rangePlaceholder[1];
    var rangeCalendarProps = mergeProps(calendarProps, {
      separator: separator,
      format: format,
      prefixCls: prefixCls,
      renderFooter: this.renderFooter,
      timePicker: props.timePicker,
      disabledDate: disabledDate,
      disabledTime: disabledTime,
      dateInputPlaceholder: [startPlaceholder, endPlaceholder],
      locale: locale.lang,
      dateRender: dateRender,
      value: showDate,
      hoverValue: hoverValue,
      showToday: showToday,
      onChange: onCalendarChange,
      onOk: onOk,
      onValueChange: this.handleShowDateChange,
      onHoverChange: this.handleHoverChange,
      onPanelChange: onPanelChange,
      onInputSelect: this.handleCalendarInputSelect,
      "class": calendarClassName
    });
    var calendar = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(range_calendar, range_picker_objectSpread({}, rangeCalendarProps), []); // default width for showTime

    var pickerStyle = {};

    if (props.showTime) {
      pickerStyle.width = '350px';
    }

    var _value5 = slicedToArray_default()(value, 2),
        startValue = _value5[0],
        endValue = _value5[1];

    var clearIcon = !props.disabled && props.allowClear && value && (startValue || endValue) ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
      "type": "close-circle",
      "class": "".concat(prefixCls, "-picker-clear"),
      "onClick": this.clearSelection,
      "theme": "filled"
    }, []) : null;
    var inputIcon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(input_icon, {
      "suffixIcon": suffixIcon,
      "prefixCls": prefixCls
    }, []);

    var input = function input(_ref2) {
      var inputValue = _ref2.value;

      var _inputValue = slicedToArray_default()(inputValue, 2),
          start = _inputValue[0],
          end = _inputValue[1];

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": props.pickerInputClass
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", {
        "disabled": props.disabled,
        "readonly": true,
        "value": formatDate(start, props.format),
        "placeholder": startPlaceholder,
        "class": "".concat(prefixCls, "-range-picker-input"),
        "tabindex": -1
      }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-range-picker-separator")
      }, [" ", separator, " "]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", {
        "disabled": props.disabled,
        "readonly": true,
        "value": formatDate(end, props.format),
        "placeholder": endPlaceholder,
        "class": "".concat(prefixCls, "-range-picker-input"),
        "tabindex": -1
      }, []), clearIcon, inputIcon]);
    };

    var vcDatePickerProps = mergeProps(Object.assign(Object.assign({}, props), listeners), pickerChangeHandler, {
      calendar: calendar,
      value: value,
      open: open,
      prefixCls: "".concat(prefixCls, "-picker-container"),
      onOpenChange: this.handleOpenChange,
      style: popupStyle
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "ref": ctx.setPickerRef,
      "class": props.pickerClass,
      "style": pickerStyle,
      "tabindex": props.disabled ? -1 : 0,
      "onFocus": focus,
      "onBlur": blur,
      "onMouseenter": this.onMouseEnter,
      "onMouseleave": this.onMouseLeave
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(picker, range_picker_objectSpread({}, vcDatePickerProps), Object.assign(Object.assign({}, this.$slots), {
      "default": input
    }))]);
  }
}));
// CONCATENATED MODULE: ./src/components/date-picker/week-picker.tsx


function week_picker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function week_picker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { week_picker_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { week_picker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }











function formatValue(value, format) {
  return value && value.format(format) || '';
}

function week_picker_noop() {}

/* harmony default export */ var week_picker = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  // static defaultProps = {
  //   format: 'YYYY-wo',
  //   allowClear: true,
  // };
  // private input: any;
  name: 'AWeekPicker',
  props: initDefaultProps(interface_WeekPickerProps(), {
    format: 'gggg-wo',
    allowClear: true
  }),
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var _useLocalValue = value_useLocalValue(props.defaultValue),
        _value = _useLocalValue.value,
        setValue = _useLocalValue.setValue,
        afterValueSetAction = _useLocalValue.afterValueSetAction;

    var _useLocalValue2 = value_useLocalValue(props.open, 'open'),
        _open = _useLocalValue2.value,
        setOpen = _useLocalValue2.setValue,
        afterOpenSetAction = _useLocalValue2.afterValueSetAction;

    var prevState = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])({
      _value: _value.value,
      _open: _open.value
    });
    afterValueSetAction(function (value) {
      prevState.value = {
        _value: value,
        _open: _open.value
      };
    });
    afterOpenSetAction(function (value) {
      prevState.value = {
        _open: value,
        _value: _value.value
      };
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        if (!_open.value) {
          focus();
        }
      });
    });

    var handleChange = function handleChange(value) {
      setValue(value);
      emit('change', value, formatValue(value, props.format));
    };

    var _prefixCls = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var setPrefixCls = function setPrefixCls(prefix) {
      _prefixCls.value = prefix;
    };

    var inputRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var focus = function focus() {
      inputRef.value.focus();
    };

    var blur = function blur() {
      inputRef.value.blur();
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        if (!_open.value && prevState.value._open) {
          focus();
        }
      });
    });
    return {
      setPrefixCls: setPrefixCls,
      _value: _value,
      _open: _open,
      focus: focus,
      blur: blur,
      configProvider: config_provider_useConfigProvider(),
      weekDateRender: function weekDateRender(current) {
        var selectedValue = _value.value;
        var prefixCls = _prefixCls.value;
        var dateRender = props_util_getComponentFromProp(currentInstance, 'dateRender');
        var dateNode = dateRender ? dateRender(current) : current.date();

        if (selectedValue && current.year() === selectedValue.year() && current.week() === selectedValue.week()) {
          return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
            "class": "".concat(prefixCls, "-selected-day")
          }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
            "class": "".concat(prefixCls, "-date")
          }, [dateNode])]);
        }

        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
          "class": "".concat(prefixCls, "-date")
        }, [dateNode]);
      },
      handleChange: handleChange,
      handleOpenChange: function handleOpenChange(open) {
        setOpen(open);
        emit('openChange', open);
      },
      clearSelection: function clearSelection(e) {
        e.preventDefault();
        e.stopPropagation();
        handleChange(null);
      },
      renderFooter: function renderFooter() {
        var prefixCls = _prefixCls.value;
        var renderExtraFooter = props_util_getComponentFromProp(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])(), 'renderExtraFooter');
        return renderExtraFooter ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
          "class": "".concat(prefixCls, "-footer-extra")
        }, [renderExtraFooter.apply(void 0, arguments)]) : null;
      }
    };
  },
  render: function render(ctx) {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var props = getOptionProps(instance);
    var suffixIcon = getComponentFromContext(this, 'suffixIcon');
    suffixIcon = Array.isArray(suffixIcon) ? suffixIcon[0] : suffixIcon;
    var customizePrefixCls = props.prefixCls,
        disabled = props.disabled,
        pickerClass = props.pickerClass,
        popupStyle = props.popupStyle,
        pickerInputClass = props.pickerInputClass,
        format = props.format,
        allowClear = props.allowClear,
        locale = props.locale,
        localeCode = props.localeCode,
        disabledDate = props.disabledDate,
        defaultPickerValue = props.defaultPickerValue;
    var listeners = getListenersFromInstance(instance);
    var getPrefixCls = config_provider_useConfigProvider().getPrefixCls;
    var prefixCls = getPrefixCls('calendar', customizePrefixCls);
    ctx.setPrefixCls(prefixCls);
    var pickerValue = ctx._value,
        open = ctx._open;
    var _listeners$focus = listeners.focus,
        focus = _listeners$focus === void 0 ? week_picker_noop : _listeners$focus,
        _listeners$blur = listeners.blur,
        blur = _listeners$blur === void 0 ? week_picker_noop : _listeners$blur;

    if (pickerValue && localeCode) {
      pickerValue.locale(localeCode);
    }

    var placeholder = hasProp(instance, 'placeholder') ? props.placeholder : locale.lang.placeholder;
    var weekDateRender = props_util_getComponentFromProp(instance, 'weekDateRender');
    var calendar = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_calendar, {
      "showWeekNumber": true,
      "dateRender": weekDateRender,
      "prefixCls": prefixCls,
      "format": format,
      "locale": locale.lang,
      "showDateInput": false,
      "showToday": false,
      "disabledDate": disabledDate,
      "renderFooter": ctx.renderFooter,
      "defaultValue": defaultPickerValue
    }, []);
    var clearIcon = !disabled && allowClear && ctx._value ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
      "type": "close-circle",
      "class": "".concat(prefixCls, "-picker-clear"),
      "onClick": ctx.clearSelection,
      "theme": "filled"
    }, []) : null;
    var inputIcon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(input_icon, {
      "suffixIcon": suffixIcon,
      "prefixCls": prefixCls
    }, []);

    var input = function input(_ref2) {
      var value = _ref2.value;
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "style": {
          display: 'inline-block',
          width: '100%'
        }
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", {
        "ref": "input",
        "disabled": disabled,
        "readonly": true,
        "value": value && value.format(format) || '',
        "placeholder": placeholder,
        "class": pickerInputClass,
        "onFocus": focus,
        "onBlur": blur
      }, []), clearIcon, inputIcon]);
    };

    var vcDatePickerProps = Object.assign(Object.assign(Object.assign(Object.assign({}, props), {
      calendar: calendar,
      prefixCls: "".concat(prefixCls, "-picker-container"),
      value: pickerValue,
      open: open
    }), listeners), {
      onChange: this.handleChange,
      onOpenChange: this.handleOpenChange,
      style: popupStyle
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": pickerClass
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(picker, week_picker_objectSpread({}, vcDatePickerProps), Object.assign(Object.assign({}, this.$slots), {
      "default": input
    }))]);
  }
}));
// CONCATENATED MODULE: ./src/components/date-picker/index.tsx









var DatePicker = wrapPicker(Object.assign(Object.assign({}, createPicker(vc_calendar, interface_DatePickerProps())), {
  name: 'ADatePicker'
}), interface_DatePickerProps(), 'date');
var MonthPicker = wrapPicker(Object.assign(Object.assign({}, createPicker(month_calendar, interface_MonthPickerProps())), {
  name: 'AMonthPicker'
}), interface_MonthPickerProps(), 'month');
Object.assign(DatePicker, {
  RangePicker: wrapPicker(range_picker, interface_RangePickerProps(), 'date'),
  MonthPicker: MonthPicker,
  WeekPicker: wrapPicker(week_picker, interface_WeekPickerProps(), 'week')
});
/* istanbul ignore next */

DatePicker.install = function (Vue) {
  Vue.use(base);
  Vue.component(DatePicker.name, DatePicker);
  Vue.component(DatePicker.RangePicker.name, DatePicker.RangePicker);
  Vue.component(DatePicker.MonthPicker.name, DatePicker.MonthPicker);
  Vue.component(DatePicker.WeekPicker.name, DatePicker.WeekPicker);
};

/* harmony default export */ var date_picker = (DatePicker);
// CONCATENATED MODULE: ./src/components/grid/index.ts



/* harmony default export */ var components_grid = ({
  install: function install(app) {
    app.component(grid_row.name, grid_row);
    app.component(col.name, col);
  }
});

// CONCATENATED MODULE: ./src/components/_util/prefix.ts

var prefix_getPrefixCls = function getPrefixCls(cls, prefix) {
  if (prefix) {
    return prefix + cls;
  }

  return 'ant-' + cls;
};
// CONCATENATED MODULE: ./src/components/layout/layout.tsx



function layout_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function layout_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { layout_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { layout_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






var BasicProps = {
  prefixCls: vue_types.string,
  hasSider: vue_types.bool,
  tagName: vue_types.string
};

function generator(_ref) {
  var suffixCls = _ref.suffixCls,
      tagName = _ref.tagName,
      name = _ref.name;
  return function (BasicComponent) {
    return {
      name: name,
      props: BasicComponent.props,
      setup: function setup() {
        return {};
      },
      render: function render(ctx) {
        var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
        var attrs = instance.attrs;
        var customizePrefixCls = this.$props.prefixCls;
        var prefixCls = prefix_getPrefixCls(suffixCls, customizePrefixCls);
        var style = {};

        if (attrs.height) {
          style.height = attrs.height.toString();
        }

        var basicComponentProps = Object.assign(Object.assign(Object.assign(Object.assign({
          prefixCls: prefixCls
        }, getOptionProps(this)), {
          tagName: tagName
        }), getListenersFromInstance(instance)), {
          style: style
        });
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(BasicComponent, layout_objectSpread({}, basicComponentProps), [this.$slots["default"] && this.$slots["default"]()]);
      }
    };
  };
}

var Basic = {
  props: BasicProps,
  render: function render() {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var prefixCls = this.prefixCls,
        Tag = this.tagName,
        $slots = this.$slots;
    var divProps = Object.assign({
      "class": prefixCls
    }, getListenersFromInstance(instance));
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Tag, layout_objectSpread({}, divProps), [$slots["default"]()]);
  }
};
var BasicLayout = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: BasicProps,
  setup: function setup() {
    var siders = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])([]);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])('siderHook', {
      addSider: function addSider(id) {
        siders.value = [].concat(toConsumableArray_default()(siders.value), [id]);
      },
      removeSider: function removeSider(id) {
        siders.value = siders.value.filter(function (currentId) {
          return currentId !== id;
        });
      }
    });
    return {
      siders: siders
    };
  },
  render: function render() {
    var prefixCls = this.prefixCls,
        $slots = this.$slots,
        hasSider = this.hasSider,
        Tag = this.tagName;
    var divCls = classnames_default()(prefixCls, defineProperty_default()({}, "".concat(prefixCls, "-has-sider"), typeof hasSider === 'boolean' ? hasSider : this.siders.length > 0));
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var divProps = Object.assign({
      "class": divCls
    }, getListenersFromInstance(instance));
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Tag, layout_objectSpread({}, divProps), [$slots["default"] && $slots["default"]()]);
  }
});
var Layout = generator({
  suffixCls: 'layout',
  tagName: 'section',
  name: 'ALayout'
})(BasicLayout);
var layout_Header = generator({
  suffixCls: 'layout-header',
  tagName: 'header',
  name: 'ALayoutHeader'
})(Basic);
var Footer = generator({
  suffixCls: 'layout-footer',
  tagName: 'footer',
  name: 'ALayoutFooter'
})(Basic);
var Content = generator({
  suffixCls: 'layout-content',
  tagName: 'main',
  name: 'ALayoutContent'
})(Basic);
Layout.Header = layout_Header;
Layout.Footer = Footer;
Layout.Content = Content;
/* harmony default export */ var layout_layout = (Layout);
// CONCATENATED MODULE: ./src/components/_util/is-numeric.ts


var isNumeric = function isNumeric(value) {
  return !isNaN(parseFloat(value)) && isFinite(value);
};

/* harmony default export */ var is_numeric = (isNumeric);
// CONCATENATED MODULE: ./src/components/layout/sider.tsx







 // matchMedia polyfill for
// https://github.com/WickyNilliams/enquire.js/issues/82

if (typeof window !== 'undefined') {
  var matchMediaPolyfill = function matchMediaPolyfill(mediaQuery) {
    return {
      media: mediaQuery,
      matches: false,
      addListener: function addListener(listener) {},
      removeListener: function removeListener(listener) {}
    };
  };

  window.matchMedia = window.matchMedia || matchMediaPolyfill;
}

var dimensionMaxMap = {
  xs: '479.98px',
  sm: '575.98px',
  md: '767.98px',
  lg: '991.98px',
  xl: '1199.98px',
  xxl: '1599.98px'
}; // export type CollapseType = 'clickTrigger' | 'responsive';

var SiderProps = {
  prefixCls: vue_types.string,
  collapsible: vue_types.bool,
  collapsed: vue_types.bool,
  defaultCollapsed: vue_types.bool,
  reverseArrow: vue_types.bool,
  // onCollapse?: (collapsed: boolean, type: CollapseType) => void;
  zeroWidthTriggerStyle: vue_types.object,
  trigger: vue_types.any,
  width: vue_types.oneOfType([vue_types.number, vue_types.string]),
  collapsedWidth: vue_types.oneOfType([vue_types.number, vue_types.string]),
  breakpoint: vue_types.oneOf(['xs', 'sm', 'md', 'lg', 'xl', 'xxl']),
  theme: vue_types.oneOf(['light', 'dark']).def('dark')
}; // export interface SiderState {
//   collapsed?: boolean;
//   below: boolean;
//   belowShow?: boolean;
// }
// export interface SiderContext {
//   siderCollapsed: boolean;
// }

var generateId = function () {
  var i = 0;
  return function () {
    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    i += 1;
    return "".concat(prefix).concat(i);
  };
}();

var sider = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ALayoutSider',
  setup: function setup(declareProps, _ref) {
    var attrs = _ref.attrs,
        emit = _ref.emit;
    var props = Object.assign(Object.assign({}, declareProps), attrs);
    var uniqueId = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(generateId('ant-sider-'));
    var mql = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])({});
    var matchMedia = null;

    if (typeof window !== 'undefined') {
      matchMedia = window.matchMedia;
    }

    if (matchMedia !== null && props.breakpoint && props.breakpoint in dimensionMaxMap) {
      mql.value = matchMedia("(max-width: ".concat(dimensionMaxMap[props.breakpoint], ")"));
    }

    var sCollapsed = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);

    if ('collapsed' in props) {
      sCollapsed.value = props.collapsed;
    } else {
      sCollapsed.value = props.defaultCollapsed;
    }

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])('layoutSiderContext', {
      collapse: sCollapsed
    });
    var siderHook = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["inject"])('siderHook');
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.collapsed;
    }, function (value) {
      sCollapsed.value = value;
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        if (mql.value.addListener) {
          mql.value.addListener(responsiveHandler);
          responsiveHandler(mql.value);
        }

        if (siderHook === null || siderHook === void 0 ? void 0 : siderHook.addSider) {
          siderHook === null || siderHook === void 0 ? void 0 : siderHook.addSider(uniqueId.value);
        }
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      if (mql.value.removeListener !== undefined) {
        mql.value.removeListener(responsiveHandler);
      }

      if (siderHook === null || siderHook === void 0 ? void 0 : siderHook.removeSider) {
        siderHook === null || siderHook === void 0 ? void 0 : siderHook.removeSider(uniqueId.value);
      }
    });
    var below = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);

    var responsiveHandler = function responsiveHandler(mql) {
      below.value = mql.matches;
      emit('breakpoint', mql.matches);

      if (sCollapsed.value !== mql.matches) {
        setCollapsed(mql.matches, 'responsive');
      }
    };

    var setCollapsed = function setCollapsed(collapsed, type) {
      if (props.collapsed === undefined) {
        sCollapsed.value = collapsed;
      }

      emit('collapse', collapsed, type);
    };

    var toggle = function toggle() {
      var collapsed = !sCollapsed.value;
      setCollapsed(collapsed, 'clickTrigger');
    };

    var belowShow = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);

    var belowShowChange = function belowShowChange() {
      belowShow.value = !belowShow.value;
    };

    return {
      sCollapsed: sCollapsed,
      below: below,
      belowShow: belowShow,
      siderHook: siderHook,
      setCollapsed: setCollapsed,
      toggle: toggle,
      responsiveHandler: responsiveHandler,
      belowShowChange: belowShowChange
    };
  },
  model: {
    prop: 'collapsed',
    event: 'collapse'
  },
  props: initDefaultProps(SiderProps, {
    collapsible: false,
    defaultCollapsed: false,
    reverseArrow: false,
    width: 200,
    collapsedWidth: 80
  }),
  render: function render(ctx) {
    var _classNames;

    var _getOptionProps = getOptionProps(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])()),
        customizePrefixCls = _getOptionProps.prefixCls,
        theme = _getOptionProps.theme,
        collapsible = _getOptionProps.collapsible,
        reverseArrow = _getOptionProps.reverseArrow,
        width = _getOptionProps.width,
        collapsedWidth = _getOptionProps.collapsedWidth,
        zeroWidthTriggerStyle = _getOptionProps.zeroWidthTriggerStyle;

    var prefixCls = prefix_getPrefixCls('layout-sider', customizePrefixCls);
    var componentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var trigger = props_util_getComponentFromProp(componentInstance, 'trigger');
    var rawWidth = this.sCollapsed ? collapsedWidth : width; // use "px" as fallback unit for width

    var siderWidth = is_numeric(rawWidth) ? "".concat(rawWidth, "px") : String(rawWidth); // special trigger when collapsedWidth == 0

    var zeroWidthTrigger = parseFloat(String(collapsedWidth || 0)) === 0 ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "onClick": this.toggle,
      "class": "".concat(prefixCls, "-zero-width-trigger ").concat(prefixCls, "-zero-width-trigger-").concat(reverseArrow ? 'right' : 'left'),
      "style": zeroWidthTriggerStyle
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
      type: 'bars'
    })]) : null;
    var iconObj = {
      expanded: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": reverseArrow ? 'right' : 'left'
      }, []),
      collapsed: Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": reverseArrow ? 'left' : 'right'
      }, [])
    };
    var status = this.sCollapsed ? 'collapsed' : 'expanded';
    var defaultTrigger = iconObj[status];
    var triggerDom = trigger !== null ? zeroWidthTrigger || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-trigger"),
      "onClick": this.toggle,
      "style": {
        width: siderWidth
      }
    }, [trigger || defaultTrigger]) : null;
    var divStyle = {
      // ...style,
      flex: "0 0 ".concat(siderWidth),
      maxWidth: siderWidth,
      minWidth: siderWidth,
      width: siderWidth
    };
    var siderCls = classnames_default()(prefixCls, "".concat(prefixCls, "-").concat(theme), (_classNames = {}, defineProperty_default()(_classNames, "".concat(prefixCls, "-collapsed"), !!this.sCollapsed), defineProperty_default()(_classNames, "".concat(prefixCls, "-has-trigger"), collapsible && trigger !== null && !zeroWidthTrigger), defineProperty_default()(_classNames, "".concat(prefixCls, "-below"), !!this.below), defineProperty_default()(_classNames, "".concat(prefixCls, "-zero-width"), parseFloat(siderWidth) === 0), _classNames));
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("aside", {
      "class": siderCls,
      "style": divStyle
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-children")
    }, [this.$slots["default"] && this.$slots["default"]()]), collapsible || this.below && zeroWidthTrigger ? triggerDom : null]);
  }
});
/* harmony default export */ var layout_sider = (sider);
// CONCATENATED MODULE: ./src/components/layout/index.ts




layout_layout.Sider = layout_sider;
/* istanbul ignore next */

layout_layout.install = function (app) {
  app.use(base);
  app.component('ALayout', layout_layout);
  app.component(layout_layout.Header.name, layout_layout.Header);
  app.component(layout_layout.Footer.name, layout_layout.Footer);
  app.component(layout_layout.Sider.name, layout_layout.Sider);
  app.component(layout_layout.Content.name, layout_layout.Content);
};

/* harmony default export */ var components_layout = (layout_layout);
// CONCATENATED MODULE: ./src/components/_util/get-scroll-bar-size.ts

var cached;
function getScrollBarSize(fresh) {
  if (fresh || cached === undefined) {
    var inner = document.createElement('div');
    inner.style.width = '100%';
    inner.style.height = '200px';
    var outer = document.createElement('div');
    var outerStyle = outer.style;
    outerStyle.position = 'absolute';
    outerStyle.top = '0';
    outerStyle.left = '0';
    outerStyle.pointerEvents = 'none';
    outerStyle.visibility = 'hidden';
    outerStyle.width = '200px';
    outerStyle.height = '150px';
    outerStyle.overflow = 'hidden';
    outer.appendChild(inner);
    document.body.appendChild(outer);
    var widthContained = inner.offsetWidth;
    outer.style.overflow = 'scroll';
    var widthScroll = inner.offsetWidth;

    if (widthContained === widthScroll) {
      widthScroll = outer.clientWidth;
    }

    document.body.removeChild(outer);
    cached = widthContained - widthScroll;
  }

  return cached;
}
// CONCATENATED MODULE: ./src/components/_util/switch-scrolling-effect.ts


/* harmony default export */ var switch_scrolling_effect = (function (close) {
  var bodyIsOverflowing = document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;

  if (!bodyIsOverflowing) {
    return;
  }

  if (close) {
    document.body.style.position = '';
    document.body.style.width = '';
    return;
  }

  var scrollBarSize = getScrollBarSize();

  if (scrollBarSize) {
    document.body.style.position = 'relative';
    document.body.style.width = "calc(100% - ".concat(scrollBarSize, "px)");
  }
});
// CONCATENATED MODULE: ./src/components/vc-dialog/IDialogPropTypes.ts



function IDialogPropTypes() {
  return {
    keyboard: vue_types.bool,
    mask: vue_types.bool,
    afterClose: vue_types.func,
    // onClose: PropTypes. (e: SyntheticEvent<HTMLDivElement>) =>any,
    closable: vue_types.bool,
    maskClosable: vue_types.bool,
    visible: vue_types.bool,
    destroyOnClose: vue_types.bool,
    mousePosition: vue_types.shape({
      x: vue_types.number,
      y: vue_types.number
    }).loose,
    title: vue_types.any,
    footer: vue_types.any,
    transitionName: vue_types.string,
    maskTransitionName: vue_types.string,
    animation: vue_types.any,
    maskAnimation: vue_types.any,
    wrapStyle: vue_types.object,
    bodyStyle: vue_types.object,
    maskStyle: vue_types.object,
    prefixCls: vue_types.string,
    wrapClassName: vue_types.string,
    width: vue_types.oneOfType([vue_types.string, vue_types.number]),
    height: vue_types.oneOfType([vue_types.string, vue_types.number]),
    zIndex: vue_types.number,
    bodyProps: vue_types.any,
    maskProps: vue_types.any,
    wrapProps: vue_types.any,
    getContainer: vue_types.any,
    dialogStyle: vue_types.object.def(function () {
      return {};
    }),
    dialogClass: vue_types.object.def(function () {
      return {};
    }),
    closeIcon: vue_types.any,
    forceRender: vue_types.bool,
    getOpenCount: vue_types.func,
    // https://github.com/ant-design/ant-design/issues/19771
    // https://github.com/react-component/dialog/issues/95
    focusTriggerAfterClose: vue_types.bool
  };
}

/* harmony default export */ var vc_dialog_IDialogPropTypes = (IDialogPropTypes);
// CONCATENATED MODULE: ./src/components/vc-dialog/dialog.tsx


function dialog_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function dialog_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { dialog_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { dialog_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }








var dialog_IDialogPropTypes = vc_dialog_IDialogPropTypes();
var uuid = 0;

function dialog_noop() {}

function dialog_getScroll(w, top) {
  var ret = w["page".concat(top ? 'Y' : 'X', "Offset")];
  var method = "scroll".concat(top ? 'Top' : 'Left');

  if (typeof ret !== 'number') {
    var d = w.document;
    ret = d.documentElement[method];

    if (typeof ret !== 'number') {
      ret = d.body[method];
    }
  }

  return ret;
}

function setTransformOrigin(node, value) {
  var style = node.style;
  ['Webkit', 'Moz', 'Ms', 'ms'].forEach(function (prefix) {
    style["".concat(prefix, "TransformOrigin")] = value;
  });
  style["transformOrigin"] = value;
}

function dialog_offset(el) {
  var rect = el.getBoundingClientRect();
  var pos = {
    left: rect.left,
    top: rect.top
  };
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += dialog_getScroll(w);
  pos.top += dialog_getScroll(w, true);
  return pos;
}

var cacheOverflow = {};
/* harmony default export */ var dialog = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: initDefaultProps(dialog_IDialogPropTypes, {
    mask: true,
    visible: false,
    keyboard: true,
    closable: true,
    maskClosable: true,
    destroyOnClose: false,
    prefixCls: 'rc-dialog',
    getOpenCount: function getOpenCount() {
      return null;
    },
    focusTriggerAfterClose: true
  }),
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var destroyPopup = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var inTransition = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);
    var wrapRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var titleId = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])("rcDialogTitle".concat(uuid++));
    var dialogRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var openTime = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var lastOutSideFocusNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var sentinelStartRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var timeoutId = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var sentinelEndRef = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
    var dialogMouseDown = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);

    var setSentinelStart = function setSentinelStart(el) {
      sentinelStartRef.value = el;
    };

    var tryFocus = function tryFocus() {
      if (!contains(wrapRef.value, document.activeElement)) {
        lastOutSideFocusNode.value = document.activeElement;
        sentinelStartRef.value.focus();
      }
    };

    var onDialogMouseDown = function onDialogMouseDown() {
      dialogMouseDown.value = true;
    };

    var close = function close(e) {
      emit('close', e);
    };

    var getTransitionName = function getTransitionName() {
      var transitionName = props.transitionName;
      var animation = props.animation;

      if (!transitionName && animation) {
        transitionName = "".concat(props.prefixCls, "-").concat(animation);
      }

      return transitionName;
    };

    var getZIndexStyle = function getZIndexStyle() {
      var style = {};

      if (props.zIndex !== undefined) {
        style.zIndex = props.zIndex;
      }

      return style;
    };

    var onAnimateLeave = function onAnimateLeave() {
      var afterClose = props.afterClose,
          destroyOnClose = props.destroyOnClose; // need demo?
      // https://github.com/react-component/dialog/pull/28

      if (wrapRef.value) {
        wrapRef.value.style.display = 'none';
      }

      if (destroyOnClose) {
        destroyPopup.value = true;
      }

      inTransition.value = false;

      switch_scrolling_effect();

      if (afterClose) {
        afterClose();
      }
    };

    var getMaskStyle = function getMaskStyle() {
      return Object.assign(Object.assign({}, getZIndexStyle()), props.maskStyle);
    };

    var getMaskTransitionName = function getMaskTransitionName() {
      var transitionName = props.maskTransitionName;
      var animation = props.maskAnimation;

      if (!transitionName && animation) {
        transitionName = "".concat(props.prefixCls, "-").concat(animation);
      }

      return transitionName;
    };

    var updatedCallback = function updatedCallback(visible) {
      var mousePosition = props.mousePosition;
      var mask = props.mask,
          focusTriggerAfterClose = props.focusTriggerAfterClose;

      if (props.visible) {
        // first show
        if (!visible) {
          openTime.value = Date.now(); // this.lastOutSideFocusNode = document.activeElement

          switch_scrolling_effect(); // this.$refs.wrap.focus()


          tryFocus();
          var dialogNode = dialogRef.value;

          if (mousePosition) {
            var elOffset = dialog_offset(dialogNode);
            setTransformOrigin(dialogNode, "".concat(mousePosition.x - elOffset.left, "px ").concat(mousePosition.y - elOffset.top, "px"));
          } else {
            setTransformOrigin(dialogNode, '');
          }
        }
      } else if (visible) {
        inTransition.value = true;

        if (mask && lastOutSideFocusNode.value && focusTriggerAfterClose) {
          try {
            lastOutSideFocusNode.value.focus();
          } catch (e) {
            lastOutSideFocusNode.value = null;
          }

          lastOutSideFocusNode.value = null;
        }
      }
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["provide"])('dialogContext', instance);
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.visible;
    }, function (val) {
      if (val) {
        destroyPopup.value = false;
      }

      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        updatedCallback(!val);
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        updatedCallback(false); // if forceRender is true, set element style display to be none;

        if ((props.forceRender || props.getContainer === false && !props.visible) && wrapRef.value) {
          wrapRef.value.style.display = 'none';
        }
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      var visible = props.visible,
          getOpenCount = props.getOpenCount;

      if ((visible || inTransition.value) && !getOpenCount()) {
        switch_scrolling_effect();
      }

      clearTimeout(timeoutId.value);
    });
    return {
      destroyPopup: destroyPopup,
      // 对外暴露的 api 不要更改名称或删除
      updatedCallback: updatedCallback,
      tryFocus: tryFocus,
      onAnimateLeave: onAnimateLeave,
      onMaskMouseUp: function onMaskMouseUp() {
        if (dialogMouseDown.value) {
          timeoutId.value = setTimeout(function () {
            dialogMouseDown.value = false;
          }, 0);
        }
      },
      onMaskClick: function onMaskClick(e) {
        // android trigger click on open (fastclick??)
        if (Date.now() - openTime.value < 300) {
          return;
        }

        if (e.target === e.currentTarget && !dialogMouseDown.value) {
          close(e);
        }
      },
      onKeydown: function onKeydown(e) {
        if (props.keyboard && e.keyCode === keycode.ESC) {
          e.stopPropagation();
          close(e);
          return;
        } // keep focus inside dialog


        if (props.visible) {
          if (e.keyCode === keycode.TAB) {
            var activeElement = document.activeElement;
            var tmpSentinelStart = sentinelStartRef.value;

            if (e.shiftKey) {
              if (activeElement === tmpSentinelStart) {
                sentinelEndRef.value.focus();
              }
            } else if (activeElement === sentinelEndRef.value) {
              tmpSentinelStart.focus();
            }
          }
        }
      },
      getDialogElement: function getDialogElement() {
        var closable = props.closable,
            prefixCls = props.prefixCls,
            width = props.width,
            height = props.height,
            title = props.title,
            tempFooter = props.footer,
            bodyStyle = props.bodyStyle,
            visible = props.visible,
            bodyProps = props.bodyProps;
        var dest = {};

        if (width !== undefined) {
          dest.width = typeof width === 'number' ? "".concat(width, "px") : width;
        }

        if (height !== undefined) {
          dest.height = typeof height === 'number' ? "".concat(height, "px") : height;
        }

        var footer;

        if (tempFooter) {
          footer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
            "key": "footer",
            "class": "".concat(prefixCls, "-footer"),
            "ref": "footer"
          }, [tempFooter]);
        }

        var header;

        if (title) {
          header = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
            "key": "header",
            "class": "".concat(prefixCls, "-header"),
            "ref": "header"
          }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
            "class": "".concat(prefixCls, "-title"),
            "id": titleId.value
          }, [title])]);
        }

        var closer;

        if (closable) {
          var closeIcon = props_util_getComponentFromProp(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])(), 'closeIcon');
          closer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("button", {
            "type": "button",
            "key": "close",
            "onClick": close || dialog_noop,
            "aria-label": "Close",
            "class": "".concat(prefixCls, "-close")
          }, [closeIcon || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
            "class": "".concat(prefixCls, "-close-x")
          }, [])]);
        }

        var style = Object.assign(Object.assign({}, props.dialogStyle), dest);
        var sentinelStyle = {
          width: 0,
          height: 0,
          overflow: 'hidden'
        };
        var cls = Object.assign(defineProperty_default()({}, prefixCls, true), props.dialogClass);
        var transitionName = getTransitionName();
        var dialogElement = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
          "key": "dialog-element",
          "role": "document",
          "ref": function ref(el) {
            return dialogRef.value = el;
          },
          "style": style,
          "class": cls,
          "onMousedown": onDialogMouseDown
        }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
          "tabindex": 0,
          "ref": setSentinelStart,
          "style": sentinelStyle,
          "aria-hidden": "true"
        }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
          "class": "".concat(prefixCls, "-content")
        }, [closer, header, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", dialog_objectSpread({
          "key": "body",
          "class": "".concat(prefixCls, "-body"),
          "style": bodyStyle,
          "ref": "body"
        }, bodyProps), [slots["default"] && slots["default"]()]), footer]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
          "tabindex": 0,
          "ref": function ref(el) {
            return sentinelEndRef.value = el;
          },
          "style": sentinelStyle,
          "aria-hidden": "true"
        }, [])]), [[external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], visible]]);
        var dialogTransitionProps = get_transition_props(transitionName, {
          onAfterLeave: onAnimateLeave
        });
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], dialog_objectSpread({
          "key": "dialog"
        }, dialogTransitionProps), [visible || !destroyPopup.value ? dialogElement : null]);
      },
      getWrapStyle: function getWrapStyle() {
        return Object.assign(Object.assign({}, getZIndexStyle()), props.wrapStyle);
      },
      getMaskElement: function getMaskElement() {
        var maskElement;

        if (props.mask) {
          var maskTransition = getMaskTransitionName();
          maskElement = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
            "style": getMaskStyle(),
            "key": "mask",
            "class": "".concat(props.prefixCls, "-mask")
          }, []), [[external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], props.visible]]);

          if (maskTransition) {
            var maskTransitionProps = get_transition_props(maskTransition);
            maskElement = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], dialog_objectSpread({
              "key": "mask"
            }, maskTransitionProps), [maskElement]);
          }
        }

        return maskElement;
      },
      getTransitionName: getTransitionName,
      // setScrollbar() {
      //   if (this.bodyIsOverflowing && this.scrollbarWidth !== undefined) {
      //     document.body.style.paddingRight = `${this.scrollbarWidth}px`;
      //   }
      // },
      switchScrollingEffect: function switchScrollingEffect() {
        var getOpenCount = props.getOpenCount;
        var openCount = getOpenCount();

        if (openCount === 1) {
          if (cacheOverflow.hasOwnProperty('overflowX')) {
            return;
          }

          cacheOverflow = {
            overflowX: document.body.style.overflowX,
            overflowY: document.body.style.overflowY,
            overflow: document.body.style.overflow
          };

          switch_scrolling_effect(); // Must be set after switchScrollingEffect


          document.body.style.overflow = 'hidden';
        } else if (!openCount) {
          // IE browser doesn't merge overflow style, need to set it separately
          // https://github.com/ant-design/ant-design/issues/19393
          if (cacheOverflow.overflow !== undefined) {
            document.body.style.overflow = cacheOverflow.overflow;
          }

          if (cacheOverflow.overflowX !== undefined) {
            document.body.style.overflowX = cacheOverflow.overflowX;
          }

          if (cacheOverflow.overflowY !== undefined) {
            document.body.style.overflowY = cacheOverflow.overflowY;
          }

          cacheOverflow = {};

          switch_scrolling_effect(true);
        }
      },
      // removeScrollingEffect() {
      //   const { getOpenCount } = this;
      //   const openCount = getOpenCount();
      //   if (openCount !== 0) {
      //     return;
      //   }
      //   document.body.style.overflow = '';
      //   switchScrollingEffect(true);
      //   // this.resetAdjustments();
      // },
      close: close,
      setWrap: function setWrap(el) {
        wrapRef.value = el;
      },
      titleId: titleId
    };
  },
  render: function render(ctx) {
    var prefixCls = this.prefixCls,
        maskClosable = this.maskClosable,
        visible = this.visible,
        wrapClassName = this.wrapClassName,
        title = this.title,
        wrapProps = this.wrapProps;
    var style = this.getWrapStyle(); // clear hide display
    // and only set display after async anim, not here for hide

    if (visible) {
      style.display = null;
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": "".concat(prefixCls, "-root")
    }, [this.getMaskElement(), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["withDirectives"])(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", dialog_objectSpread({
      "tabIndex": -1,
      "onKeydown": this.onKeydown,
      "class": "".concat(prefixCls, "-wrap ").concat(wrapClassName || ''),
      "ref": ctx.setWrap,
      "onClick": maskClosable ? this.onMaskClick : dialog_noop,
      "onMouseup": maskClosable ? this.onMaskMouseUp : dialog_noop,
      "role": "dialog",
      "aria-labelledby": title ? ctx.titleId : null,
      "style": style
    }, wrapProps), [this.getDialogElement()]), [[external_commonjs_vue_commonjs2_vue_root_Vue_["vShow"], ctx.visible]])]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-dialog/dialog-wrap.tsx


function dialog_wrap_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function dialog_wrap_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { dialog_wrap_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { dialog_wrap_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }





var dialog_wrap_IDialogPropTypes = vc_dialog_IDialogPropTypes();
var dialog_wrap_openCount = 0;
var DialogWrap = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  inheritAttrs: false,
  props: Object.assign(Object.assign({}, dialog_wrap_IDialogPropTypes), {
    visible: dialog_wrap_IDialogPropTypes.visible.def(false)
  }),
  setup: function setup(props, _ref) {
    var attrs = _ref.attrs,
        slots = _ref.slots;
    dialog_wrap_openCount = props.visible ? dialog_wrap_openCount + 1 : dialog_wrap_openCount;
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return props.visible;
    }, function (val, preVal) {
      dialog_wrap_openCount = val && !preVal ? dialog_wrap_openCount + 1 : dialog_wrap_openCount - 1;
    });
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    return {
      getComponent: function getComponent() {
        var extra = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var dialogProps = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, props), {
          dialogClass: getClassFromInstance(instance),
          dialogStyle: getStyleFromInstance(instance)
        }), extra), {
          getOpenCount: props.getContainer === false ? function () {
            return 2;
          } : function () {
            return dialog_wrap_openCount;
          }
        }), attrs), {
          ref: '_component',
          key: 'dialog'
        }), getListenersFromInstance(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])()));
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(dialog, dialog_wrap_objectSpread({}, dialogProps), [slots["default"]()]);
      }
    };
  },
  render: function render() {
    var container = this.getContainer(); // @ts-ignore

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Teleport"], {
      "to": container
    }, [this.getComponent()]);
  }
});
/* harmony default export */ var dialog_wrap = (DialogWrap);
// CONCATENATED MODULE: ./src/components/vc-dialog/index.ts

// based on vc-dialog 7.5.14

/* harmony default export */ var vc_dialog = (dialog_wrap);
// CONCATENATED MODULE: ./src/components/modal/modal.tsx


function modal_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function modal_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { modal_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { modal_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }














var ButtonType = buttonTypes().type;
var modal_mousePosition = null; // ref: https://github.com/ant-design/ant-design/issues/15795

var getClickPosition = function getClickPosition(e) {
  modal_mousePosition = {
    x: e.pageX,
    y: e.pageY
  }; // 100ms 内发生过点击事件，则从点击位置动画展示
  // 否则直接 zoom 展示
  // 这样可以兼容非点击方式展开

  setTimeout(function () {
    return modal_mousePosition = null;
  }, 100);
}; // 只有点击事件支持从鼠标位置动画展开


if (typeof window !== 'undefined' && window.document && window.document.documentElement) {
  addEventListenerWrap(document.documentElement, 'click', getClickPosition, true);
}

function modal_noop() {}

var modal_modalProps = function modalProps() {
  var defaultProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var props = {
    prefixCls: vue_types.string,

    /** 对话框是否可见*/
    visible: vue_types.bool,

    /** 确定按钮 loading*/
    confirmLoading: vue_types.bool,

    /** 标题*/
    title: vue_types.any,

    /** 是否显示右上角的关闭按钮*/
    closable: vue_types.bool,
    closeIcon: vue_types.any,

    /** 点击确定回调*/
    // onOk: (e: React.MouseEvent<any>) => void,

    /** 点击模态框右上角叉、取消按钮、Props.maskClosable 值为 true 时的遮罩层或键盘按下 Esc 时的回调*/
    // onCancel: (e: React.MouseEvent<any>) => void,
    afterClose: vue_types.func.def(modal_noop),

    /** 垂直居中 */
    centered: vue_types.bool,

    /** 宽度*/
    width: vue_types.oneOfType([vue_types.string, vue_types.number]),

    /** 底部内容*/
    footer: vue_types.any,

    /** 确认按钮文字*/
    okText: vue_types.any,

    /** 确认按钮类型*/
    okType: ButtonType,

    /** 取消按钮文字*/
    cancelText: vue_types.any,
    icon: vue_types.any,

    /** 点击蒙层是否允许关闭*/
    maskClosable: vue_types.bool,

    /** 强制渲染 Modal*/
    forceRender: vue_types.bool,
    okButtonProps: vue_types.object,
    cancelButtonProps: vue_types.object,
    destroyOnClose: vue_types.bool,
    wrapClassName: vue_types.string,
    maskTransitionName: vue_types.string,
    transitionName: vue_types.string,
    getContainer: vue_types.func,
    zIndex: vue_types.number,
    bodyStyle: vue_types.object,
    maskStyle: vue_types.object,
    mask: vue_types.bool,
    keyboard: vue_types.bool,
    wrapProps: vue_types.object,
    focusTriggerAfterClose: vue_types.bool
  };
  return initDefaultProps(props, defaultProps);
};

var destroyFns = [];
/* harmony default export */ var modal = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AModal',
  props: modal_modalProps({
    width: 520,
    transitionName: 'zoom',
    maskTransitionName: 'fade',
    confirmLoading: false,
    visible: false,
    okType: 'primary'
  }),
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var _useLocalValue = value_useLocalValue(!!props.visible, 'visible'),
        sVisible = _useLocalValue.value,
        setVisible = _useLocalValue.setValue;

    var handleCancel = function handleCancel(e) {
      setVisible(false);
      emit('cancel', e);
      emit('change', false);
    };

    var handleOk = function handleOk(e) {
      emit('ok', e);
    };

    var renderFooter = function renderFooter(locale) {
      var okType = props.okType,
          confirmLoading = props.confirmLoading;
      var cancelBtnProps = mergeProps({
        onClick: handleCancel
      }, props.cancelButtonProps || {});
      var okBtnProps = mergeProps({
        onClick: handleOk,
        type: okType,
        loading: confirmLoading
      }, props.okButtonProps || {});
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {}, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_button, modal_objectSpread({}, cancelBtnProps), [props_util_getComponentFromProp(instance, 'cancelText') || locale.cancelText]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_button, modal_objectSpread({}, okBtnProps), [props_util_getComponentFromProp(instance, 'okText') || locale.okText])]);
    };

    return {
      sVisible: sVisible,
      configProvider: config_provider_useConfigProvider(),
      handleCancel: handleCancel,
      handleOk: handleOk,
      renderFooter: renderFooter
    };
  },
  render: function render(ctx) {
    var currentInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var slots = this.$slots;
    var customizePrefixCls = ctx.prefixCls,
        visible = ctx.sVisible,
        wrapClassName = ctx.wrapClassName,
        centered = ctx.centered,
        getContainer = ctx.getContainer,
        $slots = ctx.$slots,
        $attrs = ctx.$attrs;
    var children = slots["default"] ? slots["default"]() : $slots["default"];
    var _this$configProvider = this.configProvider,
        getPrefixCls = _this$configProvider.getPrefixCls,
        getContextPopupContainer = _this$configProvider.getPopupContainer;
    var prefixCls = getPrefixCls('modal', customizePrefixCls);
    var defaultFooter = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(locale_receiver, {
      "componentName": "Modal",
      "defaultLocale": getConfirmLocale()
    }, {
      "default": this.renderFooter
    });
    var closeIcon = props_util_getComponentFromProp(currentInstance, 'closeIcon');
    var closeIconToRender = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-close-x")
    }, [closeIcon || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
      "class": "".concat(prefixCls, "-close-icon"),
      "type": 'close'
    }, [])]);
    var footer = props_util_getComponentFromProp(currentInstance, 'footer');
    var title = props_util_getComponentFromProp(currentInstance, 'title');
    var dialogProps = Object.assign(Object.assign(Object.assign(Object.assign({}, this.$props), {
      getContainer: getContainer === undefined ? getContextPopupContainer : getContainer,
      prefixCls: prefixCls,
      wrapClassName: classnames_default()(defineProperty_default()({}, "".concat(prefixCls, "-centered"), !!centered), wrapClassName),
      title: title,
      footer: footer === undefined ? defaultFooter : footer,
      visible: visible,
      mousePosition: modal_mousePosition,
      closeIcon: closeIconToRender
    }), getListenersFromInstance(currentInstance)), {
      onClose: this.handleCancel,
      "class": getClassFromInstance(currentInstance),
      style: getStyleFromInstance(currentInstance),
      attrs: $attrs
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_dialog, modal_objectSpread({}, dialogProps), [children]);
  }
}));
// CONCATENATED MODULE: ./src/components/modal/action-button.tsx


function action_button_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function action_button_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { action_button_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { action_button_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






var action_button_ButtonType = buttonTypes().type;
var ActionButtonProps = {
  type: action_button_ButtonType,
  actionFn: vue_types.func,
  closeModal: vue_types.func,
  autoFocus: vue_types.bool,
  buttonProps: vue_types.object
};
/* harmony default export */ var action_button = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: ActionButtonProps,
  setup: function setup($props, _ref) {
    var emit = _ref.emit;
    var loading = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);

    var onClick = function onClick() {
      var actionFn = $props.actionFn,
          closeModal = $props.closeModal;

      if (actionFn) {
        var ret;

        if (actionFn.length) {
          ret = actionFn(closeModal);
        } else {
          ret = actionFn();

          if (!ret) {
            closeModal();
          }
        }

        if (ret && ret.then) {
          loading.value = true;
          ret.then(function () {
            // It's unnecessary to set loading=false, for the Modal will be unmounted after close.
            // this.setState({ loading: false });
            closeModal.apply(void 0, arguments);
          }, function (e) {
            // Emit error when catch promise reject
            // eslint-disable-next-line no-console
            console.error(e); // See: https://github.com/ant-design/ant-design/issues/6183

            loading.value = false;
          });
        }
      } else {
        closeModal();
      }
    };

    var timeoutId = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var _useRefs = save_ref_useRefs(),
        getRef = _useRefs.getRef,
        saveRef = _useRefs.saveRef;

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      if ($props.autoFocus) {
        timeoutId.value = setTimeout(function () {
          return getRef('root').el.focus();
        });
      }
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      clearTimeout(timeoutId.value);
    });
    return {
      onClick: onClick,
      loading: loading,
      saveRef: saveRef
    };
  },
  render: function render() {
    var type = this.type,
        $slots = this.$slots,
        loading = this.loading,
        buttonProps = this.buttonProps;
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_button, action_button_objectSpread({
      "ref": this.saveRef('root'),
      "type": type,
      "onClick": this.onClick,
      "loading": loading
    }, buttonProps), [$slots["default"]()]);
  }
}));
// CONCATENATED MODULE: ./src/components/modal/confirm-dialog.tsx








/* harmony default export */ var confirm_dialog = (function (props, _ref) {
  var attrs = _ref.attrs;
  var context = Object.assign(Object.assign({}, props), attrs);
  var onCancel = context.onCancel,
      onOk = context.onOk,
      close = context.close,
      zIndex = context.zIndex,
      afterClose = context.afterClose,
      visible = context.visible,
      keyboard = context.keyboard,
      centered = context.centered,
      getContainer = context.getContainer,
      maskStyle = context.maskStyle,
      okButtonProps = context.okButtonProps,
      cancelButtonProps = context.cancelButtonProps,
      _context$iconType = context.iconType,
      iconType = _context$iconType === void 0 ? 'question-circle' : _context$iconType,
      _context$closable = context.closable,
      closable = _context$closable === void 0 ? false : _context$closable;
  _util_warning(!('iconType' in props), 'Modal', "The property 'iconType' is deprecated. Use the property 'icon' instead.");
  var icon = context.icon ? context.icon : iconType;
  var okType = context.okType || 'primary';
  var prefixCls = context.prefixCls || 'ant-modal';
  var contentPrefixCls = "".concat(prefixCls, "-confirm"); // 默认为 true，保持向下兼容

  var okCancel = 'okCancel' in props ? context.okCancel : true;
  var width = context.width || 416;
  var style = context.style || {};
  var mask = context.mask === undefined ? true : context.mask; // 默认为 false，保持旧版默认行为

  var maskClosable = context.maskClosable === undefined ? false : context.maskClosable;
  var runtimeLocale = getConfirmLocale();
  var okText = context.okText || (okCancel ? runtimeLocale.okText : runtimeLocale.justOkText);
  var cancelText = context.cancelText || runtimeLocale.cancelText;
  var autoFocusButton = context.autoFocusButton === null ? false : context.autoFocusButton || 'ok';
  var transitionName = context.transitionName || 'zoom';
  var maskTransitionName = context.maskTransitionName || 'fade';
  var classString = classnames_default()(contentPrefixCls, "".concat(contentPrefixCls, "-").concat(context.type), "".concat(prefixCls, "-").concat(context.type), context["class"]);
  var cancelButton = okCancel && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(action_button, {
    "actionFn": onCancel,
    "closeModal": close,
    "autoFocus": autoFocusButton === 'cancel',
    "buttonProps": cancelButtonProps
  }, [cancelText]);
  var iconNode = typeof icon === 'string' ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
    "type": icon
  }, []) : icon();
  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(modal, {
    "prefixCls": prefixCls,
    "class": classString,
    "wrapClassName": classnames_default()(defineProperty_default()({}, "".concat(contentPrefixCls, "-centered"), !!centered)),
    "onCancel": function onCancel(e) {
      return close({
        triggerCancel: true
      }, e);
    },
    "visible": visible,
    "closable": closable,
    "title": "",
    "transitionName": transitionName,
    "footer": "",
    "maskTransitionName": maskTransitionName,
    "mask": mask,
    "maskClosable": maskClosable,
    "maskStyle": maskStyle,
    "style": style,
    "width": width,
    "zIndex": zIndex,
    "afterClose": afterClose,
    "keyboard": keyboard,
    "centered": centered,
    "getContainer": getContainer
  }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
    "class": "".concat(contentPrefixCls, "-body-wrapper")
  }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
    "class": "".concat(contentPrefixCls, "-body")
  }, [iconNode, context.title === undefined ? null : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
    "class": "".concat(contentPrefixCls, "-title")
  }, [context.title]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
    "class": "".concat(contentPrefixCls, "-content")
  }, [typeof context.content === 'function' ? context.content() : context.content])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
    "class": "".concat(contentPrefixCls, "-btns")
  }, [cancelButton, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(action_button, {
    "type": okType,
    "actionFn": onOk,
    "closeModal": close,
    "autoFocus": autoFocusButton === 'ok',
    "buttonProps": okButtonProps
  }, [okText])])])]);
});
// CONCATENATED MODULE: ./src/components/modal/confirm.tsx


function confirm_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function confirm_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { confirm_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { confirm_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }





function confirm_confirm(config) {
  var div = document.createElement('div');
  var el = document.createElement('div');
  div.appendChild(el);
  document.body.appendChild(div);
  var currentConfig = Object.assign(Object.assign({}, es(config, ['parentContext'])), {
    close: close,
    visible: true
  });
  var confirmDialogInstance = null;
  var confirmDialogProps = {};

  function close() {
    destroy.apply(void 0, arguments);
  }

  function update(newConfig) {
    currentConfig = Object.assign(Object.assign({}, currentConfig), newConfig);
    Object.assign(confirmDialogProps, currentConfig);
  }

  function destroy() {
    if (confirmDialogInstance && div.parentNode) {
      confirmDialogInstance.unmount();
      confirmDialogInstance = null;
      div.parentNode.removeChild(div);
    }

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var triggerCancel = args.some(function (param) {
      return param && param.triggerCancel;
    });

    if (config.onCancel && triggerCancel) {
      config.onCancel.apply(config, args);
    }

    for (var i = 0; i < destroyFns.length; i++) {
      var fn = destroyFns[i];

      if (fn === close) {
        destroyFns.splice(i, 1);
        break;
      }
    }
  }

  function render(props) {
    var finalProps = Object.assign({}, confirmDialogProps, props);
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(confirm_dialog, confirm_objectSpread({}, finalProps), []);
  }

  confirmDialogInstance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["createApp"])(render, Object.assign(Object.assign({}, currentConfig), {
    getContainer: function getContainer() {
      return el;
    }
  }));

  confirmDialogInstance.config.warnHandler = function (m) {};

  confirmDialogInstance.mount(el);
  destroyFns.push(close);
  return {
    destroy: close,
    update: update
  };
}
// CONCATENATED MODULE: ./src/components/modal/index.tsx






var modal_info = function info(props) {
  var config = Object.assign({
    type: 'info',
    icon: function icon() {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "info-circle"
      }, []);
    },
    okCancel: false
  }, props);
  return confirm_confirm(config);
};

var modal_success = function success(props) {
  var config = Object.assign({
    type: 'success',
    icon: function icon() {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "check-circle"
      }, []);
    },
    okCancel: false
  }, props);
  return confirm_confirm(config);
};

var modal_error = function error(props) {
  var config = Object.assign({
    type: 'error',
    icon: function icon() {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "close-circle"
      }, []);
    },
    okCancel: false
  }, props);
  return confirm_confirm(config);
};

var modal_warning = function warning(props) {
  var config = Object.assign({
    type: 'warning',
    icon: function icon() {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "exclamation-circle"
      }, []);
    },
    okCancel: false
  }, props);
  return confirm_confirm(config);
};

var modal_warn = modal_warning;

var modal_confirm = function confirm(props) {
  var config = Object.assign({
    type: 'confirm',
    okCancel: true
  }, props);
  return confirm_confirm(config);
};

modal.info = modal_info;
modal.success = modal_success;
modal.error = modal_error;
modal.warning = modal_warning;
modal.warn = modal_warn;
modal.confirm = modal_confirm;

modal.destroyAll = function destroyAllFn() {
  while (destroyFns.length) {
    var close = destroyFns.pop();

    if (close) {
      close();
    }
  }
};
/* istanbul ignore next */


modal.install = function (Vue) {
  Vue.use(base);
  Vue.component(modal.name, modal);
};

/* harmony default export */ var components_modal = (modal);
// CONCATENATED MODULE: ./src/components/vc-pagination/keycode.ts

/* harmony default export */ var vc_pagination_keycode = ({
  ZERO: 48,
  NINE: 57,
  NUMPAD_ZERO: 96,
  NUMPAD_NINE: 105,
  BACKSPACE: 8,
  DELETE: 46,
  ENTER: 13,
  ARROW_UP: 38,
  ARROW_DOWN: 40
});
// CONCATENATED MODULE: ./src/components/vc-pagination/options.tsx



/* harmony default export */ var vc_pagination_options = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: {
    disabled: vue_types.bool,
    changeSize: vue_types.func,
    quickGo: vue_types.func,
    selectComponentClass: vue_types.any,
    current: vue_types.number,
    pageSizeOptions: vue_types.array.def(['10', '20', '30', '40']),
    pageSize: vue_types.number,
    buildOptionText: vue_types.func,
    locale: vue_types.object,
    rootPrefixCls: vue_types.string,
    selectPrefixCls: vue_types.string,
    goButton: vue_types.any
  },
  setup: function setup(props) {
    var goInputText = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])('');

    var getValidValue = function getValidValue() {
      var goInputTextV = goInputText.value;
      var current = props.current;
      return !goInputTextV || isNaN(goInputTextV) ? current : Number(goInputTextV);
    };

    var defaultBuildOptionText = function defaultBuildOptionText(opt) {
      return "".concat(opt.value, " ").concat(props.locale.items_per_page);
    };

    var handleChange = function handleChange(e) {
      var _e$target = e.target,
          value = _e$target.value,
          composing = _e$target.composing;

      if (composing || goInputText === value) {
        return;
      }

      goInputText.value = value;
    };

    var handleBlur = function handleBlur(e) {
      var goButton = props.goButton,
          quickGo = props.quickGo,
          rootPrefixCls = props.rootPrefixCls;

      if (goButton) {
        return;
      }

      if (e.relatedTarget && (e.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-prev")) >= 0 || e.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-next")) >= 0)) {
        return;
      }

      quickGo(getValidValue());
    };

    var go = function go(e) {
      if (goInputText.value === '') {
        return;
      }

      if (e.keyCode === vc_pagination_keycode.ENTER || e.type === 'click') {
        // https://github.com/vueComponent/ant-design-vue/issues/1316
        props.quickGo(getValidValue());
        goInputText.value = '';
      }
    };

    return {
      getValidValue: getValidValue,
      defaultBuildOptionText: defaultBuildOptionText,
      handleChange: handleChange,
      handleBlur: handleBlur,
      goInputText: goInputText,
      go: go
    };
  },
  render: function render() {
    var _this = this;

    var rootPrefixCls = this.rootPrefixCls,
        locale = this.locale,
        changeSize = this.changeSize,
        quickGo = this.quickGo,
        goButton = this.goButton,
        Select = this.selectComponentClass,
        defaultBuildOptionText = this.defaultBuildOptionText,
        selectPrefixCls = this.selectPrefixCls,
        pageSize = this.pageSize,
        pageSizeOptions = this.pageSizeOptions,
        goInputText = this.goInputText,
        disabled = this.disabled;
    var prefixCls = "".concat(rootPrefixCls, "-options");
    var changeSelect = null;
    var goInput = null;
    var gotoButton = null;

    if (!changeSize && !quickGo) {
      return null;
    }

    if (changeSize && Select) {
      var buildOptionText = this.buildOptionText || defaultBuildOptionText;
      var SelectOption = Select.Option;
      var options = pageSizeOptions.map(function (opt, i) {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(SelectOption, {
          "key": i,
          "value": opt
        }, [buildOptionText({
          value: opt
        })]);
      });
      changeSelect = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Select, {
        "disabled": disabled,
        "prefixCls": selectPrefixCls,
        "showSearch": false,
        "class": "".concat(prefixCls, "-size-changer"),
        "optionLabelProp": "children",
        "dropdownMatchSelectWidth": false,
        "value": (pageSize || pageSizeOptions[0]).toString(),
        "onChange": function onChange(value) {
          return _this.changeSize(Number(value));
        },
        "getPopupContainer": function getPopupContainer(triggerNode) {
          return triggerNode.parentNode;
        }
      }, [options]);
    }

    if (quickGo) {
      if (goButton) {
        gotoButton = typeof goButton === 'boolean' ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("button", {
          "type": "button",
          "onClick": this.go,
          "onKeyup": this.go,
          "disabled": disabled
        }, [locale.jump_to_confirm]) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
          "onClick": this.go,
          "onKeyup": this.go
        }, [goButton]);
      }

      goInput = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": "".concat(prefixCls, "-quick-jumper")
      }, [locale.jump_to, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", {
        "disabled": disabled,
        "type": "text",
        "value": goInputText,
        "onInput": this.handleChange,
        "onKeyup": this.go,
        "onBlur": this.handleBlur
      }, []), locale.page, gotoButton]);
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
      "class": "".concat(prefixCls)
    }, [changeSelect, goInput]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-pagination/pager.tsx




/* harmony default export */ var pager = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'Pager',
  props: {
    rootPrefixCls: vue_types.string,
    page: vue_types.number,
    active: vue_types.bool,
    last: vue_types.bool,
    locale: vue_types.object,
    showTitle: vue_types.bool,
    itemRender: {
      type: Function,
      "default": function _default() {}
    }
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;

    var handleClick = function handleClick() {
      emit('click', props.page);
    };

    var handleKeyPress = function handleKeyPress(event) {
      emit('keypress', event, handleClick, props.page);
    };

    return {
      handleClick: handleClick,
      handleKeyPress: handleKeyPress
    };
  },
  render: function render(ctx) {
    var _classNames;

    var props = this.$props;
    var prefixCls = "".concat(props.rootPrefixCls, "-item");
    var cls = classnames_default()(prefixCls, "".concat(prefixCls, "-").concat(props.page), (_classNames = {}, defineProperty_default()(_classNames, "".concat(prefixCls, "-active"), props.active), defineProperty_default()(_classNames, "".concat(prefixCls, "-disabled"), !props.page), _classNames));
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
      "class": cls,
      "onClick": this.handleClick,
      "onKeypress": this.handleKeyPress,
      "title": this.showTitle ? this.page : null,
      "tabindex": 0
    }, [ctx.itemRender(this.page, 'page', Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {}, [this.page]))]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-pagination/pagination.tsx


function pagination_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function pagination_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { pagination_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { pagination_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }









 // 是否是正整数

function pagination_isInteger(value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
}

function pagination_defaultItemRender(page, type, element) {
  return element;
}

function calculatePage(p, statePageSize, props) {
  var pageSize = p;

  if (typeof pageSize === 'undefined') {
    pageSize = statePageSize;
  }

  return Math.floor((props.total - 1) / pageSize) + 1;
}

/* harmony default export */ var pagination = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'Pagination',
  props: {
    disabled: vue_types.bool,
    prefixCls: vue_types.string.def('rc-pagination'),
    selectPrefixCls: vue_types.string.def('rc-select'),
    current: vue_types.number,
    defaultCurrent: vue_types.number.def(1),
    total: vue_types.number.def(0),
    pageSize: vue_types.number,
    defaultPageSize: vue_types.number.def(10),
    hideOnSinglePage: vue_types.bool.def(false),
    showSizeChanger: vue_types.bool.def(false),
    showLessItems: vue_types.bool.def(false),
    // showSizeChange: PropTypes.func.def(noop),
    selectComponentClass: vue_types.any,
    showPrevNextJumpers: vue_types.bool.def(true),
    showQuickJumper: vue_types.oneOfType([vue_types.bool, vue_types.object]).def(false),
    showTitle: vue_types.bool.def(true),
    pageSizeOptions: vue_types.arrayOf(vue_types.string),
    buildOptionText: vue_types.func,
    showTotal: vue_types.func,
    simple: vue_types.bool,
    locale: vue_types.object.def(vc_pagination_locale_zh_CN),
    itemRender: vue_types.func.def(function () {
      return pagination_defaultItemRender;
    }),
    prevIcon: vue_types.any,
    nextIcon: vue_types.any,
    jumpPrevIcon: vue_types.any,
    jumpNextIcon: vue_types.any
  },
  setup: function setup($props, _ref) {
    var emit = _ref.emit;
    var paginationNode = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);

    var _useLocalValue = value_useLocalValue($props.defaultCurrent, 'current'),
        stateCurrent = _useLocalValue.value,
        setCurrent = _useLocalValue.setValue;

    var _useLocalValue2 = value_useLocalValue($props.defaultPageSize, 'pageSize'),
        statePageSize = _useLocalValue2.value,
        setPageSize = _useLocalValue2.setValue;

    var stateCurrentInputValue = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(stateCurrent.value);

    var getJumpPrevPage = function getJumpPrevPage() {
      return Math.max(1, stateCurrent.value - ($props.showLessItems ? 3 : 5));
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return stateCurrent.value;
    }, function (val, oldValue) {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        if (paginationNode.value) {
          var lastCurrentNode = paginationNode.value.querySelector(".".concat($props.prefixCls, "-item-").concat(oldValue));

          if (lastCurrentNode && document.activeElement === lastCurrentNode) {
            lastCurrentNode.blur();
          }
        }
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $props.total;
    }, function () {
      var newCurrent = calculatePage($props.pageSize, statePageSize.valeu, $props);

      if ($props.current !== undefined) {
        var current = Math.min($props.current, newCurrent);
        stateCurrent.value = current;
        stateCurrentInputValue.value = current;
      } else {
        var _current = stateCurrent.value;

        if (_current === 0 && newCurrent > 0) {
          _current = 1;
        } else {
          _current = Math.min(stateCurrent.value, newCurrent);
        }

        stateCurrent.value = _current;
      }
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $props.current;
    }, function (val) {
      stateCurrentInputValue.value = val;
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["watch"])(function () {
      return $props.pageSize;
    }, function (val) {
      var current = stateCurrent.value;
      var newCurrent = calculatePage(val, statePageSize.value, $props);
      current = current > newCurrent ? newCurrent : current;

      if ($props.current === undefined) {
        stateCurrent.value = current;
        stateCurrentInputValue.value = current;
      }

      statePageSize.value = val;
    });

    var getJumpNextPage = function getJumpNextPage() {
      return Math.min(calculatePage(undefined, statePageSize.value, $props), stateCurrent.value + ($props.showLessItems ? 3 : 5));
    };

    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();

    var getItemIcon = function getItemIcon(icon) {
      var prefixCls = $props.prefixCls;
      return props_util_getComponentFromProp(instance, icon, $props) || Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
        "class": "".concat(prefixCls, "-item-link")
      }, []);
    };

    var getValidValue = function getValidValue(e) {
      var inputValue = e.target.value;
      var allPages = calculatePage(undefined, statePageSize.value, $props);
      var value;

      if (inputValue === '') {
        value = inputValue;
      } else if (isNaN(Number(inputValue))) {
        value = stateCurrentInputValue.value;
      } else if (inputValue >= allPages) {
        value = allPages;
      } else {
        value = Number(inputValue);
      }

      return value;
    };

    var isValid = function isValid(page) {
      return pagination_isInteger(page) && page !== stateCurrent;
    };

    var shouldDisplayQuickJumper = function shouldDisplayQuickJumper() {
      var showQuickJumper = $props.showQuickJumper,
          pageSize = $props.pageSize,
          total = $props.total;

      if (total <= pageSize) {
        return false;
      }

      return showQuickJumper;
    };

    var handleKeyDown = function handleKeyDown(event) {
      if (event.keyCode === vc_pagination_keycode.ARROW_UP || event.keyCode === vc_pagination_keycode.ARROW_DOWN) {
        event.preventDefault();
      }
    };

    var handleKeyUp = function handleKeyUp(e) {
      if (e.target.composing) {
        return;
      }

      var value = getValidValue(e);
      var stateCurrentInputValueV = stateCurrentInputValue.value;

      if (value !== stateCurrentInputValueV) {
        stateCurrentInputValueV.value = value;
      }

      if (e.key === KeyName.Enter) {
        handleChange(value);
      } else if (e.keyCode === vc_pagination_keycode.ARROW_UP) {
        handleChange(value - 1);
      } else if (e.keyCode === vc_pagination_keycode.ARROW_DOWN) {
        handleChange(value + 1);
      }
    };

    var changePageSize = function changePageSize(size) {
      var current = stateCurrent.value;
      var preCurrent = current;
      var newCurrent = calculatePage(size, statePageSize.value, $props);
      current = current > newCurrent ? newCurrent : current; // fix the issue:
      // Once 'total' is 0, 'current' in 'onShowSizeChange' is 0, which is not correct.

      if (newCurrent === 0) {
        current = stateCurrent;
      }

      if (typeof size === 'number') {
        setPageSize(size);
        setCurrent(current);
        stateCurrentInputValue.value = current;
      }

      emit('update:pageSize', size);
      emit('showSizeChange', current, size);

      if (current !== preCurrent) {
        emit('change.current', current, size);
      }
    };

    var handleChange = function handleChange(p) {
      var disabled = $props.disabled;
      var page = p;

      if (isValid(page) && !disabled) {
        var currentPage = calculatePage(undefined, statePageSize.value, $props);

        if (page > currentPage) {
          page = currentPage;
        } else if (page < 1) {
          page = 1;
        }

        setCurrent(page);
        stateCurrentInputValue.value = page; // this.$emit('input', page)

        emit('change', page, statePageSize);
        emit('change.current', page, statePageSize);
        return page;
      }

      return stateCurrent;
    };

    var prev = function prev() {
      if (hasPrev()) {
        handleChange(stateCurrent.value - 1);
      }
    };

    var next = function next() {
      if (hasNext()) {
        handleChange(stateCurrent.value + 1);
      }
    };

    var jumpPrev = function jumpPrev() {
      handleChange(getJumpPrevPage());
    };

    var jumpNext = function jumpNext() {
      handleChange(getJumpNextPage());
    };

    var hasPrev = function hasPrev() {
      return stateCurrent.value > 1;
    };

    var hasNext = function hasNext() {
      return stateCurrent.value < calculatePage(undefined, statePageSize.value, $props);
    };

    var runIfEnter = function runIfEnter(event, callback) {
      if (event.key === 'Enter' || event.charCode === 13) {
        for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          restParams[_key - 2] = arguments[_key];
        }

        callback.apply(void 0, restParams);
      }
    };

    var setPaginationNode = function setPaginationNode(el) {
      paginationNode.value = el;
    };

    var runIfEnterPrev = function runIfEnterPrev(event) {
      runIfEnter(event, prev);
    };

    var runIfEnterNext = function runIfEnterNext(event) {
      runIfEnter(event, next);
    };

    var runIfEnterJumpPrev = function runIfEnterJumpPrev(event) {
      runIfEnter(event, jumpPrev);
    };

    var runIfEnterJumpNext = function runIfEnterJumpNext(event) {
      runIfEnter(event, jumpNext);
    };

    var handleGoTO = function handleGoTO(event) {
      if (event.keyCode === vc_pagination_keycode.ENTER || event.type === 'click') {
        handleChange(stateCurrentInputValue);
      }
    };

    return {
      getJumpPrevPage: getJumpPrevPage,
      getJumpNextPage: getJumpNextPage,
      getItemIcon: getItemIcon,
      getValidValue: getValidValue,
      isValid: isValid,
      shouldDisplayQuickJumper: shouldDisplayQuickJumper,
      handleKeyDown: handleKeyDown,
      handleKeyUp: handleKeyUp,
      changePageSize: changePageSize,
      handleChange: handleChange,
      prev: prev,
      next: next,
      jumpPrev: jumpPrev,
      jumpNext: jumpNext,
      hasPrev: hasPrev,
      hasNext: hasNext,
      runIfEnter: runIfEnter,
      runIfEnterPrev: runIfEnterPrev,
      runIfEnterNext: runIfEnterNext,
      runIfEnterJumpPrev: runIfEnterJumpPrev,
      runIfEnterJumpNext: runIfEnterJumpNext,
      handleGoTO: handleGoTO,
      stateCurrentInputValue: stateCurrentInputValue,
      stateCurrent: stateCurrent,
      statePageSize: statePageSize,
      setPaginationNode: setPaginationNode
    };
  },
  render: function render(ctx) {
    var _ref2;

    var _this$$props = this.$props,
        prefixCls = _this$$props.prefixCls,
        disabled = _this$$props.disabled; // When hideOnSinglePage is true and there is only 1 page, hide the pager

    if (this.hideOnSinglePage === true && this.total <= this.statePageSize) {
      return null;
    }

    var props = this.$props;
    var locale = this.locale;
    var allPages = calculatePage(undefined, this.statePageSize, this.$props);
    var pagerList = [];
    var jumpPrev = null;
    var jumpNext = null;
    var firstPager = null;
    var lastPager = null;
    var gotoButton = null;
    var goButton = this.showQuickJumper && this.showQuickJumper.goButton;
    var pageBufferSize = this.showLessItems ? 1 : 2;
    var stateCurrent = this.stateCurrent,
        statePageSize = this.statePageSize;
    var prevPage = stateCurrent - 1 > 0 ? stateCurrent - 1 : 0;
    var nextPage = stateCurrent + 1 < allPages ? stateCurrent + 1 : allPages;

    if (this.simple) {
      if (goButton) {
        if (typeof goButton === 'boolean') {
          gotoButton = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("button", {
            "type": "button",
            "onClick": this.handleGoTO,
            "onKeyup": this.handleGoTO
          }, [locale.jump_to_confirm]);
        } else {
          gotoButton = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
            "onClick": this.handleGoTO,
            "onKeyup": this.handleGoTO
          }, [goButton]);
        }

        gotoButton = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
          "title": this.showTitle ? "".concat(locale.jump_to).concat(this.stateCurrent, "/").concat(allPages) : null,
          "class": "".concat(prefixCls, "-simple-pager")
        }, [gotoButton]);
      }

      var hasPrev = this.hasPrev();
      var hasNext = this.hasNext();
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("ul", {
        "class": "".concat(prefixCls, " ").concat(prefixCls, "-simple")
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
        "title": this.showTitle ? locale.prev_page : null,
        "onClick": this.prev,
        "tabindex": hasPrev ? 0 : null,
        "onKeypress": this.runIfEnterPrev,
        "class": "".concat(hasPrev ? '' : "".concat(prefixCls, "-disabled"), " ").concat(prefixCls, "-prev"),
        "aria-disabled": !this.hasPrev()
      }, [ctx.itemRender(prevPage, 'prev', this.getItemIcon('prevIcon'))]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
        "title": this.showTitle ? "".concat(stateCurrent, "/").concat(allPages) : null,
        "class": "".concat(prefixCls, "-simple-pager")
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", pagination_objectSpread({
        "type": "text",
        "value": this.stateCurrentInputValue,
        "onKeydown": this.handleKeyDown,
        "onKeyup": this.handleKeyUp,
        "onInput": this.handleKeyUp,
        "size": 3
      }, {
        directives: [{
          name: 'ant-input'
        }]
      }), []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-slash")
      }, ["\uFF0F"]), allPages]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
        "title": this.showTitle ? locale.next_page : null,
        "onClick": this.next,
        "tabindex": this.hasNext ? 0 : null,
        "onKeypress": this.runIfEnterNext,
        "class": "".concat(hasNext ? '' : "".concat(prefixCls, "-disabled"), " ").concat(prefixCls, "-next"),
        "aria-disabled": !this.hasNext()
      }, [ctx.itemRender(nextPage, 'next', this.getItemIcon('nextIcon'))]), gotoButton]);
    }

    if (allPages <= 5 + pageBufferSize * 2) {
      var pagerProps = {
        locale: locale,
        rootPrefixCls: prefixCls,
        showTitle: props.showTitle,
        itemRender: props.itemRender,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter
      };

      if (!allPages) {
        pagerList.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(pager, pagination_objectSpread({}, pagerProps, {
          "key": "noPager",
          "page": allPages,
          "class": "".concat(prefixCls, "-disabled")
        }), []));
      }

      for (var i = 1; i <= allPages; i++) {
        var active = stateCurrent === i;
        pagerList.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(pager, pagination_objectSpread({}, pagerProps, {
          "key": i,
          "page": i,
          "active": active
        }), []));
      }
    } else {
      var prevItemTitle = this.showLessItems ? locale.prev_3 : locale.prev_5;
      var nextItemTitle = this.showLessItems ? locale.next_3 : locale.next_5;

      if (this.showPrevNextJumpers) {
        var jumpPrevClassString = "".concat(prefixCls, "-jump-prev");

        if (props.jumpPrevIcon) {
          jumpPrevClassString += " ".concat(prefixCls, "-jump-prev-custom-icon");
        }

        jumpPrev = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
          "title": this.showTitle ? prevItemTitle : null,
          "key": "prev",
          "onClick": this.jumpPrev,
          "tabindex": 0,
          "onKeypress": this.runIfEnterJumpPrev,
          "class": jumpPrevClassString
        }, [ctx.itemRender(this.getJumpPrevPage(), 'jump-prev', this.getItemIcon('jumpPrevIcon'))]);
        var jumpNextClassString = "".concat(prefixCls, "-jump-next");

        if (props.jumpNextIcon) {
          jumpNextClassString += " ".concat(prefixCls, "-jump-next-custom-icon");
        }

        jumpNext = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
          "title": this.showTitle ? nextItemTitle : null,
          "key": "next",
          "tabindex": 0,
          "onClick": this.jumpNext,
          "onKeypress": this.runIfEnterJumpNext,
          "class": jumpNextClassString
        }, [ctx.itemRender(this.getJumpNextPage(), 'jump-next', this.getItemIcon('jumpNextIcon'))]);
      }

      lastPager = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(pager, {
        "locale": locale,
        "last": true,
        "rootPrefixCls": prefixCls,
        "onClick": this.handleChange,
        "onKeypress": this.runIfEnter,
        "key": allPages,
        "page": allPages,
        "active": false,
        "showTitle": this.showTitle,
        "itemRender": ctx.itemRender
      }, []);
      firstPager = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(pager, {
        "locale": locale,
        "rootPrefixCls": prefixCls,
        "onClick": this.handleChange,
        "onKeypress": this.runIfEnter,
        "key": 1,
        "page": 1,
        "active": false,
        "showTitle": this.showTitle,
        "itemRender": ctx.itemRender
      }, []);
      var left = Math.max(1, stateCurrent - pageBufferSize);
      var right = Math.min(stateCurrent + pageBufferSize, allPages);

      if (stateCurrent - 1 <= pageBufferSize) {
        right = 1 + pageBufferSize * 2;
      }

      if (allPages - stateCurrent <= pageBufferSize) {
        left = allPages - pageBufferSize * 2;
      }

      for (var _i = left; _i <= right; _i++) {
        var _active = stateCurrent === _i;

        pagerList.push(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(pager, {
          "locale": locale,
          "rootPrefixCls": prefixCls,
          "onClick": this.handleChange,
          "onKeypress": this.runIfEnter,
          "key": _i,
          "page": _i,
          "active": _active,
          "showTitle": this.showTitle,
          "itemRender": ctx.itemRender
        }, []));
      }

      if (stateCurrent - 1 >= pageBufferSize * 2 && stateCurrent !== 1 + 2) {
        pagerList[0] = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(pager, {
          "locale": locale,
          "rootPrefixCls": prefixCls,
          "onClick": this.handleChange,
          "onKeypress": this.runIfEnter,
          "key": left,
          "page": left,
          "class": "".concat(prefixCls, "-item-after-jump-prev"),
          "active": false,
          "showTitle": this.showTitle,
          "itemRender": ctx.itemRender
        }, []);
        pagerList.unshift(jumpPrev);
      }

      if (allPages - stateCurrent >= pageBufferSize * 2 && stateCurrent !== allPages - 2) {
        pagerList[pagerList.length - 1] = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(pager, {
          "locale": locale,
          "rootPrefixCls": prefixCls,
          "onClick": this.handleChange,
          "onKeypress": this.runIfEnter,
          "key": right,
          "page": right,
          "class": "".concat(prefixCls, "-item-before-jump-next"),
          "active": false,
          "showTitle": this.showTitle,
          "itemRender": ctx.itemRender
        }, []);
        pagerList.push(jumpNext);
      }

      if (left !== 1) {
        pagerList.unshift(firstPager);
      }

      if (right !== allPages) {
        pagerList.push(lastPager);
      }
    }

    var totalText = null;

    if (this.showTotal) {
      totalText = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
        "class": "".concat(prefixCls, "-total-text")
      }, [this.showTotal(this.total, [this.total === 0 ? 0 : (stateCurrent - 1) * statePageSize + 1, stateCurrent * statePageSize > this.total ? this.total : stateCurrent * statePageSize])]);
    }

    var prevDisabled = !this.hasPrev() || !allPages;
    var nextDisabled = !this.hasNext() || !allPages;
    var buildOptionText = this.buildOptionText || this.$slots.buildOptionText;
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("ul", {
      "class": (_ref2 = {}, defineProperty_default()(_ref2, "".concat(prefixCls), true), defineProperty_default()(_ref2, "".concat(prefixCls, "-disabled"), disabled), _ref2),
      "unselectable": "on",
      "ref": ctx.setPaginationNode
    }, [totalText, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
      "title": this.showTitle ? locale.prev_page : null,
      "onClick": this.prev,
      "tabindex": prevDisabled ? null : 0,
      "onKeypress": this.runIfEnterPrev,
      "class": "".concat(!prevDisabled ? '' : "".concat(prefixCls, "-disabled"), " ").concat(prefixCls, "-prev"),
      "aria-disabled": prevDisabled
    }, [ctx.itemRender(prevPage, 'prev', this.getItemIcon('prevIcon'))]), pagerList, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("li", {
      "title": this.showTitle ? locale.next_page : null,
      "onClick": this.next,
      "tabindex": nextDisabled ? null : 0,
      "onKeypress": this.runIfEnterNext,
      "class": "".concat(!nextDisabled ? '' : "".concat(prefixCls, "-disabled"), " ").concat(prefixCls, "-next"),
      "aria-disabled": nextDisabled
    }, [ctx.itemRender(nextPage, 'next', this.getItemIcon('nextIcon'))]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_pagination_options, {
      "disabled": disabled,
      "locale": locale,
      "rootPrefixCls": prefixCls,
      "selectComponentClass": this.selectComponentClass,
      "selectPrefixCls": this.selectPrefixCls,
      "changeSize": this.showSizeChanger ? this.changePageSize : null,
      "current": stateCurrent,
      "pageSize": statePageSize,
      "pageSizeOptions": this.pageSizeOptions,
      "buildOptionText": buildOptionText || null,
      "quickGo": this.shouldDisplayQuickJumper() ? this.handleChange : null,
      "goButton": goButton
    }, [])]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-pagination/index.ts

// based on rc-pagination 1.20.14

// CONCATENATED MODULE: ./src/components/pagination/mini-select.tsx


function mini_select_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function mini_select_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { mini_select_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { mini_select_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/* harmony default export */ var mini_select = ({
  props: Object.assign({}, SelectProps),
  Option: components_select.Option,
  render: function render(ctx) {
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var selectOptionsProps = getOptionProps(instance);
    var selelctProps = Object.assign(Object.assign(Object.assign({}, selectOptionsProps), {
      size: 'small'
    }), getListenersFromInstance(instance));
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_select, mini_select_objectSpread({}, selelctProps), [filterEmpty(ctx.$slots["default"])]);
  }
});
// CONCATENATED MODULE: ./src/components/pagination/pagination.tsx


function pagination_pagination_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function pagination_pagination_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { pagination_pagination_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { pagination_pagination_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }












var pagination_PaginationProps = function PaginationProps() {
  return {
    total: vue_types.number,
    defaultCurrent: vue_types.number,
    disabled: vue_types.bool,
    current: vue_types.number,
    defaultPageSize: vue_types.number,
    pageSize: vue_types.number,
    hideOnSinglePage: vue_types.bool,
    showSizeChanger: vue_types.bool,
    pageSizeOptions: vue_types.arrayOf(vue_types.oneOfType([vue_types.number, vue_types.string])),
    buildOptionText: vue_types.func,
    showSizeChange: vue_types.func,
    showQuickJumper: vue_types.oneOfType([vue_types.bool, vue_types.object]),
    showTotal: vue_types.any,
    size: vue_types.string,
    simple: vue_types.bool,
    locale: vue_types.object,
    prefixCls: vue_types.string,
    selectPrefixCls: vue_types.string,
    itemRender: vue_types.any,
    role: vue_types.string,
    showLessItems: vue_types.bool
  };
};
var pagination_PaginationConfig = function PaginationConfig() {
  return Object.assign(Object.assign({}, pagination_PaginationProps()), {
    position: vue_types.oneOf(['top', 'bottom', 'both'])
  });
};
/* harmony default export */ var pagination_pagination = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'APagination',
  model: {
    prop: 'current',
    event: 'change.current'
  },
  props: Object.assign({}, pagination_PaginationProps()),
  setup: function setup(props, _ref) {
    var slots = _ref.slots;

    var getIconsProps = function getIconsProps(prefixCls) {
      var prevIcon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
        "class": "".concat(prefixCls, "-item-link")
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "left"
      }, [])]);
      var nextIcon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
        "class": "".concat(prefixCls, "-item-link")
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "right"
      }, [])]);
      var jumpPrevIcon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
        "class": "".concat(prefixCls, "-item-link")
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": "".concat(prefixCls, "-item-container")
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "class": "".concat(prefixCls, "-item-link-icon"),
        "type": "double-left"
      }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-item-ellipsis")
      }, ["\u2022\u2022\u2022"])])]);
      var jumpNextIcon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
        "class": "".concat(prefixCls, "-item-link")
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": "".concat(prefixCls, "-item-container")
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "class": "".concat(prefixCls, "-item-link-icon"),
        "type": "double-right"
      }, []), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-item-ellipsis")
      }, ["\u2022\u2022\u2022"])])]);
      return {
        prevIcon: prevIcon,
        nextIcon: nextIcon,
        jumpPrevIcon: jumpPrevIcon,
        jumpNextIcon: jumpNextIcon
      };
    };

    var configProvider = config_provider_useConfigProvider();

    var renderPagination = function renderPagination(contextLocale) {
      var customizePrefixCls = props.prefixCls,
          customizeSelectPrefixCls = props.selectPrefixCls,
          buildOptionText = props.buildOptionText,
          size = props.size,
          customLocale = props.locale,
          restProps = __rest(props, ["prefixCls", "selectPrefixCls", "buildOptionText", "size", "locale"]);

      var getPrefixCls = configProvider.getPrefixCls;
      var prefixCls = getPrefixCls('pagination', customizePrefixCls);
      var selectPrefixCls = getPrefixCls('select', customizeSelectPrefixCls);
      var isSmall = size === 'small';
      var paginationProps = Object.assign(Object.assign(Object.assign(Object.assign({
        prefixCls: prefixCls,
        selectPrefixCls: selectPrefixCls
      }, restProps), getIconsProps(prefixCls)), {
        selectComponentClass: isSmall ? mini_select : components_select,
        locale: Object.assign(Object.assign({}, contextLocale), customLocale),
        buildOptionText: buildOptionText || slots.buildOptionText,
        "class": {
          mini: isSmall
        }
      }), getListenersFromInstance(Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])()));
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(pagination, pagination_pagination_objectSpread({}, paginationProps), []);
    };

    return {
      getIconsProps: getIconsProps,
      renderPagination: renderPagination
    };
  },
  render: function render() {
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(locale_receiver, {
      "componentName": "Pagination",
      "defaultLocale": vc_pagination_locale_zh_CN
    }, {
      "default": this.renderPagination
    });
  }
}));
// CONCATENATED MODULE: ./src/components/pagination/index.tsx




/* istanbul ignore next */

pagination_pagination.install = function (Vue) {
  Vue.use(base);
  Vue.component(pagination_pagination.name, pagination_pagination);
};

/* harmony default export */ var components_pagination = (pagination_pagination);
// CONCATENATED MODULE: ./src/components/vc-progress/src/enhancer.ts

var enhancer_useEnhancer = function useEnhancer() {
  var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
  var prevTimeStamp = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);
  Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
    var now = Date.now();
    var paths = instance['ctx'].paths;
    var updated = false;
    Object.keys(paths).forEach(function (key) {
      var path = paths[key];

      if (!path) {
        return;
      }

      updated = true;
      var pathStyle = path.style;
      pathStyle.transitionDuration = '.3s, .3s, .3s, .06s';

      if (prevTimeStamp.value && now - prevTimeStamp.value < 100) {
        pathStyle.transitionDuration = '0s, 0s';
      }
    });

    if (updated) {
      prevTimeStamp.value = Date.now();
    }
  });
};
// CONCATENATED MODULE: ./src/components/vc-progress/src/types.tsx


var types_defaultProps = {
  // className: '',
  percent: 0,
  prefixCls: 'rc-progress',
  strokeColor: '#2db7f5',
  strokeLinecap: 'round',
  strokeWidth: 1,
  // style: {},
  trailColor: '#D9D9D9',
  trailWidth: 1
};
var mixedType = vue_types.oneOfType([vue_types.number, vue_types.string]);
var propTypes = {
  // className: PropTypes.string,
  percent: vue_types.oneOfType([mixedType, vue_types.arrayOf(mixedType)]),
  prefixCls: vue_types.string,
  strokeColor: vue_types.oneOfType([vue_types.string, vue_types.arrayOf(vue_types.oneOfType([vue_types.string, vue_types.object])), vue_types.object]),
  strokeLinecap: vue_types.oneOf(['butt', 'round', 'square']),
  strokeWidth: mixedType,
  // style: PropTypes.object,
  trailColor: vue_types.string,
  trailWidth: mixedType
};
// CONCATENATED MODULE: ./src/components/vc-progress/src/line.tsx


function line_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function line_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { line_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { line_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






var line_Line = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: initDefaultProps(propTypes, types_defaultProps),
  setup: function setup() {
    enhancer_useEnhancer();
    var paths = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["reactive"])({});
    return {
      setPath: function setPath(index, el) {
        paths[index] = el;
      }
    };
  },
  render: function render() {
    var _this = this;

    var _a = this.$props,
        percent = _a.percent,
        prefixCls = _a.prefixCls,
        strokeColor = _a.strokeColor,
        strokeLinecap = _a.strokeLinecap,
        strokeWidth = _a.strokeWidth,
        trailColor = _a.trailColor,
        trailWidth = _a.trailWidth,
        transition = _a.transition,
        restProps = __rest(_a, ["percent", "prefixCls", "strokeColor", "strokeLinecap", "strokeWidth", "trailColor", "trailWidth", "transition"]);

    var percentList = Array.isArray(percent) ? percent : [percent];
    var strokeColorList = Array.isArray(strokeColor) ? strokeColor : [strokeColor];
    var center = strokeWidth / 2;
    var right = 100 - strokeWidth / 2;
    var pathString = "M ".concat(strokeLinecap === 'round' ? center : 0, ",").concat(center, "\n           L ").concat(strokeLinecap === 'round' ? right : 100, ",").concat(center);
    var viewBoxString = "0 0 100 ".concat(strokeWidth);
    var stackPtg = 0;
    var pathFirst = {
      d: pathString,
      'stroke-linecap': strokeLinecap,
      stroke: trailColor,
      'stroke-width': trailWidth || strokeWidth,
      'fill-opacity': '0',
      "class": "".concat(prefixCls, "-line-trail")
    };
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", line_objectSpread({
      "viewBox": viewBoxString,
      "preserveAspectRatio": "none"
    }, restProps), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", line_objectSpread({}, pathFirst), []), percentList.map(function (ptg, index) {
      var pathStyle = {
        strokeDasharray: "".concat(ptg, "px, 100px"),
        strokeDashoffset: "-".concat(stackPtg, "px"),
        transition: transition || 'stroke-dashoffset 0.3s ease 0s, stroke-dasharray .3s ease 0s, stroke 0.3s linear'
      };
      var color = strokeColorList[index] || strokeColorList[strokeColorList.length - 1];
      stackPtg += ptg;
      var pathProps = {
        key: index,
        d: pathString,
        'stroke-linecap': strokeLinecap,
        stroke: color,
        'stroke-width': strokeWidth,
        'fill-opacity': '0',
        "class": "".concat(prefixCls, "-line-path"),
        style: pathStyle,
        ref: function ref(c) {
          _this.setPath(index, c);
        }
      };
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", line_objectSpread({}, pathProps), []);
    })]);
  }
});
/* harmony default export */ var line = (line_Line);
// CONCATENATED MODULE: ./src/components/vc-progress/src/circle.tsx


function circle_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function circle_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { circle_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { circle_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }







var circlePropTypes = Object.assign(Object.assign({}, propTypes), {
  gapPosition: vue_types.oneOf(['top', 'bottom', 'left', 'right']),
  gapDegree: vue_types.oneOfType([vue_types.number, vue_types.string, vue_types.bool])
});
var circleDefaultProps = Object.assign(Object.assign({}, types_defaultProps), {
  gapPosition: 'top'
});
var gradientSeed = 0;

function stripPercentToNumber(percent) {
  return +percent.replace('%', '');
}

function circle_toArray(symArray) {
  return Array.isArray(symArray) ? symArray : [symArray];
}

function getPathStyles(offset, percent, strokeColor, strokeWidth) {
  var gapDegree = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var gapPosition = arguments.length > 5 ? arguments[5] : undefined;
  var radius = 50 - strokeWidth / 2;
  var beginPositionX = 0;
  var beginPositionY = -radius;
  var endPositionX = 0;
  var endPositionY = -2 * radius;

  switch (gapPosition) {
    case 'left':
      beginPositionX = -radius;
      beginPositionY = 0;
      endPositionX = 2 * radius;
      endPositionY = 0;
      break;

    case 'right':
      beginPositionX = radius;
      beginPositionY = 0;
      endPositionX = -2 * radius;
      endPositionY = 0;
      break;

    case 'bottom':
      beginPositionY = radius;
      endPositionY = 2 * radius;
      break;

    default:
  }

  var pathString = "M 50,50 m ".concat(beginPositionX, ",").concat(beginPositionY, "\n   a ").concat(radius, ",").concat(radius, " 0 1 1 ").concat(endPositionX, ",").concat(-endPositionY, "\n   a ").concat(radius, ",").concat(radius, " 0 1 1 ").concat(-endPositionX, ",").concat(endPositionY);
  var len = Math.PI * 2 * radius;
  var pathStyle = {
    stroke: strokeColor,
    strokeDasharray: "".concat(percent / 100 * (len - gapDegree), "px ").concat(len, "px"),
    strokeDashoffset: "-".concat(gapDegree / 2 + offset / 100 * (len - gapDegree), "px"),
    transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s' // eslint-disable-line

  };
  return {
    pathString: pathString,
    pathStyle: pathStyle
  };
}

var circle_Circle = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: initDefaultProps(circlePropTypes, circleDefaultProps),
  setup: function setup($props) {
    enhancer_useEnhancer();
    var paths = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])({});
    var gradientId = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(gradientSeed);

    var getStokeList = function getStokeList() {
      var prefixCls = $props.prefixCls,
          percent = $props.percent,
          strokeColor = $props.strokeColor,
          strokeWidth = $props.strokeWidth,
          strokeLinecap = $props.strokeLinecap,
          gapDegree = $props.gapDegree,
          gapPosition = $props.gapPosition;
      var percentList = circle_toArray(percent);
      var strokeColorList = circle_toArray(strokeColor);
      var stackPtg = 0;
      return percentList.map(function (ptg, index) {
        var color = strokeColorList[index] || strokeColorList[strokeColorList.length - 1];
        var stroke = Object.prototype.toString.call(color) === '[object Object]' ? "url(#".concat(prefixCls, "-gradient-").concat(gradientId.value, ")") : '';

        var _getPathStyles = getPathStyles(stackPtg, ptg, color, strokeWidth, gapDegree, gapPosition),
            pathString = _getPathStyles.pathString,
            pathStyle = _getPathStyles.pathStyle;

        stackPtg += ptg;
        var pathProps = {
          key: index,
          d: pathString,
          stroke: stroke,
          'stroke-linecap': strokeLinecap,
          'stroke-width': ptg === 0 ? 0 : strokeWidth,
          'fill-opacity': '0',
          "class": "".concat(prefixCls, "-circle-path"),
          style: pathStyle,
          ref: function ref(c) {
            paths.value[index] = c;
          }
        };
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", circle_objectSpread({}, pathProps), []);
      });
    };

    gradientSeed += 1;
    return {
      getStokeList: getStokeList,
      paths: paths,
      gradientId: gradientId
    };
  },
  render: function render() {
    var _a = this.$props,
        prefixCls = _a.prefixCls,
        strokeWidth = _a.strokeWidth,
        trailWidth = _a.trailWidth,
        gapDegree = _a.gapDegree,
        gapPosition = _a.gapPosition,
        trailColor = _a.trailColor,
        strokeLinecap = _a.strokeLinecap,
        strokeColor = _a.strokeColor,
        restProps = __rest(_a, ["prefixCls", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "strokeColor"]);

    var _getPathStyles2 = getPathStyles(0, 100, trailColor, strokeWidth, gapDegree, gapPosition),
        pathString = _getPathStyles2.pathString,
        pathStyle = _getPathStyles2.pathStyle;

    var strokeColorList = circle_toArray(strokeColor);
    var gradient = strokeColorList.find(function (color) {
      return Object.prototype.toString.call(color) === '[object Object]';
    });
    var pathFirst = {
      d: pathString,
      stroke: trailColor,
      'stroke-linecap': strokeLinecap,
      'stroke-width': trailWidth || strokeWidth,
      'fill-opacity': '0',
      "class": "".concat(prefixCls, "-circle-trail"),
      style: pathStyle
    };
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("svg", circle_objectSpread({
      "viewBox": "0 0 100 100"
    }, restProps), [gradient && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("defs", {}, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("linearGradient", {
      "id": "".concat(prefixCls, "-gradient-").concat(this.gradientId),
      "x1": "100%",
      "y1": "0%",
      "x2": "0%",
      "y2": "0%"
    }, [Object.keys(gradient).sort(function (a, b) {
      return stripPercentToNumber(a) - stripPercentToNumber(b);
    }).map(function (key, index) {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("stop", {
        "key": index,
        "offset": key,
        "stop-color": gradient[key]
      }, []);
    })])]), Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("path", circle_objectSpread({}, pathFirst), []), this.getStokeList().reverse()]);
  }
});
/* harmony default export */ var circle = (circle_Circle);
// CONCATENATED MODULE: ./src/components/vc-progress/src/index.ts




/* harmony default export */ var vc_progress_src = ({
  Line: line,
  Circle: circle
});
// CONCATENATED MODULE: ./src/components/vc-progress/index.ts

// based on rc-progress 2.5.2


/* harmony default export */ var vc_progress = (vc_progress_src);
// CONCATENATED MODULE: ./src/components/progress/utils.ts

function validProgress(progress) {
  if (!progress || progress < 0) {
    return 0;
  }

  if (progress > 100) {
    return 100;
  }

  return progress;
}
// CONCATENATED MODULE: ./src/components/progress/circle.tsx




var statusColorMap = {
  normal: '#108ee9',
  exception: '#ff5500',
  success: '#87d068'
};

function getPercentage(_ref) {
  var percent = _ref.percent,
      successPercent = _ref.successPercent;
  var ptg = validProgress(percent);

  if (!successPercent) {
    return ptg;
  }

  var successPtg = validProgress(successPercent);
  return [successPercent, validProgress(ptg - successPtg)];
}

function getStrokeColor(_ref2) {
  var progressStatus = _ref2.progressStatus,
      successPercent = _ref2.successPercent,
      strokeColor = _ref2.strokeColor;
  var color = strokeColor || statusColorMap[progressStatus];

  if (!successPercent) {
    return color;
  }

  return [statusColorMap.success, color];
}

var progress_circle_Circle = function Circle(props, _ref3) {
  var _wrapperClassName;

  var slots = _ref3.slots;
  var prefixCls = props.prefixCls,
      width = props.width,
      strokeWidth = props.strokeWidth,
      trailColor = props.trailColor,
      strokeLinecap = props.strokeLinecap,
      gapPosition = props.gapPosition,
      gapDegree = props.gapDegree,
      type = props.type;
  var circleSize = width || 120;
  var circleStyle = {
    width: typeof circleSize === 'number' ? "".concat(circleSize, "px") : circleSize,
    height: typeof circleSize === 'number' ? "".concat(circleSize, "px") : circleSize,
    fontSize: circleSize * 0.15 + 6
  };
  var circleWidth = strokeWidth || 6;
  var gapPos = gapPosition || type === 'dashboard' && 'bottom' || 'top';
  var gapDeg = gapDegree || type === 'dashboard' && 75;
  var strokeColor = getStrokeColor(props);
  var isGradient = Object.prototype.toString.call(strokeColor) === '[object Object]';
  var wrapperClassName = (_wrapperClassName = {}, defineProperty_default()(_wrapperClassName, "".concat(prefixCls, "-inner"), true), defineProperty_default()(_wrapperClassName, "".concat(prefixCls, "-circle-gradient"), isGradient), _wrapperClassName);
  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
    "class": wrapperClassName,
    "style": circleStyle
  }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(circle, {
    "percent": getPercentage(props),
    "strokeWidth": circleWidth,
    "trailWidth": circleWidth,
    "strokeColor": strokeColor,
    "strokeLinecap": strokeLinecap,
    "trailColor": trailColor,
    "prefixCls": prefixCls,
    "gapDegree": gapDeg,
    "gapPosition": gapPos
  }, []), slots["default"] && slots["default"]()]);
};

/* harmony default export */ var progress_circle = (progress_circle_Circle);
// CONCATENATED MODULE: ./src/components/progress/line.tsx




/**
 * {
 *   '0%': '#afc163',
 *   '75%': '#009900',
 *   '50%': 'green',     ====>     '#afc163 0%, #66FF00 25%, #00CC00 50%, #009900 75%, #ffffff 100%'
 *   '25%': '#66FF00',
 *   '100%': '#ffffff'
 * }
 */

var line_sortGradient = function sortGradient(gradients) {
  var tempArr = []; // eslint-disable-next-line no-restricted-syntax

  for (var _i = 0, _Object$entries = Object.entries(gradients); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = slicedToArray_default()(_Object$entries[_i], 2),
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];

    var formatKey = parseFloat(key.replace(/%/g, ''));

    if (isNaN(formatKey)) {
      return {};
    }

    tempArr.push({
      key: formatKey,
      value: value
    });
  }

  tempArr = tempArr.sort(function (a, b) {
    return a.key - b.key;
  });
  return tempArr.map(function (_ref) {
    var key = _ref.key,
        value = _ref.value;
    return "".concat(value, " ").concat(key, "%");
  }).join(', ');
};
/**
 * {
 *   '0%': '#afc163',
 *   '25%': '#66FF00',
 *   '50%': '#00CC00',     ====>  linear-gradient(to right, #afc163 0%, #66FF00 25%,
 *   '75%': '#009900',              #00CC00 50%, #009900 75%, #ffffff 100%)
 *   '100%': '#ffffff'
 * }
 *
 * Then this man came to realize the truth:
 * Besides six pence, there is the moon.
 * Besides bread and butter, there is the bug.
 * And...
 * Besides women, there is the code.
 */

var line_handleGradient = function handleGradient(strokeColor) {
  var _strokeColor$from = strokeColor.from,
      from = _strokeColor$from === void 0 ? '#1890ff' : _strokeColor$from,
      _strokeColor$to = strokeColor.to,
      to = _strokeColor$to === void 0 ? '#1890ff' : _strokeColor$to,
      _strokeColor$directio = strokeColor.direction,
      direction = _strokeColor$directio === void 0 ? 'to right' : _strokeColor$directio,
      rest = __rest(strokeColor, ["from", "to", "direction"]);

  if (Object.keys(rest).length !== 0) {
    var sortedGradients = line_sortGradient(rest);
    return {
      backgroundImage: "linear-gradient(".concat(direction, ", ").concat(sortedGradients, ")")
    };
  }

  return {
    backgroundImage: "linear-gradient(".concat(direction, ", ").concat(from, ", ").concat(to, ")")
  };
};

var progress_line_Line = function Line(props, _ref2) {
  var slots = _ref2.slots;
  var prefixCls = props.prefixCls,
      percent = props.percent,
      successPercent = props.successPercent,
      strokeWidth = props.strokeWidth,
      size = props.size,
      strokeColor = props.strokeColor,
      strokeLinecap = props.strokeLinecap;
  var backgroundProps;

  if (strokeColor && typeof strokeColor !== 'string') {
    backgroundProps = line_handleGradient(strokeColor);
  } else {
    backgroundProps = {
      background: strokeColor
    };
  }

  var percentStyle = Object.assign({
    width: "".concat(validProgress(percent), "%"),
    height: "".concat(strokeWidth || (size === 'small' ? 6 : 8), "px"),
    background: strokeColor,
    borderRadius: strokeLinecap === 'square' ? 0 : '100px'
  }, backgroundProps);
  var successPercentStyle = {
    width: "".concat(validProgress(successPercent), "%"),
    height: "".concat(strokeWidth || (size === 'small' ? 6 : 8), "px"),
    borderRadius: strokeLinecap === 'square' ? 0 : ''
  };
  var successSegment = successPercent !== undefined ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
    "class": "".concat(prefixCls, "-success-bg"),
    "style": successPercentStyle
  }, []) : null;
  return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {}, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
    "class": "".concat(prefixCls, "-outer")
  }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
    "class": "".concat(prefixCls, "-inner")
  }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
    "class": "".concat(prefixCls, "-bg"),
    "style": percentStyle
  }, []), successSegment])]), slots["default"] && slots["default"]()]);
};

/* harmony default export */ var progress_line = (progress_line_Line);
// CONCATENATED MODULE: ./src/components/progress/progress.tsx


function progress_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function progress_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { progress_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { progress_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }










var ProgressStatuses = ['normal', 'exception', 'active', 'success'];
var ProgressType = vue_types.oneOf(['line', 'circle', 'dashboard']);
var ProgressSize = vue_types.oneOf(['default', 'small']);
var ProgressProps = {
  prefixCls: vue_types.string,
  type: ProgressType,
  percent: vue_types.number,
  successPercent: vue_types.number,
  format: vue_types.func,
  status: vue_types.oneOf(ProgressStatuses),
  showInfo: vue_types.bool,
  strokeWidth: vue_types.number,
  strokeLinecap: vue_types.oneOf(['butt', 'round', 'square']),
  strokeColor: vue_types.oneOfType([vue_types.string, vue_types.object]),
  trailColor: vue_types.string,
  width: vue_types.number,
  gapDegree: vue_types.number,
  gapPosition: vue_types.oneOf(['top', 'bottom', 'left', 'right']),
  size: ProgressSize
};
/* harmony default export */ var progress_progress = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AProgress',
  props: initDefaultProps(ProgressProps, {
    type: 'line',
    percent: 0,
    showInfo: true,
    trailColor: '#f3f3f3',
    size: 'default',
    gapDegree: 0,
    strokeLinecap: 'round'
  }),
  setup: function setup($props, _ref) {
    var emit = _ref.emit,
        slots = _ref.slots;

    var getPercentNumber = function getPercentNumber() {
      var successPercent = $props.successPercent,
          _$props$percent = $props.percent,
          percent = _$props$percent === void 0 ? 0 : _$props$percent;
      return parseInt(successPercent !== undefined ? successPercent.toString() : percent.toString(), 10);
    };

    var getProgressStatus = function getProgressStatus() {
      var status = $props.status;

      if (ProgressStatuses.indexOf(status) < 0 && getPercentNumber() >= 100) {
        return 'success';
      }

      return status || 'normal';
    };

    var renderProcessInfo = function renderProcessInfo(prefixCls, progressStatus) {
      var showInfo = $props.showInfo,
          format = $props.format,
          type = $props.type,
          percent = $props.percent,
          successPercent = $props.successPercent;

      if (!showInfo) {
        return null;
      }

      var text;

      var textFormatter = format || slots.format || function (percentNumber) {
        return "".concat(percentNumber, "%");
      };

      var iconType = type === 'circle' || type === 'dashboard' ? '' : '-circle';

      if (format || slots.format || progressStatus !== 'exception' && progressStatus !== 'success') {
        text = textFormatter(validProgress(percent), validProgress(successPercent));
      } else if (progressStatus === 'exception') {
        text = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
          "type": "close".concat(iconType),
          "theme": type === 'line' ? 'filled' : 'outlined'
        }, []);
      } else if (progressStatus === 'success') {
        text = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
          "type": "check".concat(iconType),
          "theme": type === 'line' ? 'filled' : 'outlined'
        }, []);
      }

      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-text"),
        "title": typeof text === 'string' ? text : undefined
      }, [text]);
    };

    return {
      getPercentNumber: getPercentNumber,
      getProgressStatus: getProgressStatus,
      renderProcessInfo: renderProcessInfo,
      configProvider: config_provider_useConfigProvider()
    };
  },
  render: function render() {
    var _classNames;

    var props = this.$props;
    var customizePrefixCls = props.prefixCls,
        size = props.size,
        type = props.type,
        showInfo = props.showInfo;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('progress', customizePrefixCls);
    var progressStatus = this.getProgressStatus();
    var progressInfo = this.renderProcessInfo(prefixCls, progressStatus);
    var progress; // Render progress shape

    if (type === 'line') {
      var lineProps = Object.assign(Object.assign({}, props), {
        prefixCls: prefixCls
      });
      progress = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(progress_line, progress_objectSpread({}, lineProps), [progressInfo]);
    } else if (type === 'circle' || type === 'dashboard') {
      var circleProps = Object.assign(Object.assign({}, props), {
        prefixCls: prefixCls,
        progressStatus: progressStatus
      });
      progress = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(progress_circle, progress_objectSpread({}, circleProps), [progressInfo]);
    }

    var classString = classnames_default()(prefixCls, (_classNames = {}, defineProperty_default()(_classNames, "".concat(prefixCls, "-").concat(type === 'dashboard' && 'circle' || type), true), defineProperty_default()(_classNames, "".concat(prefixCls, "-status-").concat(progressStatus), true), defineProperty_default()(_classNames, "".concat(prefixCls, "-show-info"), showInfo), defineProperty_default()(_classNames, "".concat(prefixCls, "-").concat(size), size), _classNames));
    var progressProps = Object.assign(Object.assign({}, getListenersFromContext(this)), {
      "class": classString
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", progress_objectSpread({}, progressProps), [progress]);
  }
}));
// CONCATENATED MODULE: ./src/components/progress/index.tsx




/* istanbul ignore next */

progress_progress.install = function (Vue) {
  Vue.use(base);
  Vue.component(progress_progress.name, progress_progress);
};

/* harmony default export */ var components_progress = (progress_progress);
// CONCATENATED MODULE: ./src/tools/focus.ts

var focus_useRootFocusBlur = function useRootFocusBlur() {
  var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
  return {
    blur: function blur() {
      if (instance.vnode.el) {
        instance.vnode.el.blur();
      }
    },
    focus: function focus() {
      if (instance.vnode.el) {
        instance.vnode.el.focus();
      }
    }
  };
};
// CONCATENATED MODULE: ./src/components/switch/index.tsx


function switch_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function switch_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { switch_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { switch_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }











var Switch = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'ASwitch',
  __ANT_SWITCH: true,
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    prefixCls: vue_types.string,
    // size=default and size=large are the same
    size: vue_types.oneOf(['small', 'default', 'large']),
    disabled: vue_types.bool,
    checkedChildren: vue_types.any,
    unCheckedChildren: vue_types.any,
    tabIndex: vue_types.oneOfType([vue_types.string, vue_types.number]),
    value: vue_types.bool,
    defaultChecked: vue_types.bool,
    autoFocus: vue_types.bool,
    loading: vue_types.bool
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    form_useForm().registerControl();
    var configProvider = config_provider_useConfigProvider();

    var _useLocalValue = value_useLocalValue(!!props.defaultChecked),
        getValue = _useLocalValue.getValue,
        setValue = _useLocalValue.setValue;

    var _useRootFocusBlur = focus_useRootFocusBlur(),
        focus = _useRootFocusBlur.focus,
        blur = _useRootFocusBlur.blur;

    var setChecked = function setChecked(checked, e) {
      if (props.disabled) {
        return;
      }

      setValue(checked);
      emit('change', checked, e);
    };

    var handleClick = function handleClick(e) {
      var checked = !getValue();
      setChecked(checked, e);

      if (!props.disabled) {
        focus();
      }

      emit('click', checked, e);
    };

    var handleKeyDown = function handleKeyDown(e) {
      if (e.key === 'ArrowLeft') {
        setChecked(false, e);
      } else if (e.key === 'ArrowRight') {
        setChecked(true, e);
      }
    };

    var handleMouseUp = function handleMouseUp(e) {
      blur();
      emit('mouseup', e);
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        var autoFocus = props.autoFocus,
            disabled = props.disabled;

        if (autoFocus && !disabled) {
          focus();
        }
      });
    });
    return {
      focus: focus,
      blur: blur,
      configProvider: configProvider,
      handleKeyDown: handleKeyDown,
      handleMouseUp: handleMouseUp,
      handleClick: handleClick,
      getValue: getValue
    };
  },
  render: function render(ctx) {
    var _switchClassName;

    var customizePrefixCls = ctx.prefixCls,
        size = ctx.size,
        loading = ctx.loading,
        disabled = ctx.disabled;
    var getPrefixCls = ctx.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('switch', customizePrefixCls);
    var checked = ctx.getValue();
    var loadingIcon = loading ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
      "type": "loading",
      "class": "".concat(prefixCls, "-loading-icon")
    }, []) : null;
    var switchClassName = (_switchClassName = {}, defineProperty_default()(_switchClassName, prefixCls, true), defineProperty_default()(_switchClassName, "".concat(prefixCls, "-small"), size === 'small'), defineProperty_default()(_switchClassName, "".concat(prefixCls, "-loading"), loading), defineProperty_default()(_switchClassName, "".concat(prefixCls, "-checked"), checked), defineProperty_default()(_switchClassName, "".concat(prefixCls, "-disabled"), disabled), _switchClassName);
    var instance = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["getCurrentInstance"])();
    var spanProps = Object.assign(Object.assign({}, getListenersFromInstance(instance)), {
      onKeydown: ctx.handleKeyDown,
      onClick: ctx.handleClick,
      onMouseup: ctx.handleMouseUp,
      type: 'button',
      role: 'switch',
      'aria-checked': checked,
      disabled: disabled,
      tabIndex: ctx.tabIndex,
      "class": switchClassName
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(wave, {
      "insertExtraNode": true
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("button", switch_objectSpread({}, spanProps), [loadingIcon, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
      "class": "".concat(prefixCls, "-inner")
    }, [checked ? props_util_getComponentFromProp(instance, 'checkedChildren') : props_util_getComponentFromProp(instance, 'unCheckedChildren')])])]);
  }
});
/* istanbul ignore next */

Switch.install = function (app) {
  app.use(base);
  app.component(Switch.name, Switch);
};

/* harmony default export */ var components_switch = (Switch);
// EXTERNAL MODULE: ./node_modules/lodash/findIndex.js
var findIndex = __webpack_require__("51f5");
var findIndex_default = /*#__PURE__*/__webpack_require__.n(findIndex);

// EXTERNAL MODULE: ./node_modules/lodash/pick.js
var pick = __webpack_require__("2593");
var pick_default = /*#__PURE__*/__webpack_require__.n(pick);

// EXTERNAL MODULE: ./node_modules/lodash/uniqBy.js
var uniqBy = __webpack_require__("a8fc");
var uniqBy_default = /*#__PURE__*/__webpack_require__.n(uniqBy);

// EXTERNAL MODULE: ./node_modules/lodash/partition.js
var partition = __webpack_require__("327d");
var partition_default = /*#__PURE__*/__webpack_require__.n(partition);

// CONCATENATED MODULE: ./src/components/vc-upload/src/attr-accept.ts


function endsWith(str, suffix) {
  return str.indexOf(suffix, str.length - suffix.length) !== -1;
}

/* harmony default export */ var attr_accept = (function (file, acceptedFiles) {
  if (file && acceptedFiles) {
    var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(',');
    var fileName = file.name || '';
    var mimeType = file.type || '';
    var baseMimeType = mimeType.replace(/\/.*$/, '');
    return acceptedFilesArray.some(function (type) {
      var validType = type.trim();

      if (validType.charAt(0) === '.') {
        return endsWith(fileName.toLowerCase(), validType.toLowerCase());
      } else if (/\/\*$/.test(validType)) {
        // This is something like a image/* mime type
        return baseMimeType === validType.replace(/\/.*$/, '');
      }

      return mimeType === validType;
    });
  }

  return true;
});
// CONCATENATED MODULE: ./src/components/vc-upload/src/request.ts


function getError(option, xhr) {
  var msg = "cannot ".concat(option.method, " ").concat(option.action, " ").concat(xhr.status, "'");
  var err = new Error(msg);
  err.status = xhr.status;
  err.method = option.method;
  err.url = option.action;
  return err;
}

function getBody(xhr) {
  var text = xhr.responseText || xhr.response;

  if (!text) {
    return text;
  }

  try {
    return JSON.parse(text);
  } catch (e) {
    return text;
  }
} // option {
//  onProgress: (event: { percent: number }): void,
//  onError: (event: Error, body?: Object): void,
//  onSuccess: (body: Object): void,
//  data: Object,
//  filename: String,
//  file: File,
//  withCredentials: Boolean,
//  action: String,
//  headers: Object,
// }


function request_upload(option) {
  var xhr = new window.XMLHttpRequest();

  if (option.onProgress && xhr.upload) {
    xhr.upload.onprogress = function progress(e) {
      if (e.total > 0) {
        e.percent = e.loaded / e.total * 100;
      }

      option.onProgress(e);
    };
  }

  var formData = new window.FormData();

  if (option.data) {
    Object.keys(option.data).forEach(function (key) {
      var value = option.data[key]; // support key-value array data

      if (Array.isArray(value)) {
        value.forEach(function (item) {
          // { list: [ 11, 22 ] }
          // formData.append('list[]', 11);
          formData.append("".concat(key, "[]"), item);
        });
        return;
      }

      formData.append(key, option.data[key]);
    });
  }

  formData.append(option.filename, option.file);

  xhr.onerror = function error(e) {
    option.onError(e);
  };

  xhr.onload = function onload() {
    // allow success when 2xx status
    // see https://github.com/react-component/upload/issues/34
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(option, xhr), getBody(xhr));
    }

    option.onSuccess(getBody(xhr), xhr);
  };

  xhr.open(option.method, option.action, true); // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179

  if (option.withCredentials && 'withCredentials' in xhr) {
    xhr.withCredentials = true;
  }

  var headers = option.headers || {}; // when set headers['X-Requested-With'] = null , can close default XHR header
  // see https://github.com/react-component/upload/issues/33

  if (headers['X-Requested-With'] !== null) {
    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
  }

  for (var h in headers) {
    if (headers.hasOwnProperty(h) && headers[h] !== null) {
      xhr.setRequestHeader(h, headers[h]);
    }
  }

  xhr.send(formData);
  return {
    abort: function abort() {
      xhr.abort();
    }
  };
}
// CONCATENATED MODULE: ./src/components/vc-upload/src/traverse-file-tree.ts


function traverse_file_tree_createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = traverse_file_tree_unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function traverse_file_tree_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return traverse_file_tree_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return traverse_file_tree_arrayLikeToArray(o, minLen); }

function traverse_file_tree_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function loopFiles(item, callback) {
  var dirReader = item.createReader();
  var fileList = [];

  function sequence() {
    dirReader.readEntries(function (entries) {
      var entryList = Array.prototype.slice.apply(entries);
      fileList = fileList.concat(entryList); // Check if all the file has been viewed

      var isFinished = !entryList.length;

      if (isFinished) {
        callback(fileList);
      } else {
        sequence();
      }
    });
  }

  sequence();
}

var traverseFileTree = function traverseFileTree(files, callback, isAccepted) {
  var _traverseFileTree = function _traverseFileTree(item, path) {
    var copyPath = path;
    copyPath = copyPath || '';

    if (item.isFile) {
      item.file(function (file) {
        if (isAccepted(file)) {
          // https://github.com/ant-design/ant-design/issues/16426
          if (item.fullPath && !file.webkitRelativePath) {
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: true
              }
            });
            file.webkitRelativePath = item.fullPath.replace(/^\//, '');
            Object.defineProperties(file, {
              webkitRelativePath: {
                writable: false
              }
            });
          }

          callback([file]);
        }
      });
    } else if (item.isDirectory) {
      loopFiles(item, function (entries) {
        entries.forEach(function (entryItem) {
          _traverseFileTree(entryItem, "".concat(copyPath).concat(item.name, "/"));
        });
      });
    }
  };

  var _iterator = traverse_file_tree_createForOfIteratorHelper(files),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var file = _step.value;

      _traverseFileTree(file.webkitGetAsEntry());
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
};

/* harmony default export */ var traverse_file_tree = (traverseFileTree);
// CONCATENATED MODULE: ./src/components/vc-upload/src/uid.ts

var uid_now = +new Date();
var uid_index = 0;
function uid_uid() {
  return "vc-upload-".concat(uid_now, "-").concat(++uid_index);
}
// CONCATENATED MODULE: ./src/components/vc-upload/src/ajax-uploader.tsx


function ajax_uploader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function ajax_uploader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ajax_uploader_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ajax_uploader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }











var upLoadPropTypes = {
  componentTag: vue_types.string,
  // style: PropTypes.object,
  prefixCls: vue_types.string,
  name: vue_types.string,
  // className: PropTypes.string,
  multiple: vue_types.bool,
  directory: vue_types.bool,
  disabled: vue_types.bool,
  accept: vue_types.string,
  // children: PropTypes.any,
  // onStart: PropTypes.func,
  data: vue_types.oneOfType([vue_types.object, vue_types.func]),
  action: vue_types.oneOfType([vue_types.string, vue_types.func]),
  method: vue_types.string,
  headers: vue_types.object,
  beforeUpload: vue_types.func,
  customRequest: vue_types.func,
  // onProgress: PropTypes.func,
  withCredentials: vue_types.bool,
  openFileDialogOnClick: vue_types.bool,
  transformFile: vue_types.func
};
var AjaxUploader = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  inheritAttrs: false,
  name: 'ajaxUploader',
  props: upLoadPropTypes,
  setup: function setup($props, _ref) {
    var emit = _ref.emit;
    var reqs = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])([]);
    var uid = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(uid_uid());

    var _isMounted = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);

    var onChange = function onChange(e) {
      var files = e.target.files;
      uploadFiles(files);
      reset();
    };

    var _useRefs = save_ref_useRefs(),
        getRef = _useRefs.getRef,
        saveRef = _useRefs.saveRef;

    var onClick = function onClick() {
      var el = getRef('fileInputRef');

      if (!el) {
        return;
      }

      el.click();
    };

    var onKeyDown = function onKeyDown(e) {
      if (e.key === 'Enter') {
        onClick();
      }
    };

    var onFileDrop = function onFileDrop(e) {
      var multiple = $props.multiple;
      e.preventDefault();

      if (e.type === 'dragover') {
        return;
      }

      if ($props.directory) {
        traverse_file_tree(e.dataTransfer.items, uploadFiles, function (_file) {
          return attr_accept(_file, $props.accept);
        });
      } else {
        var files = partition_default()(Array.prototype.slice.call(e.dataTransfer.files), function (file) {
          return attr_accept(file, $props.accept);
        });
        var successFiles = files[0];
        var errorFiles = files[1];

        if (multiple === false) {
          successFiles = successFiles.slice(0, 1);
        }

        uploadFiles(successFiles);

        if (errorFiles.length) {
          emit('reject', errorFiles);
        }
      }
    };

    var uploadFiles = function uploadFiles(files) {
      var postFiles = Array.prototype.slice.call(files);
      postFiles.map(function (file) {
        file.uid = uid_uid();
        return file;
      }).forEach(function (file) {
        upload(file, postFiles);
      });
    };

    var upload = function upload(file, fileList) {
      if (!$props.beforeUpload) {
        // always async in case use react state to keep fileList
        return setTimeout(function () {
          return post(file);
        }, 0);
      }

      var before = $props.beforeUpload(file, fileList);

      if (before && before.then) {
        before.then(function (processedFile) {
          var processedFileType = Object.prototype.toString.call(processedFile);

          if (processedFileType === '[object File]' || processedFileType === '[object Blob]') {
            return post(processedFile);
          }

          return post(file);
        })["catch"](function (e) {
          console && console.log(e); // eslint-disable-line
        });
      } else if (before !== false) {
        setTimeout(function () {
          return post(file);
        }, 0);
      }
    };

    var post = function post(file) {
      if (!_isMounted.value) {
        return;
      }

      var data = $props.data;
      var _$props$transformFile = $props.transformFile,
          transformFile = _$props$transformFile === void 0 ? function (originFile) {
        return originFile;
      } : _$props$transformFile;
      new Promise(function (resolve) {
        var action = $props.action;

        if (typeof action === 'function') {
          return resolve(action(file));
        }

        resolve(action);
      }).then(function (action) {
        var uid = file.uid;
        var request = $props.customRequest || request_upload;
        var transform = Promise.resolve(transformFile(file))["catch"](function (e) {
          console.error(e); // eslint-disable-line no-console
        });
        transform.then(function (transformedFile) {
          if (typeof data === 'function') {
            data = data(file);
          }

          var requestOption = {
            action: action,
            filename: name,
            data: data,
            file: transformedFile,
            headers: $props.headers,
            withCredentials: $props.withCredentials,
            method: $props.method || 'post',
            onProgress: function onProgress(e) {
              emit('progress', e, file);
            },
            onSuccess: function onSuccess(ret, xhr) {
              delete reqs[uid];
              emit('success', ret, file, xhr);
            },
            onError: function onError(err, ret) {
              delete reqs[uid];
              emit('error', err, ret, file);
            }
          };
          reqs[uid] = request(requestOption);
          emit('start', file);
        });
      });
    };

    var reset = function reset() {
      uid.value = uid_uid();
    };

    var abort = function abort(file) {
      if (file) {
        var _uid = file;

        if (file && file.uid) {
          _uid = file.uid;
        }

        if (reqs.value[_uid] && reqs.value[_uid].abort) {
          reqs.value[_uid].abort();
        }

        delete reqs.value[_uid];
      } else {
        Object.keys(reqs.value).forEach(function (uid) {
          if (reqs.value[uid] && reqs.value[uid].abort) {
            reqs.value[uid].abort();
          }

          delete reqs.value[uid];
        });
      }
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      _isMounted.value = true;
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      _isMounted.value = false;
      abort();
    });
    return {
      onChange: onChange,
      onClick: onClick,
      onKeyDown: onKeyDown,
      onFileDrop: onFileDrop,
      uploadFiles: uploadFiles,
      upload: upload,
      post: post,
      reset: reset,
      abort: abort,
      saveRef: saveRef,
      uid: uid
    };
  },
  render: function render() {
    var _classNames;

    var $props = this.$props,
        $attrs = this.$attrs;
    var Tag = $props.componentTag,
        prefixCls = $props.prefixCls,
        disabled = $props.disabled,
        multiple = $props.multiple,
        accept = $props.accept,
        directory = $props.directory,
        openFileDialogOnClick = $props.openFileDialogOnClick;
    var cls = classnames_default()((_classNames = {}, defineProperty_default()(_classNames, prefixCls, true), defineProperty_default()(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
    var events = disabled ? {} : {
      onClick: openFileDialogOnClick ? this.onClick : function () {},
      onKeydown: openFileDialogOnClick ? this.onKeyDown : function () {},
      onDrop: this.onFileDrop,
      onDragover: this.onFileDrop
    };
    var tagProps = Object.assign(Object.assign(Object.assign({}, getListenersFromContext(this)), events), {
      role: 'button',
      tabIndex: disabled ? null : '0',
      "class": cls
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Tag, ajax_uploader_objectSpread({}, tagProps), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("input", {
      "id": $attrs.id,
      "type": "file",
      "ref": this.saveRef('fileInputRef'),
      "onClick": function onClick(e) {
        return e.stopPropagation();
      },
      "key": this.uid,
      "style": {
        display: 'none'
      },
      "accept": accept,
      "multiple": multiple,
      "onChange": this.onChange
    }, []), this.$slots["default"] && this.$slots["default"]()]);
  }
});
/* harmony default export */ var ajax_uploader = (AjaxUploader);
// CONCATENATED MODULE: ./src/components/vc-upload/src/iframe-uploader.tsx







var IFRAME_STYLE = {
  top: '0',
  opacity: '0',
  filter: 'alpha(opacity=0)',
  left: '0',
  zIndex: 9999
}; // diferent from AjaxUpload, can only upload on at one time, serial seriously

var IframeUploader = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  props: {
    componentTag: vue_types.string,
    beforeUpload: vue_types.func,
    // style: PropTypes.object,
    disabled: vue_types.bool,
    prefixCls: vue_types.string,
    // className: PropTypes.string,
    accept: vue_types.string,
    // onStart: PropTypes.func,
    multiple: vue_types.bool,
    // children: PropTypes.any,
    data: vue_types.oneOfType([vue_types.object, vue_types.func]),
    action: vue_types.oneOfType([vue_types.string, vue_types.func]),
    name: vue_types.string
  },
  data: function data() {
    return {
      uploading: false
    };
  },
  setup: function setup($props, _ref) {
    var emit = _ref.emit;
    var domain = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(undefined);
    var file = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])({});
    var uploading = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(false);

    var onLoad = function onLoad() {
      if (!uploading.value) {
        return;
      }

      var response;

      try {
        var doc = getIframeDocument();
        var script = doc.getElementsByTagName('script')[0];

        if (script && script.parentNode === doc.body) {
          doc.body.removeChild(script);
        }

        response = doc.body.innerHTML;
        emit('success', response, file.value);
      } catch (err) {
        _util_warning(false, 'cross domain error for Upload. Maybe server should return document.domain script. see Note from https://github.com/react-component/upload');
        response = 'cross-domain';
        emit('error', err, null, file.value);
      }

      endUpload();
    };

    var onChange = function onChange() {
      var target = getFormInputNode(); // ie8/9 don't support FileList Object
      // http://stackoverflow.com/questions/12830058/ie8-input-type-file-get-files

      var localFile = {
        uid: uid_uid(),
        name: target.value && target.value.substring(target.value.lastIndexOf('\\') + 1, target.value.length)
      };
      file.value = localFile;
      startUpload();

      if (!$props.beforeUpload) {
        return post(localFile);
      }

      var before = $props.beforeUpload(localFile);

      if (before && before.then) {
        before.then(function () {
          post(localFile);
        }, function () {
          endUpload();
        });
      } else if (before !== false) {
        post(localFile);
      } else {
        endUpload();
      }
    };

    var _useRefs = save_ref_useRefs(),
        getRef = _useRefs.getRef,
        saveRef = _useRefs.saveRef;

    var getIframeNode = function getIframeNode() {
      return getRef('iframeRef');
    };

    var getIframeDocument = function getIframeDocument() {
      return getIframeNode().contentDocument;
    };

    var getFormNode = function getFormNode() {
      return getIframeDocument().getElementById('form');
    };

    var getFormInputNode = function getFormInputNode() {
      return getIframeDocument().getElementById('input');
    };

    var getFormDataNode = function getFormDataNode() {
      return getIframeDocument().getElementById('data');
    };

    var getFileForMultiple = function getFileForMultiple(file) {
      return $props.multiple ? [file] : file;
    };

    var getIframeHTML = function getIframeHTML(domain) {
      var domainScript = '';
      var domainInput = '';

      if (domain) {
        var script = 'script';
        domainScript = "<".concat(script, ">document.domain=\"").concat(domain, "\";</").concat(script, ">");
        domainInput = "<input name=\"_documentDomain\" value=\"".concat(domain, "\" />");
      }

      return "<!DOCTYPE html>\n<html>\n<head>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"/>\n  <style>\n    body, html {\n      padding: 0;\n      margin: 0;\n      border: 0;\n      overflow: hidden;\n    }\n  </style>\n  ".concat(domainScript, "\n</head>\n<body>\n<form method=\"post\"\n      encType=\"multipart/form-data\"\n      action=\"\" id=\"form\"\n      style=\"display:block;height:9999px;position:relative;overflow:hidden;\">\n  <input id=\"input\" type=\"file\"\n         name=\"").concat(name, "\"\n         style=\"position:absolute;top:0;right:0;height:9999px;font-size:9999px;cursor:pointer;\"/>\n  ").concat(domainInput, "\n  <span id=\"data\"></span>\n</form>\n</body>\n</html>\n      ");
    };

    var initIframeSrc = function initIframeSrc() {
      if (domain.value) {
        getIframeNode().src = "javascript:void((function(){\n          var d = document;\n          d.open();\n          d.domain='".concat(domain.value, "';\n          d.write('');\n          d.close();\n        })())");
      }
    };

    var initIframe = function initIframe() {
      var iframeNode = getIframeNode();
      var win = iframeNode.contentWindow;
      var doc;
      domain.value = domain.value || '';
      initIframeSrc();

      try {
        doc = win.document;
      } catch (e) {
        domain.value = document.domain;
        initIframeSrc();
        win = iframeNode.contentWindow;
        doc = win.document;
      }

      doc.open('text/html', 'replace');
      doc.write(getIframeHTML(domain.value));
      doc.close();
      getFormInputNode().onchange = onChange;
    };

    var endUpload = function endUpload() {
      if (uploading) {
        file.value = {}; // hack avoid batch

        uploading.value = false;
        initIframe();
      }
    };

    var startUpload = function startUpload() {
      if (!uploading) {
        uploading.value = true;
      }
    };

    var updateIframeWH = function updateIframeWH() {
      var rootNode = getRef('root');
      var iframeNode = getIframeNode();
      iframeNode.style.height = "".concat(rootNode.offsetHeight, "px");
      iframeNode.style.width = "".concat(rootNode.offsetWidth, "px");
    };

    var abort = function abort(localFile) {
      if (localFile) {
        var uid = localFile;

        if (localFile && localFile.uid) {
          uid = localFile.uid;
        }

        if (uid === file.value.uid) {
          endUpload();
        }
      } else {
        endUpload();
      }
    };

    var post = function post(file) {
      var formNode = getFormNode();
      var dataSpan = getFormDataNode();
      var data = $props.data;

      if (typeof data === 'function') {
        data = data(file);
      }

      var inputs = document.createDocumentFragment();

      for (var key in data) {
        if (data.hasOwnProperty(key)) {
          var input = document.createElement('input');
          input.setAttribute('name', key);
          input.value = data[key];
          inputs.appendChild(input);
        }
      }

      dataSpan.appendChild(inputs);
      new Promise(function (resolve) {
        var action = $props.action;

        if (typeof action === 'function') {
          return resolve(action(file));
        }

        resolve(action);
      }).then(function (action) {
        formNode.setAttribute('action', action);
        formNode.submit();
        dataSpan.innerHTML = '';
        emit('start', file);
      });
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        updateIframeWH();
        initIframe();
      });
    });
    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        updateIframeWH();
      });
    });
    return {
      onLoad: onLoad,
      onChange: onChange,
      getIframeNode: getIframeNode,
      getIframeDocument: getIframeDocument,
      getFormNode: getFormNode,
      getFormInputNode: getFormInputNode,
      getFormDataNode: getFormDataNode,
      getFileForMultiple: getFileForMultiple,
      getIframeHTML: getIframeHTML,
      initIframeSrc: initIframeSrc,
      initIframe: initIframe,
      endUpload: endUpload,
      startUpload: startUpload,
      updateIframeWH: updateIframeWH,
      abort: abort,
      post: post,
      saveRef: saveRef
    };
  },
  render: function render() {
    var _classNames;

    var _this$$props = this.$props,
        Tag = _this$$props.componentTag,
        disabled = _this$$props.disabled,
        prefixCls = _this$$props.prefixCls;
    var iframeStyle = Object.assign(Object.assign({}, IFRAME_STYLE), {
      display: this.uploading || disabled ? 'none' : ''
    });
    var cls = classnames_default()((_classNames = {}, defineProperty_default()(_classNames, prefixCls, true), defineProperty_default()(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(Tag, {
      "ref": this.saveRef('root'),
      "className": cls,
      "style": {
        position: 'relative',
        zIndex: 0
      }
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("iframe", {
      "ref": "iframeRef",
      "onLoad": this.onLoad,
      "style": iframeStyle
    }, []), this.$slots["default"] && this.$slots["default"]()]);
  }
});
/* harmony default export */ var iframe_uploader = (IframeUploader);
// CONCATENATED MODULE: ./src/components/vc-upload/src/upload.tsx


function upload_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function upload_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { upload_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { upload_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }








function upload_empty() {}

var uploadProps = {
  componentTag: vue_types.string,
  prefixCls: vue_types.string,
  action: vue_types.oneOfType([vue_types.string, vue_types.func]),
  name: vue_types.string,
  multipart: vue_types.bool,
  directory: vue_types.bool,
  // onError: PropTypes.func,
  // onSuccess: PropTypes.func,
  // onProgress: PropTypes.func,
  // onStart: PropTypes.func,
  data: vue_types.oneOfType([vue_types.object, vue_types.func]),
  headers: vue_types.object,
  accept: vue_types.string,
  multiple: vue_types.bool,
  disabled: vue_types.bool,
  beforeUpload: vue_types.func,
  customRequest: vue_types.func,
  // onReady: PropTypes.func,
  withCredentials: vue_types.bool,
  supportServerRender: vue_types.bool,
  openFileDialogOnClick: vue_types.bool
};
/* harmony default export */ var src_upload = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'Upload',
  inheritAttrs: false,
  props: initDefaultProps(uploadProps, {
    componentTag: 'span',
    prefixCls: 'rc-upload',
    data: {},
    headers: {},
    name: 'file',
    multipart: false,
    // onReady: empty,
    // onStart: empty,
    // onError: empty,
    // onSuccess: empty,
    supportServerRender: false,
    multiple: false,
    beforeUpload: upload_empty,
    withCredentials: false,
    openFileDialogOnClick: true
  }),
  setup: function setup($props, _ref) {
    var emit = _ref.emit;
    var component = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var _useRefs = save_ref_useRefs(),
        getRef = _useRefs.getRef,
        saveRef = _useRefs.saveRef;

    var getComponent = function getComponent() {
      return typeof File !== 'undefined' ? ajax_uploader : iframe_uploader;
    };

    var abort = function abort(file) {
      getRef('uploaderRef').abort(file);
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onMounted"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        if ($props.supportServerRender) {
          component.value = getComponent();
          Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
            emit('ready');
          });
        }
      });
    });
    return {
      getComponent: getComponent,
      abort: abort,
      saveRef: saveRef,
      component: component
    };
  },
  render: function render() {
    var componentProps = Object.assign(Object.assign(Object.assign(Object.assign({}, this.$attrs), this.$props), getListenersFromContext(this)), {
      ref: this.saveRef('uploaderRef')
    });

    if (this.supportServerRender) {
      var _ComponentUploader = this.component;

      if (_ComponentUploader) {
        return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(_ComponentUploader, upload_objectSpread({}, componentProps), [this.$slots["default"] && this.$slots["default"]()]);
      }

      return null;
    }

    var ComponentUploader = this.getComponent();
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(ComponentUploader, upload_objectSpread({}, componentProps), [this.$slots["default"] && this.$slots["default"]()]);
  }
}));
// CONCATENATED MODULE: ./src/components/vc-upload/src/index.ts

// export this package's api

/* harmony default export */ var vc_upload_src = (src_upload);
// CONCATENATED MODULE: ./src/components/vc-upload/index.js

// rc-upload 2.9.4

/* harmony default export */ var vc_upload = (vc_upload_src);
// CONCATENATED MODULE: ./src/components/upload/interface.tsx



var UploadFileStatus = vue_types.oneOf(['error', 'success', 'done', 'uploading', 'removed']); // export const HttpRequestHeader {
//   [key: string]: string;
// }
// export const UploadFile = PropsTypes.shape({
//   uid: PropsTypes.oneOfType([
//     PropsTypes.string,
//     PropsTypes.number,
//   ]),
//   size: PropsTypes.number,
//   name: PropsTypes.string,
//   filename: PropsTypes.string,
//   lastModified: PropsTypes.number,
//   lastModifiedDate: PropsTypes.any,
//   url: PropsTypes.string,
//   status: UploadFileStatus,
//   percent: PropsTypes.number,
//   thumbUrl: PropsTypes.string,
//   originFileObj: PropsTypes.any,
//   response: PropsTypes.any,
//   error: PropsTypes.any,
//   linkProps: PropsTypes.any,
//   type: PropsTypes.string,
// }).loose

function UploadFile(_ref) {
  var uid = _ref.uid,
      name = _ref.name;

  if (!uid && uid !== 0) {
    return false;
  }

  if (!['string', 'number'].includes(typeof_default()(uid))) {
    return false;
  }

  return !(name === '' || typeof name !== 'string');
}

var UploadChangeParam = {
  file: vue_types.custom(UploadFile),
  fileList: vue_types.arrayOf(vue_types.custom(UploadFile)),
  event: vue_types.object
};
var ShowUploadListInterface = vue_types.shape({
  showRemoveIcon: vue_types.bool,
  showPreviewIcon: vue_types.bool
}).loose;
var UploadLocale = vue_types.shape({
  uploading: vue_types.string,
  removeFile: vue_types.string,
  downloadFile: vue_types.string,
  uploadError: vue_types.string,
  previewFile: vue_types.string
}).loose;
var UploadProps = {
  type: vue_types.oneOf(['drag', 'select']),
  name: vue_types.string,
  defaultFileList: vue_types.arrayOf(vue_types.custom(UploadFile)),
  fileList: vue_types.arrayOf(vue_types.custom(UploadFile)),
  action: vue_types.oneOfType([vue_types.string, vue_types.func]),
  directory: vue_types.bool,
  data: vue_types.oneOfType([vue_types.object, vue_types.func]),
  method: vue_types.oneOf(['POST', 'PUT', 'post', 'put']),
  headers: vue_types.object,
  showUploadList: vue_types.oneOfType([vue_types.bool, ShowUploadListInterface]),
  multiple: vue_types.bool,
  accept: vue_types.string,
  beforeUpload: vue_types.func,
  // onChange: PropsTypes.func,
  listType: vue_types.oneOf(['text', 'picture', 'picture-card']),
  // className: PropsTypes.string,
  // onPreview: PropsTypes.func,
  remove: vue_types.func,
  supportServerRender: vue_types.bool,
  // style: PropsTypes.object,
  disabled: vue_types.bool,
  prefixCls: vue_types.string,
  customRequest: vue_types.func,
  withCredentials: vue_types.bool,
  openFileDialogOnClick: vue_types.bool,
  locale: UploadLocale,
  height: vue_types.number,
  id: vue_types.string,
  previewFile: vue_types.func,
  transformFile: vue_types.func
};
var UploadState = {
  fileList: vue_types.arrayOf(vue_types.custom(UploadFile)),
  dragState: vue_types.string
};
var UploadListProps = {
  listType: vue_types.oneOf(['text', 'picture', 'picture-card']),
  // onPreview: PropsTypes.func,
  // onRemove: PropsTypes.func,
  // items: PropsTypes.arrayOf(UploadFile),
  items: vue_types.arrayOf(vue_types.custom(UploadFile)),
  // items: PropsTypes.any,
  progressAttr: vue_types.object,
  prefixCls: vue_types.string,
  showRemoveIcon: vue_types.bool,
  showDownloadIcon: vue_types.bool,
  showPreviewIcon: vue_types.bool,
  locale: UploadLocale,
  previewFile: vue_types.func
};
// CONCATENATED MODULE: ./src/components/upload/dragger.tsx


function dragger_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function dragger_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { dragger_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { dragger_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }





/* harmony default export */ var dragger = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AUploadDragger',
  props: UploadProps,
  render: function render() {
    var props = this.$props;
    var draggerProps = Object.assign(Object.assign(Object.assign(Object.assign({}, props), {
      type: 'drag'
    }), getListenersFromContext(this)), {
      style: {
        height: this.height
      }
    });
    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(upload_upload, dragger_objectSpread({}, draggerProps), [this.$slots["default"] && this.$slots["default"]()]);
  }
}));
// CONCATENATED MODULE: ./src/components/upload/utils.tsx

function T() {
  return true;
} // Fix IE file.status problem
// via coping a new Object

function fileToObject(file) {
  return Object.assign(Object.assign({}, file), {
    lastModified: file.lastModified,
    lastModifiedDate: file.lastModifiedDate,
    name: file.name,
    size: file.size,
    type: file.type,
    uid: file.uid,
    percent: 0,
    originFileObj: file
  });
}
/**
 * 生成Progress percent: 0.1 -> 0.98
 *   - for ie
 */

function genPercentAdd() {
  var k = 0.1;
  var i = 0.01;
  var end = 0.98;
  return function (s) {
    var start = s;

    if (start >= end) {
      return start;
    }

    start += k;
    k = k - i;

    if (k < 0.001) {
      k = 0.001;
    }

    return start;
  };
}
function getFileItem(file, fileList) {
  var matchKey = file.uid !== undefined ? 'uid' : 'name';
  return fileList.filter(function (item) {
    return item[matchKey] === file[matchKey];
  })[0];
}
function removeFileItem(file, fileList) {
  var matchKey = file.uid !== undefined ? 'uid' : 'name';
  var removed = fileList.filter(function (item) {
    return item[matchKey] !== file[matchKey];
  });

  if (removed.length === fileList.length) {
    return null;
  }

  return removed;
} // ==================== Default Image Preview ====================

var extname = function extname() {
  var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var temp = url.split('/');
  var filename = temp[temp.length - 1];
  var filenameWithoutSuffix = filename.split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [''])[0];
};

var isImageFileType = function isImageFileType(type) {
  return !!type && type.indexOf('image/') === 0;
};

var isImageUrl = function isImageUrl(file) {
  if (isImageFileType(file.type)) {
    return true;
  }

  var url = file.thumbUrl || file.url;
  var extension = extname(url);

  if (/^data:image\//.test(url) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i.test(extension)) {
    return true;
  }

  if (/^data:/.test(url)) {
    // other file types of base64
    return false;
  }

  if (extension) {
    // other file types which have extension
    return false;
  }

  return true;
};
var MEASURE_SIZE = 200;
function previewImage(file) {
  return new Promise(function (resolve) {
    if (!isImageFileType(file.type)) {
      resolve('');
      return;
    }

    var canvas = document.createElement('canvas');
    canvas.width = MEASURE_SIZE;
    canvas.height = MEASURE_SIZE;
    canvas.style.cssText = "position: fixed; left: 0; top: 0; width: ".concat(MEASURE_SIZE, "px; height: ").concat(MEASURE_SIZE, "px; z-index: 9999; display: none;");
    document.body.appendChild(canvas);
    var ctx = canvas.getContext('2d');
    var img = new Image();

    img.onload = function () {
      var width = img.width,
          height = img.height;
      var drawWidth = MEASURE_SIZE;
      var drawHeight = MEASURE_SIZE;
      var offsetX = 0;
      var offsetY = 0;

      if (width < height) {
        drawHeight = height * (MEASURE_SIZE / width);
        offsetY = -(drawHeight - drawWidth) / 2;
      } else {
        drawWidth = width * (MEASURE_SIZE / height);
        offsetX = -(drawWidth - drawHeight) / 2;
      }

      ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      var dataURL = canvas.toDataURL();
      document.body.removeChild(canvas);
      resolve(dataURL);
    };

    img.src = window.URL.createObjectURL(file);
  });
}
// CONCATENATED MODULE: ./src/components/upload/upload-list.tsx


function upload_list_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function upload_list_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { upload_list_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { upload_list_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }











/* harmony default export */ var upload_list = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AUploadList',
  props: initDefaultProps(UploadListProps, {
    listType: 'text',
    progressAttr: {
      strokeWidth: 2,
      showInfo: false
    },
    showRemoveIcon: true,
    showDownloadIcon: false,
    showPreviewIcon: true,
    previewFile: function previewFile() {
      return previewImage;
    }
  }),
  setup: function setup($props, _ref) {
    var emit = _ref.emit,
        $attrs = _ref.attrs;

    var handlePreview = function handlePreview(file, e) {
      var _getListenersFromCont = getListenersFromContext({
        $props: $props,
        $attrs: $attrs
      }),
          preview = _getListenersFromCont.preview;

      if (!preview) {
        return;
      }

      e.preventDefault();
      return emit('preview', file);
    };

    var handleDownload = function handleDownload(file) {
      var _getListenersFromCont2 = getListenersFromContext({
        $props: $props,
        $attrs: $attrs
      }),
          download = _getListenersFromCont2.download;

      if (typeof download === 'function') {
        download(file);
      } else if (file.url) {
        window.open(file.url);
      }
    };

    var handleClose = function handleClose(file) {
      emit('remove', file);
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onUpdated"])(function () {
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function () {
        var listType = $props.listType,
            items = $props.items,
            previewFile = $props.previewFile;

        if (listType !== 'picture' && listType !== 'picture-card') {
          return;
        }

        (items || []).forEach(function (file) {
          if (typeof document === 'undefined' || typeof window === 'undefined' || !window.FileReader || !window.File || !(file.originFileObj instanceof File || file.originFileObj instanceof Blob) || file.thumbUrl !== undefined) {
            return;
          }
          /*eslint-disable */


          file.thumbUrl = '';

          if (previewFile) {
            previewFile(file.originFileObj).then(function (previewDataUrl) {
              // Need append '' to avoid dead loop
              file.thumbUrl = previewDataUrl || '';
            });
          }
        });
      });
    });
    return {
      handlePreview: handlePreview,
      handleDownload: handleDownload,
      handleClose: handleClose,
      configProvider: config_provider_useConfigProvider()
    };
  },
  render: function render() {
    var _this = this,
        _classNames4;

    var _this$$props = this.$props,
        customizePrefixCls = _this$$props.prefixCls,
        _this$$props$items = _this$$props.items,
        items = _this$$props$items === void 0 ? [] : _this$$props$items,
        listType = _this$$props.listType,
        showPreviewIcon = _this$$props.showPreviewIcon,
        showRemoveIcon = _this$$props.showRemoveIcon,
        showDownloadIcon = _this$$props.showDownloadIcon,
        locale = _this$$props.locale,
        progressAttr = _this$$props.progressAttr;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('upload', customizePrefixCls);
    var list = items.map(function (file) {
      var _classNames, _classNames2;

      var progress;
      var icon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": file.status === 'uploading' ? 'loading' : 'paper-clip'
      }, []);

      if (listType === 'picture' || listType === 'picture-card') {
        if (listType === 'picture-card' && file.status === 'uploading') {
          icon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
            "class": "".concat(prefixCls, "-list-item-uploading-text")
          }, [locale.uploading]);
        } else if (!file.thumbUrl && !file.url) {
          icon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
            "class": "".concat(prefixCls, "-list-item-thumbnail"),
            "type": "picture",
            "theme": "twoTone"
          }, []);
        } else {
          var thumbnail = isImageUrl(file) ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("img", {
            "src": file.thumbUrl || file.url,
            "alt": file.name,
            "class": "".concat(prefixCls, "-list-item-image")
          }, []) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
            "type": "file",
            "class": "".concat(prefixCls, "-list-item-icon"),
            "theme": "twoTone"
          }, []);
          icon = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
            "class": "".concat(prefixCls, "-list-item-thumbnail"),
            "onClick": function onClick(e) {
              return _this.handlePreview(file, e);
            },
            "href": file.url || file.thumbUrl,
            "target": "_blank",
            "rel": "noopener noreferrer"
          }, [thumbnail]);
        }
      }

      if (file.status === 'uploading') {
        var progressProps = Object.assign(Object.assign({}, progressAttr), {
          type: 'line',
          percent: file.percent
        }); // show loading icon if upload progress listener is disabled

        var loadingProgress = 'percent' in file ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_progress, upload_list_objectSpread({}, progressProps), []) : null;
        progress = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
          "class": "".concat(prefixCls, "-list-item-progress"),
          "key": "progress"
        }, [loadingProgress]);
      }

      var infoUploadingClass = classnames_default()((_classNames = {}, defineProperty_default()(_classNames, "".concat(prefixCls, "-list-item"), true), defineProperty_default()(_classNames, "".concat(prefixCls, "-list-item-").concat(file.status), true), defineProperty_default()(_classNames, "".concat(prefixCls, "-list-item-list-type-").concat(listType), true), _classNames));
      var linkProps = typeof file.linkProps === 'string' ? JSON.parse(file.linkProps) : file.linkProps;
      var removeIcon = showRemoveIcon ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "delete",
        "title": locale.removeFile,
        "onClick": function onClick() {
          return _this.handleClose(file);
        }
      }, []) : null;
      var downloadIcon = showDownloadIcon && file.status === 'done' ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "download",
        "title": locale.downloadFile,
        "onClick": function onClick() {
          return _this.handleDownload(file);
        }
      }, []) : null;
      var downloadOrDelete = listType !== 'picture-card' && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "key": "download-delete",
        "class": "".concat(prefixCls, "-list-item-card-actions ").concat(listType === 'picture' ? 'picture' : '')
      }, [downloadIcon && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
        "title": locale.downloadFile
      }, [downloadIcon]), removeIcon && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
        "title": locale.removeFile
      }, [removeIcon])]);
      var listItemNameClass = classnames_default()((_classNames2 = {}, defineProperty_default()(_classNames2, "".concat(prefixCls, "-list-item-name"), true), defineProperty_default()(_classNames2, "".concat(prefixCls, "-list-item-name-icon-count-").concat([downloadIcon, removeIcon].filter(function (x) {
        return x;
      }).length), true), _classNames2));
      var preview = file.url ? [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", upload_list_objectSpread({
        "target": "_blank",
        "rel": "noopener noreferrer",
        "class": listItemNameClass,
        "title": file.name
      }, linkProps, {
        "href": file.url,
        "onClick": function onClick(e) {
          return _this.handlePreview(file, e);
        }
      }), [file.name]), downloadOrDelete] : [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "key": "view",
        "class": "".concat(prefixCls, "-list-item-name"),
        "onClick": function onClick(e) {
          return _this.handlePreview(file, e);
        },
        "title": file.name
      }, [file.name]), downloadOrDelete];
      var style = file.url || file.thumbUrl ? undefined : {
        pointerEvents: 'none',
        opacity: 0.5
      };
      var previewIcon = showPreviewIcon ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("a", {
        "href": file.url || file.thumbUrl,
        "target": "_blank",
        "rel": "noopener noreferrer",
        "style": style,
        "onClick": function onClick(e) {
          return _this.handlePreview(file, e);
        },
        "title": locale.previewFile
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_icon, {
        "type": "eye-o"
      }, [])]) : null;
      var actions = listType === 'picture-card' && file.status !== 'uploading' && Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-list-item-actions")
      }, [previewIcon, file.status === 'done' && downloadIcon, removeIcon]);
      var message;

      if (file.response && typeof file.response === 'string') {
        message = file.response;
      } else {
        message = file.error && file.error.statusText || locale.uploadError;
      }

      var iconAndPreview = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {}, [icon, preview]);
      var transitionProps = get_transition_props('fade');
      var dom = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": infoUploadingClass,
        "key": file.uid
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": "".concat(prefixCls, "-list-item-info")
      }, [iconAndPreview]), actions, Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["Transition"], upload_list_objectSpread({}, transitionProps), [progress])]);
      var listContainerNameClass = classnames_default()(defineProperty_default()({}, "".concat(prefixCls, "-list-picture-card-container"), listType === 'picture-card'));
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "key": file.uid,
        "class": listContainerNameClass
      }, [file.status === 'error' ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(components_tooltip, {
        "title": message
      }, [dom]) : Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {}, [dom])]);
    });
    var listClassNames = classnames_default()((_classNames4 = {}, defineProperty_default()(_classNames4, "".concat(prefixCls, "-list"), true), defineProperty_default()(_classNames4, "".concat(prefixCls, "-list-").concat(listType), true), _classNames4));
    var animationDirection = listType === 'picture-card' ? 'animate-inline' : 'animate';
    var transitionGroupProps = get_transition_props("".concat(prefixCls, "-").concat(animationDirection));
    return (// @ts-ignore
      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(external_commonjs_vue_commonjs2_vue_root_Vue_["TransitionGroup"], upload_list_objectSpread({}, transitionGroupProps, {
        "tag": "div",
        "class": listClassNames
      }), [list])
    );
  }
}));
// CONCATENATED MODULE: ./src/components/upload/upload.tsx


function upload_upload_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function upload_upload_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { upload_upload_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { upload_upload_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

















/* harmony default export */ var upload_upload = (Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
  name: 'AUpload',
  inheritAttrs: false,
  Dragger: dragger,
  props: initDefaultProps(UploadProps, {
    type: 'select',
    multiple: false,
    action: '',
    data: function data() {},
    accept: '',
    beforeUpload: function beforeUpload() {
      return T;
    },
    showUploadList: true,
    listType: 'text',
    disabled: false,
    supportServerRender: false
  }),
  setup: function setup($props, _ref) {
    var emit = _ref.emit,
        $attrs = _ref.attrs;

    var _useLocalValue = value_useLocalValue($props.defaultFileList || [], 'fileList'),
        sFileList = _useLocalValue.value,
        setFileList = _useLocalValue.setValue;

    var dragState = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])('drop');
    var progressTimer = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["ref"])(null);

    var onStart = function onStart(file) {
      var targetItem = fileToObject(file);
      targetItem.status = 'uploading';
      var nextFileList = sFileList.value.concat();
      var fileIndex = findIndex_default()(nextFileList, function (_ref2) {
        var uid = _ref2.uid;
        return uid === targetItem.uid;
      });

      if (fileIndex === -1) {
        nextFileList.push(targetItem);
      } else {
        nextFileList[fileIndex] = targetItem;
      }

      onChange({
        file: targetItem,
        fileList: nextFileList
      }); // fix ie progress

      if (!window.File || Object({"NODE_ENV":"production","BASE_URL":"/"}).TEST_IE) {
        autoUpdateProgress(0, targetItem);
      }
    };

    var onSuccess = function onSuccess(response, file, xhr) {
      clearProgressTimer();
      var copyResponse = response;

      try {
        if (typeof copyResponse === 'string') {
          copyResponse = JSON.parse(copyResponse);
        }
      } catch (e) {
        /* do nothing */
      }

      var fileList = sFileList.value;
      var targetItem = getFileItem(file, fileList); // removed

      if (!targetItem) {
        return;
      }

      targetItem.status = 'done';
      targetItem.response = copyResponse;
      targetItem.xhr = xhr;
      onChange({
        file: Object.assign({}, targetItem),
        fileList: fileList
      });
    };

    var _useRefs = save_ref_useRefs(),
        getRef = _useRefs.getRef,
        saveRef = _useRefs.saveRef;

    var onProgress = function onProgress(e, file) {
      var fileList = sFileList.value;
      var targetItem = getFileItem(file, fileList); // removed

      if (!targetItem) {
        return;
      }

      targetItem.percent = e.percent;
      onChange({
        event: e,
        file: Object.assign({}, targetItem),
        fileList: sFileList.value
      });
    };

    var onError = function onError(error, response, file) {
      clearProgressTimer();
      var fileList = sFileList.value;
      var targetItem = getFileItem(file, fileList); // removed

      if (!targetItem) {
        return;
      }

      targetItem.error = error;
      targetItem.response = response;
      targetItem.status = 'error';
      onChange({
        file: Object.assign({}, targetItem),
        fileList: fileList
      });
    };

    var onReject = function onReject(fileList) {
      emit('reject', fileList);
    };

    var handleRemove = function handleRemove(file) {
      var onRemove = $props.remove;
      var fileList = sFileList.value;
      Promise.resolve(typeof onRemove === 'function' ? onRemove(file) : onRemove).then(function (ret) {
        // Prevent removing file
        if (ret === false) {
          return;
        }

        var removedFileList = removeFileItem(file, fileList);

        if (removedFileList) {
          file.status = 'removed'; // eslint-disable-line

          onChange({
            file: file,
            fileList: removedFileList
          });
        }
      });
    };

    var handleManualRemove = function handleManualRemove(file) {
      if (getRef('uploadRef')) {
        getRef('uploadRef').abort(file);
      }

      handleRemove(file);
    };

    var onChange = function onChange(info) {
      setFileList(info.fileList);
      emit('change', info);
    };

    var onFileDrop = function onFileDrop(e) {
      dragState.value = e.type;
    };

    var reBeforeUpload = function reBeforeUpload(file, fileList) {
      var beforeUpload = $props.beforeUpload;
      var stateFileList = sFileList.value;

      if (!beforeUpload) {
        return true;
      }

      var result = beforeUpload(file, fileList);

      if (result === false) {
        onChange({
          file: file,
          fileList: uniqBy_default()(stateFileList.concat(fileList.map(fileToObject)), function (item) {
            return item.uid;
          })
        });
        return false;
      }

      if (result && result.then) {
        return result;
      }

      return true;
    };

    var clearProgressTimer = function clearProgressTimer() {
      clearInterval(progressTimer.value);
    };

    var autoUpdateProgress = function autoUpdateProgress(_, file) {
      var getPercent = genPercentAdd();
      var curPercent = 0;
      clearProgressTimer();
      progressTimer.value = setInterval(function () {
        curPercent = getPercent(curPercent);
        onProgress({
          percent: curPercent * 100
        }, file);
      }, 200);
    };

    var renderUploadList = function renderUploadList(locale) {
      var _$props$showUploadLis = $props.showUploadList,
          showUploadList = _$props$showUploadLis === void 0 ? {} : _$props$showUploadLis,
          listType = $props.listType,
          previewFile = $props.previewFile,
          disabled = $props.disabled,
          propLocale = $props.locale;
      var showRemoveIcon = showUploadList.showRemoveIcon,
          showPreviewIcon = showUploadList.showPreviewIcon,
          showDownloadIcon = showUploadList.showDownloadIcon;
      var fileList = sFileList.value;
      var uploadListProps = Object.assign({
        listType: listType,
        items: fileList,
        previewFile: previewFile,
        showRemoveIcon: !disabled && showRemoveIcon,
        showPreviewIcon: showPreviewIcon,
        showDownloadIcon: showDownloadIcon,
        locale: Object.assign(Object.assign({}, locale), propLocale),
        onRemove: handleManualRemove
      }, pick_default()(getListenersFromContext({
        $props: $props,
        $attrs: $attrs
      }), ['onDownload', 'onPreview']) // 如果没有配置该事件，不要传递，
      // uploadlist 会有相应逻辑
      );
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(upload_list, upload_upload_objectSpread({}, uploadListProps), []);
    };

    Object(external_commonjs_vue_commonjs2_vue_root_Vue_["onBeforeUnmount"])(function () {
      clearProgressTimer();
    });
    return {
      onStart: onStart,
      onSuccess: onSuccess,
      onProgress: onProgress,
      onError: onError,
      onReject: onReject,
      handleRemove: handleRemove,
      handleManualRemove: handleManualRemove,
      onChange: onChange,
      onFileDrop: onFileDrop,
      reBeforeUpload: reBeforeUpload,
      clearProgressTimer: clearProgressTimer,
      autoUpdateProgress: autoUpdateProgress,
      renderUploadList: renderUploadList,
      saveRef: saveRef,
      sFileList: sFileList,
      dragState: dragState,
      configProvider: config_provider_useConfigProvider()
    };
  },
  render: function render() {
    var _classNames2;

    var customizePrefixCls = this.prefixCls,
        showUploadList = this.showUploadList,
        listType = this.listType,
        type = this.type,
        disabled = this.disabled,
        dragState = this.dragState,
        fileList = this.sFileList;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('upload', customizePrefixCls);
    var vcUploadProps = Object.assign(Object.assign(Object.assign({}, this.$props), {
      prefixCls: prefixCls,
      beforeUpload: this.reBeforeUpload,
      onStart: this.onStart,
      onError: this.onError,
      onProgress: this.onProgress,
      onSuccess: this.onSuccess,
      onReject: this.onReject,
      ref: this.saveRef('uploadRef')
    }), this.$attrs);
    var uploadList = showUploadList ? this.renderUploadList(locale_provider_default.Upload) : null;
    var children = this.$slots["default"] && this.$slots["default"]();

    if (type === 'drag') {
      var _classNames;

      var dragCls = classnames_default()(prefixCls, (_classNames = {}, defineProperty_default()(_classNames, "".concat(prefixCls, "-drag"), true), defineProperty_default()(_classNames, "".concat(prefixCls, "-drag-uploading"), fileList.some(function (file) {
        return file.status === 'uploading';
      })), defineProperty_default()(_classNames, "".concat(prefixCls, "-drag-hover"), dragState === 'dragover'), defineProperty_default()(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {}, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": dragCls,
        "onDrop": this.onFileDrop,
        "onDragover": this.onFileDrop,
        "onDragleave": this.onFileDrop
      }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_upload, upload_upload_objectSpread({}, vcUploadProps, {
        "class": "".concat(prefixCls, "-btn")
      }), [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
        "class": "".concat(prefixCls, "-drag-container")
      }, [children])])]), uploadList]);
    }

    var uploadButtonCls = classnames_default()(prefixCls, (_classNames2 = {}, defineProperty_default()(_classNames2, "".concat(prefixCls, "-select"), true), defineProperty_default()(_classNames2, "".concat(prefixCls, "-select-").concat(listType), true), defineProperty_default()(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _classNames2)); // Remove id to avoid open by label when trigger is hidden
    // https://github.com/ant-design/ant-design/issues/14298

    if (!children || disabled) {
      delete vcUploadProps.id;
    }

    var uploadButton = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("div", {
      "class": uploadButtonCls,
      "style": children ? undefined : {
        display: 'none'
      }
    }, [Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])(vc_upload, upload_upload_objectSpread({}, vcUploadProps), [children])]);

    if (listType === 'picture-card') {
      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {
        "class": "".concat(prefixCls, "-picture-card-wrapper")
      }, [uploadList, uploadButton]);
    }

    return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("span", {}, [uploadButton, uploadList]);
  }
}));
// CONCATENATED MODULE: ./src/components/upload/index.tsx





upload_upload.Dragger = dragger;
/* istanbul ignore next */

upload_upload.install = function (Vue) {
  Vue.use(base);
  Vue.component(upload_upload.name, upload_upload);
  Vue.component(dragger.name, dragger);
};

/* harmony default export */ var components_upload = (upload_upload);
// CONCATENATED MODULE: ./src/components/index.ts

// 导入颜色选择器组件


























 // 注册moment中文国际化文案

if (window.moment) {
  window.moment.locale('zh-cn', moment_zh_CN);
} else {
  moment_default.a.locale('zh-cn', moment_zh_CN);
}

if (window.AntDesignIcons) {
  // 注册 ant design icons, 共721个icon
  var icons = window.AntDesignIcons;
  Object.keys(icons).forEach(function (icon) {
    icons_vue.add(icons[icon]);
  });
} // 存储组件列表


var components_components = [components_button, components_affix, components_tree, components_cascader, components_calendar, components_select, components_card, components_dropdown, components_breadcrumb, components_checkbox, date_picker, components_grid, components_layout, components_icon, components_input, components_menu, components_modal, components_pagination, components_progress, components_radio, components_switch, components_tabs, components_tag, components_upload]; // 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册

var components_install = function install(app) {
  // 判断是否可以安装
  // if (install.installed) return
  // 遍历注册全局组件
  components_components.forEach(function (comp) {
    return app.use(comp);
  });
};


/* harmony default export */ var src_components = ({
  // 导出的对象必须具有 install，才能被 Vue.use() 方法安装
  install: components_install,
  Button: components_button,
  Affix: components_affix,
  Tree: components_tree,
  Cascader: components_cascader,
  Calendar: components_calendar,
  Select: components_select,
  Card: components_card,
  Dropdown: components_dropdown,
  Breadcrumb: components_breadcrumb,
  Checkbox: components_checkbox,
  DatePicker: date_picker,
  Grid: components_grid,
  Layout: components_layout,
  Icon: components_icon,
  Input: components_input,
  Menu: components_menu,
  Modal: components_modal,
  Pagination: components_pagination,
  Progress: components_progress,
  Radio: components_radio,
  Switch: components_switch,
  Tabs: components_tabs,
  Tag: components_tag,
  Upload: components_upload
});
// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = __webpack_exports__["default"] = (src_components);



/***/ }),

/***/ "fba5":
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__("cb5a");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "fd7e":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var xPseudo = moment.defineLocale('x-pseudo', {
        months : 'J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér'.split('_'),
        monthsShort : 'J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc'.split('_'),
        monthsParseExact : true,
        weekdays : 'S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý'.split('_'),
        weekdaysShort : 'S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát'.split('_'),
        weekdaysMin : 'S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[T~ódá~ý át] LT',
            nextDay : '[T~ómó~rró~w át] LT',
            nextWeek : 'dddd [át] LT',
            lastDay : '[Ý~ést~érdá~ý át] LT',
            lastWeek : '[L~ást] dddd [át] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'í~ñ %s',
            past : '%s á~gó',
            s : 'á ~féw ~sécó~ñds',
            ss : '%d s~écóñ~ds',
            m : 'á ~míñ~úté',
            mm : '%d m~íñú~tés',
            h : 'á~ñ hó~úr',
            hh : '%d h~óúrs',
            d : 'á ~dáý',
            dd : '%d d~áýs',
            M : 'á ~móñ~th',
            MM : '%d m~óñt~hs',
            y : 'á ~ýéár',
            yy : '%d ý~éárs'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return xPseudo;

})));


/***/ }),

/***/ "ffd6":
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__("3729"),
    isObjectLike = __webpack_require__("1310");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "ffff":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__("c1df")) :
   undefined
}(this, (function (moment) { 'use strict';


    var se = moment.defineLocale('se', {
        months : 'ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu'.split('_'),
        monthsShort : 'ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov'.split('_'),
        weekdays : 'sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat'.split('_'),
        weekdaysShort : 'sotn_vuos_maŋ_gask_duor_bear_láv'.split('_'),
        weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'MMMM D. [b.] YYYY',
            LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
            LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
        },
        calendar : {
            sameDay: '[otne ti] LT',
            nextDay: '[ihttin ti] LT',
            nextWeek: 'dddd [ti] LT',
            lastDay: '[ikte ti] LT',
            lastWeek: '[ovddit] dddd [ti] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s geažes',
            past : 'maŋit %s',
            s : 'moadde sekunddat',
            ss: '%d sekunddat',
            m : 'okta minuhta',
            mm : '%d minuhtat',
            h : 'okta diimmu',
            hh : '%d diimmut',
            d : 'okta beaivi',
            dd : '%d beaivvit',
            M : 'okta mánnu',
            MM : '%d mánut',
            y : 'okta jahki',
            yy : '%d jagit'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return se;

})));


/***/ })

/******/ });
});
//# sourceMappingURL=antd-vue3.umd.js.map